perf record: Avoid infinite loop at buildid processing with no samples

If a session contains no events, we can get stuck in an infinite loop in
__perf_session__process_events, with a non-zero file_size and data_offset, but
a zero data_size.

In this case, we can mmap the entirety of the file (consisting of the file and
attribute headers), and fetch_mmaped_event will correctly refuse to read any
(unmapped and non-existent) event headers. This causes
__perf_session__process_events to unmap the file and retry with the exact same
parameters, getting stuck in an infinite loop.

This has been observed to result in an exit-time hang when counting
rare/unschedulable events with perf record, and can be triggered artificially
with the script below:

  ----
  #!/bin/sh
  printf "REPRO: launching perf\n";
  ./perf record -e software/config=9/ sleep 1 &
  PERF_PID=$!;
  sleep 0.002;
  kill -2 $PERF_PID;
  printf "REPRO: waiting for perf (%d) to exit...\n" "$PERF_PID";
  wait $PERF_PID;
  printf "REPRO: perf exited\n";
  ----

To avoid this, have __perf_session__process_events bail out early when
the file has no data (i.e. it has no events).

Commiter note:

I only managed to reproduce this when setting
/proc/sys/kernel/kptr_restrict to '1' and changing the code to
purposefully not process any samples and no synthesized samples, i.e.
kptr_restrict prevents 'record' from synthesizing the kernel mmaps for
vmlinux + modules and since it is a workload started from perf, we don't
synthesize mmap/comm records for existing threads.

Adrian Hunter managed to reproduce it in his environment tho.

Signed-off-by: Mark Rutland <mark.rutland@arm.com>
Tested-by: Arnaldo Carvalho de Melo <acme@kernel.org>
Tested-by: Adrian Hunter <adrian.hunter@intel.com>
Cc: Jiri Olsa <jolsa@redhat.com>
Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1442423929-12253-1-git-send-email-mark.rutland@arm.com
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

