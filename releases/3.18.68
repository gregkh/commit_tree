commit 2713f9f39b8fd713d914c0051b8dc5acf1bc2c6d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 30 10:17:08 2017 +0200

    Linux 3.18.68

commit 2c3accfd6187fb910ba9ed307e36eaef9ef27e4d
Author: James Morse <james.morse@arm.com>
Date:   Thu Mar 16 14:30:39 2017 +0000

    ACPI / APEI: Add missing synchronize_rcu() on NOTIFY_SCI removal
    
    commit 7d64f82cceb21e6d95db312d284f5f195e120154 upstream.
    
    When removing a GHES device notified by SCI, list_del_rcu() is used,
    ghes_remove() should call synchronize_rcu() before it goes on to call
    kfree(ghes), otherwise concurrent RCU readers may still hold this list
    entry after it has been freed.
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Reviewed-by: "Huang, Ying" <ying.huang@intel.com>
    Fixes: 81e88fdc432a (ACPI, APEI, Generic Hardware Error Source POLL/IRQ/NMI notification type support)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9bfdf6b5b24236d9696c4023fc3ee0e7add4f419
Author: Charles Milette <charlesmilette@gmail.com>
Date:   Fri Aug 18 16:30:34 2017 -0400

    staging: rtl8188eu: add RNX-N150NUB support
    
    commit f299aec6ebd747298e35934cff7709c6b119ca52 upstream.
    
    Add support for USB Device Rosewill RNX-N150NUB.
    VendorID: 0x0bda, ProductID: 0xffef
    
    Signed-off-by: Charles Milette <charles.milette@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0647d1234afe90786f70b803c2aa8a4ebda821f1
Author: Dragos Bogdan <dragos.bogdan@analog.com>
Date:   Fri Aug 4 01:37:27 2017 +0300

    iio: imu: adis16480: Fix acceleration scale factor for adis16480
    
    commit fdd0d32eb95f135041236a6885d9006315aa9a1d upstream.
    
    According to the datasheet, the range of the acceleration is [-10 g, + 10 g],
    so the scale factor should be 10 instead of 5.
    
    Signed-off-by: Dragos Bogdan <dragos.bogdan@analog.com>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 80007111d1ee22259156f8b01360682e6192473e
Author: Jeffy Chen <jeffy.chen@rock-chips.com>
Date:   Tue Jun 27 17:34:42 2017 +0800

    Bluetooth: bnep: fix possible might sleep error in bnep_session
    
    commit 25717382c1dd0ddced2059053e3ca5088665f7a5 upstream.
    
    It looks like bnep_session has same pattern as the issue reported in
    old rfcomm:
    
            while (1) {
                    set_current_state(TASK_INTERRUPTIBLE);
                    if (condition)
                            break;
                    // may call might_sleep here
                    schedule();
            }
            __set_current_state(TASK_RUNNING);
    
    Which fixed at:
            dfb2fae Bluetooth: Fix nested sleeps
    
    So let's fix it at the same way, also follow the suggestion of:
    https://lwn.net/Articles/628628/
    
    Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Reviewed-by: Brian Norris <briannorris@chromium.org>
    Reviewed-by: AL Yu-Chen Cho <acho@suse.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a17886b2596672394a424d0a9a12400336060f54
Author: Jeffy Chen <jeffy.chen@rock-chips.com>
Date:   Tue Jun 27 17:34:43 2017 +0800

    Bluetooth: cmtp: fix possible might sleep error in cmtp_session
    
    commit f06d977309d09253c744e54e75c5295ecc52b7b4 upstream.
    
    It looks like cmtp_session has same pattern as the issue reported in
    old rfcomm:
    
            while (1) {
                    set_current_state(TASK_INTERRUPTIBLE);
                    if (condition)
                            break;
                    // may call might_sleep here
                    schedule();
            }
            __set_current_state(TASK_RUNNING);
    
    Which fixed at:
            dfb2fae Bluetooth: Fix nested sleeps
    
    So let's fix it at the same way, also follow the suggestion of:
    https://lwn.net/Articles/628628/
    
    Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Reviewed-by: Brian Norris <briannorris@chromium.org>
    Reviewed-by: AL Yu-Chen Cho <acho@suse.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 81baf8c59bd8278350c5bbd8d690a8f038b39929
Author: Jeffy Chen <jeffy.chen@rock-chips.com>
Date:   Tue Jun 27 17:34:44 2017 +0800

    Bluetooth: hidp: fix possible might sleep error in hidp_session_thread
    
    commit 5da8e47d849d3d37b14129f038782a095b9ad049 upstream.
    
    It looks like hidp_session_thread has same pattern as the issue reported in
    old rfcomm:
    
            while (1) {
                    set_current_state(TASK_INTERRUPTIBLE);
                    if (condition)
                            break;
                    // may call might_sleep here
                    schedule();
            }
            __set_current_state(TASK_RUNNING);
    
    Which fixed at:
            dfb2fae Bluetooth: Fix nested sleeps
    
    So let's fix it at the same way, also follow the suggestion of:
    https://lwn.net/Articles/628628/
    
    Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Tested-by: AL Yu-Chen Cho <acho@suse.com>
    Tested-by: Rohit Vaswani <rvaswani@nvidia.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d5255d9dc9741cc9b176cfa84fc22d8c8031f9ae
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Jun 22 15:41:38 2017 +0100

    perf/core: Fix group {cpu,task} validation
    
    commit 64aee2a965cf2954a038b5522f11d2cd2f0f8f3e upstream.
    
    Regardless of which events form a group, it does not make sense for the
    events to target different tasks and/or CPUs, as this leaves the group
    inconsistent and impossible to schedule. The core perf code assumes that
    these are consistent across (successfully intialised) groups.
    
    Core perf code only verifies this when moving SW events into a HW
    context. Thus, we can violate this requirement for pure SW groups and
    pure HW groups, unless the relevant PMU driver happens to perform this
    verification itself. These mismatched groups subsequently wreak havoc
    elsewhere.
    
    For example, we handle watchpoints as SW events, and reserve watchpoint
    HW on a per-CPU basis at pmu::event_init() time to ensure that any event
    that is initialised is guaranteed to have a slot at pmu::add() time.
    However, the core code only checks the group leader's cpu filter (via
    event_filter_match()), and can thus install follower events onto CPUs
    violating thier (mismatched) CPU filters, potentially installing them
    into a CPU without sufficient reserved slots.
    
    This can be triggered with the below test case, resulting in warnings
    from arch backends.
    
      #define _GNU_SOURCE
      #include <linux/hw_breakpoint.h>
      #include <linux/perf_event.h>
      #include <sched.h>
      #include <stdio.h>
      #include <sys/prctl.h>
      #include <sys/syscall.h>
      #include <unistd.h>
    
      static int perf_event_open(struct perf_event_attr *attr, pid_t pid, int cpu,
                               int group_fd, unsigned long flags)
      {
            return syscall(__NR_perf_event_open, attr, pid, cpu, group_fd, flags);
      }
    
      char watched_char;
    
      struct perf_event_attr wp_attr = {
            .type = PERF_TYPE_BREAKPOINT,
            .bp_type = HW_BREAKPOINT_RW,
            .bp_addr = (unsigned long)&watched_char,
            .bp_len = 1,
            .size = sizeof(wp_attr),
      };
    
      int main(int argc, char *argv[])
      {
            int leader, ret;
            cpu_set_t cpus;
    
            /*
             * Force use of CPU0 to ensure our CPU0-bound events get scheduled.
             */
            CPU_ZERO(&cpus);
            CPU_SET(0, &cpus);
            ret = sched_setaffinity(0, sizeof(cpus), &cpus);
            if (ret) {
                    printf("Unable to set cpu affinity\n");
                    return 1;
            }
    
            /* open leader event, bound to this task, CPU0 only */
            leader = perf_event_open(&wp_attr, 0, 0, -1, 0);
            if (leader < 0) {
                    printf("Couldn't open leader: %d\n", leader);
                    return 1;
            }
    
            /*
             * Open a follower event that is bound to the same task, but a
             * different CPU. This means that the group should never be possible to
             * schedule.
             */
            ret = perf_event_open(&wp_attr, 0, 1, leader, 0);
            if (ret < 0) {
                    printf("Couldn't open mismatched follower: %d\n", ret);
                    return 1;
            } else {
                    printf("Opened leader/follower with mismastched CPUs\n");
            }
    
            /*
             * Open as many independent events as we can, all bound to the same
             * task, CPU0 only.
             */
            do {
                    ret = perf_event_open(&wp_attr, 0, 0, -1, 0);
            } while (ret >= 0);
    
            /*
             * Force enable/disble all events to trigger the erronoeous
             * installation of the follower event.
             */
            printf("Opened all events. Toggling..\n");
            for (;;) {
                    prctl(PR_TASK_PERF_EVENTS_DISABLE, 0, 0, 0, 0);
                    prctl(PR_TASK_PERF_EVENTS_ENABLE, 0, 0, 0, 0);
            }
    
            return 0;
      }
    
    Fix this by validating this requirement regardless of whether we're
    moving events.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Zhou Chengming <zhouchengming1@huawei.com>
    Link: http://lkml.kernel.org/r/1498142498-15758-1-git-send-email-mark.rutland@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a2a7cf08c9ce65e997b5714bd078cd0de3efe8ee
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Aug 18 11:12:19 2017 -0400

    nfsd: Limit end of page list when decoding NFSv4 WRITE
    
    commit fc788f64f1f3eb31e87d4f53bcf1ab76590d5838 upstream.
    
    When processing an NFSv4 WRITE operation, argp->end should never
    point past the end of the data in the final page of the page list.
    Otherwise, nfsd4_decode_compound can walk into uninitialized memory.
    
    More critical, nfsd4_decode_write is failing to increment argp->pagelen
    when it increments argp->pagelist.  This can cause later xdr decoders
    to assume more data is available than really is, which can cause server
    crashes on malformed requests.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5ff5bac0eb20305cd5d8d8639a9b410ed9ca70f3
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed Aug 23 14:48:14 2017 +1000

    cifs: return ENAMETOOLONG for overlong names in cifs_open()/cifs_lookup()
    
    commit d3edede29f74d335f81d95a4588f5f136a9f7dcf upstream.
    
    Add checking for the path component length and verify it is <= the maximum
    that the server advertizes via FileFsAttributeInformation.
    
    With this patch cifs.ko will now return ENAMETOOLONG instead of ENOENT
    when users to access an overlong path.
    
    To test this, try to cd into a (non-existing) directory on a CIFS share
    that has a too long name:
    cd /mnt/aaaaaaaaaaaaaaa...
    
    and it now should show a good error message from the shell:
    bash: cd: /mnt/aaaaaaaaaaaaaaaa...aaaaaa: File name too long
    
    rh bz 1153996
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 04c93922c56015b27cd308fb918c2baf28a987be
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Thu Aug 3 13:09:03 2017 +0530

    cifs: Fix df output for users with quota limits
    
    commit 42bec214d8bd432be6d32a1acb0a9079ecd4d142 upstream.
    
    The df for a SMB2 share triggers a GetInfo call for
    FS_FULL_SIZE_INFORMATION. The values returned are used to populate
    struct statfs.
    
    The problem is that none of the information returned by the call
    contains the total blocks available on the filesystem. Instead we use
    the blocks available to the user ie. quota limitation when filling out
    statfs.f_blocks. The information returned does contain Actual free units
    on the filesystem and is used to populate statfs.f_bfree. For users with
    quota enabled, it can lead to situations where the total free space
    reported is more than the total blocks on the system ending up with df
    reports like the following
    
     # df -h /mnt/a
    Filesystem         Size  Used Avail Use% Mounted on
    //192.168.22.10/a  2.5G -2.3G  2.5G    - /mnt/a
    
    To fix this problem, we instead populate both statfs.f_bfree with the
    same value as statfs.f_bavail ie. CallerAvailableAllocationUnits. This
    is similar to what is done already in the code for cifs and df now
    reports the quota information for the user used to mount the share.
    
     # df --si /mnt/a
    Filesystem         Size  Used Avail Use% Mounted on
    //192.168.22.10/a  2.7G  101M  2.6G   4% /mnt/a
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Signed-off-by: Pierguido Lambri <plambri@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5dd78853f43e08bdf9d20ffa7223808e9c2b1f7e
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Wed Aug 23 12:46:27 2017 -0400

    tracing: Fix freeing of filter in create_filter() when set_str is false
    
    commit 8b0db1a5bdfcee0dbfa89607672598ae203c9045 upstream.
    
    Performing the following task with kmemleak enabled:
    
     # cd /sys/kernel/tracing/events/irq/irq_handler_entry/
     # echo 'enable_event:kmem:kmalloc:3 if irq >' > trigger
     # echo 'enable_event:kmem:kmalloc:3 if irq > 31' > trigger
     # echo scan > /sys/kernel/debug/kmemleak
     # cat /sys/kernel/debug/kmemleak
    unreferenced object 0xffff8800b9290308 (size 32):
      comm "bash", pid 1114, jiffies 4294848451 (age 141.139s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<ffffffff81cef5aa>] kmemleak_alloc+0x4a/0xa0
        [<ffffffff81357938>] kmem_cache_alloc_trace+0x158/0x290
        [<ffffffff81261c09>] create_filter_start.constprop.28+0x99/0x940
        [<ffffffff812639c9>] create_filter+0xa9/0x160
        [<ffffffff81263bdc>] create_event_filter+0xc/0x10
        [<ffffffff812655e5>] set_trigger_filter+0xe5/0x210
        [<ffffffff812660c4>] event_enable_trigger_func+0x324/0x490
        [<ffffffff812652e2>] event_trigger_write+0x1a2/0x260
        [<ffffffff8138cf87>] __vfs_write+0xd7/0x380
        [<ffffffff8138f421>] vfs_write+0x101/0x260
        [<ffffffff8139187b>] SyS_write+0xab/0x130
        [<ffffffff81cfd501>] entry_SYSCALL_64_fastpath+0x1f/0xbe
        [<ffffffffffffffff>] 0xffffffffffffffff
    
    The function create_filter() is passed a 'filterp' pointer that gets
    allocated, and if "set_str" is true, it is up to the caller to free it, even
    on error. The problem is that the pointer is not freed by create_filter()
    when set_str is false. This is a bug, and it is not up to the caller to free
    the filter on error if it doesn't care about the string.
    
    Link: http://lkml.kernel.org/r/1502705898-27571-2-git-send-email-chuhu@redhat.com
    
    Fixes: 38b78eb85 ("tracing: Factorize filter creation")
    Reported-by: Chunyu Hu <chuhu@redhat.com>
    Tested-by: Chunyu Hu <chuhu@redhat.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d3f4c196d99d04d7cd62a8126f5700c76e688d44
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Aug 19 13:05:58 2017 +0100

    drm: Release driver tracking before making the object available again
    
    commit fe4600a548f2763dec91b3b27a1245c370ceee2a upstream.
    
    This is the same bug as we fixed in commit f6cd7daecff5 ("drm: Release
    driver references to handle before making it available again"), but now
    the exposure is via the PRIME lookup tables. If we remove the
    object/handle from the PRIME lut, then a new request for the same
    object/fd will generate a new handle, thus for a short window that
    object is known to userspace by two different handles. Fix this by
    releasing the driver tracking before PRIME.
    
    Fixes: 0ff926c7d4f0 ("drm/prime: add exported buffers to current fprivs
    imported buffer list (v2)")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170819120558.6465-1-chris@chris-wilson.co.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e3d62b2d359c52c9af8e18cec74080c22993b072
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 23 09:30:17 2017 +0200

    ALSA: hda - Add stereo mic quirk for Lenovo G50-70 (17aa:3978)
    
    commit bbba6f9d3da357bbabc6fda81e99ff5584500e76 upstream.
    
    Lenovo G50-70 (17aa:3978) with Conexant codec chip requires the
    similar workaround for the inverted stereo dmic like other Lenovo
    models.
    
    Bugzilla: https://bugzilla.suse.com/show_bug.cgi?id=1020657
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 639ea02e79ec2aab07f6bf9e78993e2066228ebc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 22 08:15:13 2017 +0200

    ALSA: core: Fix unexpected error at replacing user TLV
    
    commit 88c54cdf61f508ebcf8da2d819f5dfc03e954d1d upstream.
    
    When user tries to replace the user-defined control TLV, the kernel
    checks the change of its content via memcmp().  The problem is that
    the kernel passes the return value from memcmp() as is.  memcmp()
    gives a non-zero negative value depending on the comparison result,
    and this shall be recognized as an error code.
    
    The patch covers that corner-case, return 1 properly for the changed
    TLV.
    
    Fixes: 8aa9b586e420 ("[ALSA] Control API - more robust TLV implementation")
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ea205266b1f198f34be9330c8c2e3f3088958bed
Author: Aaron Ma <aaron.ma@canonical.com>
Date:   Fri Aug 18 12:17:21 2017 -0700

    Input: trackpoint - add new trackpoint firmware ID
    
    commit ec667683c532c93fb41e100e5d61a518971060e2 upstream.
    
    Synaptics add new TP firmware ID: 0x2 and 0x3, for now both lower 2 bits
    are indicated as TP. Change the constant to bitwise values.
    
    This makes trackpoint to be recognized on Lenovo Carbon X1 Gen5 instead
    of it being identified as "PS/2 Generic Mouse".
    
    Signed-off-by: Aaron Ma <aaron.ma@canonical.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4eebc905b64836baac8c8ac898f8e8e6addd905a
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Sat Aug 19 15:37:07 2017 +0300

    net_sched: fix order of queue length updates in qdisc_replace()
    
    
    [ Upstream commit 68a66d149a8c78ec6720f268597302883e48e9fa ]
    
    This important to call qdisc_tree_reduce_backlog() after changing queue
    length. Parent qdisc should deactivate class in ->qlen_notify() called from
    qdisc_tree_reduce_backlog() but this happens only if qdisc->q.qlen in zero.
    
    Missed class deactivations leads to crashes/warnings at picking packets
    from empty qdisc and corrupting state at reactivating this class in future.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Fixes: 86a7996cc8a0 ("net_sched: introduce qdisc_replace() helper")
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 28ae858736a42b37ff4352e3cb46e4a9e9299d2f
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 18 11:01:36 2017 +0800

    net: sched: fix NULL pointer dereference when action calls some targets
    
    
    [ Upstream commit 4f8a881acc9d1adaf1e552349a0b1df28933a04c ]
    
    As we know in some target's checkentry it may dereference par.entryinfo
    to check entry stuff inside. But when sched action calls xt_check_target,
    par.entryinfo is set with NULL. It would cause kernel panic when calling
    some targets.
    
    It can be reproduce with:
      # tc qd add dev eth1 ingress handle ffff:
      # tc filter add dev eth1 parent ffff: u32 match u32 0 0 action xt \
        -j ECN --ecn-tcp-remove
    
    It could also crash kernel when using target CLUSTERIP or TPROXY.
    
    By now there's no proper value for par.entryinfo in ipt_init_target,
    but it can not be set with NULL. This patch is to void all these
    panics by setting it with an ipt_entry obj with all members = 0.
    
    Note that this issue has been there since the very beginning.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 69e12f86c34a54bffba6480c22326e97c661ff2e
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Aug 17 23:14:58 2017 +0100

    irda: do not leak initialized list.dev to userspace
    
    
    [ Upstream commit b024d949a3c24255a7ef1a470420eb478949aa4c ]
    
    list.dev has not been initialized and so the copy_to_user is copying
    data from the stack back to user space which is a potential
    information leak. Fix this ensuring all of list is initialized to
    zero.
    
    Detected by CoverityScan, CID#1357894 ("Uninitialized scalar variable")
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8621be05fdb666b39483ad58df383a406c345c1a
Author: Neal Cardwell <ncardwell@google.com>
Date:   Wed Aug 16 17:53:36 2017 -0400

    tcp: when rearming RTO, if RTO time is in past then fire RTO ASAP
    
    
    [ Upstream commit cdbeb633ca71a02b7b63bfeb94994bf4e1a0b894 ]
    
    In some situations tcp_send_loss_probe() can realize that it's unable
    to send a loss probe (TLP), and falls back to calling tcp_rearm_rto()
    to schedule an RTO timer. In such cases, sometimes tcp_rearm_rto()
    realizes that the RTO was eligible to fire immediately or at some
    point in the past (delta_us <= 0). Previously in such cases
    tcp_rearm_rto() was scheduling such "overdue" RTOs to happen at now +
    icsk_rto, which caused needless delays of hundreds of milliseconds
    (and non-linear behavior that made reproducible testing
    difficult). This commit changes the logic to schedule "overdue" RTOs
    ASAP, rather than at now + icsk_rto.
    
    Fixes: 6ba8a3b19e76 ("tcp: Tail loss probe (TLP)")
    Suggested-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: Neal Cardwell <ncardwell@google.com>
    Signed-off-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 82bd5554e1b7ff5464ec3a85bd8ea7aef6485595
Author: Alexander Potapenko <glider@google.com>
Date:   Wed Aug 16 20:16:40 2017 +0200

    sctp: fully initialize the IPv6 address in sctp_v6_to_addr()
    
    
    [ Upstream commit 15339e441ec46fbc3bf3486bb1ae4845b0f1bb8d ]
    
    KMSAN reported use of uninitialized sctp_addr->v4.sin_addr.s_addr and
    sctp_addr->v6.sin6_scope_id in sctp_v6_cmp_addr() (see below).
    Make sure all fields of an IPv6 address are initialized, which
    guarantees that the IPv4 fields are also initialized.
    
    ==================================================================
     BUG: KMSAN: use of uninitialized memory in sctp_v6_cmp_addr+0x8d4/0x9f0
     net/sctp/ipv6.c:517
     CPU: 2 PID: 31056 Comm: syz-executor1 Not tainted 4.11.0-rc5+ #2944
     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs
     01/01/2011
     Call Trace:
      dump_stack+0x172/0x1c0 lib/dump_stack.c:42
      is_logbuf_locked mm/kmsan/kmsan.c:59 [inline]
      kmsan_report+0x12a/0x180 mm/kmsan/kmsan.c:938
      native_save_fl arch/x86/include/asm/irqflags.h:18 [inline]
      arch_local_save_flags arch/x86/include/asm/irqflags.h:72 [inline]
      arch_local_irq_save arch/x86/include/asm/irqflags.h:113 [inline]
      __msan_warning_32+0x61/0xb0 mm/kmsan/kmsan_instr.c:467
      sctp_v6_cmp_addr+0x8d4/0x9f0 net/sctp/ipv6.c:517
      sctp_v6_get_dst+0x8c7/0x1630 net/sctp/ipv6.c:290
      sctp_transport_route+0x101/0x570 net/sctp/transport.c:292
      sctp_assoc_add_peer+0x66d/0x16f0 net/sctp/associola.c:651
      sctp_sendmsg+0x35a5/0x4f90 net/sctp/socket.c:1871
      inet_sendmsg+0x498/0x670 net/ipv4/af_inet.c:762
      sock_sendmsg_nosec net/socket.c:633 [inline]
      sock_sendmsg net/socket.c:643 [inline]
      SYSC_sendto+0x608/0x710 net/socket.c:1696
      SyS_sendto+0x8a/0xb0 net/socket.c:1664
      entry_SYSCALL_64_fastpath+0x13/0x94
     RIP: 0033:0x44b479
     RSP: 002b:00007f6213f21c08 EFLAGS: 00000286 ORIG_RAX: 000000000000002c
     RAX: ffffffffffffffda RBX: 0000000020000000 RCX: 000000000044b479
     RDX: 0000000000000041 RSI: 0000000020edd000 RDI: 0000000000000006
     RBP: 00000000007080a8 R08: 0000000020b85fe4 R09: 000000000000001c
     R10: 0000000000040005 R11: 0000000000000286 R12: 00000000ffffffff
     R13: 0000000000003760 R14: 00000000006e5820 R15: 0000000000ff8000
     origin description: ----dst_saddr@sctp_v6_get_dst
     local variable created at:
      sk_fullsock include/net/sock.h:2321 [inline]
      inet6_sk include/linux/ipv6.h:309 [inline]
      sctp_v6_get_dst+0x91/0x1630 net/sctp/ipv6.c:241
      sctp_transport_route+0x101/0x570 net/sctp/transport.c:292
    ==================================================================
     BUG: KMSAN: use of uninitialized memory in sctp_v6_cmp_addr+0x8d4/0x9f0
     net/sctp/ipv6.c:517
     CPU: 2 PID: 31056 Comm: syz-executor1 Not tainted 4.11.0-rc5+ #2944
     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs
     01/01/2011
     Call Trace:
      dump_stack+0x172/0x1c0 lib/dump_stack.c:42
      is_logbuf_locked mm/kmsan/kmsan.c:59 [inline]
      kmsan_report+0x12a/0x180 mm/kmsan/kmsan.c:938
      native_save_fl arch/x86/include/asm/irqflags.h:18 [inline]
      arch_local_save_flags arch/x86/include/asm/irqflags.h:72 [inline]
      arch_local_irq_save arch/x86/include/asm/irqflags.h:113 [inline]
      __msan_warning_32+0x61/0xb0 mm/kmsan/kmsan_instr.c:467
      sctp_v6_cmp_addr+0x8d4/0x9f0 net/sctp/ipv6.c:517
      sctp_v6_get_dst+0x8c7/0x1630 net/sctp/ipv6.c:290
      sctp_transport_route+0x101/0x570 net/sctp/transport.c:292
      sctp_assoc_add_peer+0x66d/0x16f0 net/sctp/associola.c:651
      sctp_sendmsg+0x35a5/0x4f90 net/sctp/socket.c:1871
      inet_sendmsg+0x498/0x670 net/ipv4/af_inet.c:762
      sock_sendmsg_nosec net/socket.c:633 [inline]
      sock_sendmsg net/socket.c:643 [inline]
      SYSC_sendto+0x608/0x710 net/socket.c:1696
      SyS_sendto+0x8a/0xb0 net/socket.c:1664
      entry_SYSCALL_64_fastpath+0x13/0x94
     RIP: 0033:0x44b479
     RSP: 002b:00007f6213f21c08 EFLAGS: 00000286 ORIG_RAX: 000000000000002c
     RAX: ffffffffffffffda RBX: 0000000020000000 RCX: 000000000044b479
     RDX: 0000000000000041 RSI: 0000000020edd000 RDI: 0000000000000006
     RBP: 00000000007080a8 R08: 0000000020b85fe4 R09: 000000000000001c
     R10: 0000000000040005 R11: 0000000000000286 R12: 00000000ffffffff
     R13: 0000000000003760 R14: 00000000006e5820 R15: 0000000000ff8000
     origin description: ----dst_saddr@sctp_v6_get_dst
     local variable created at:
      sk_fullsock include/net/sock.h:2321 [inline]
      inet6_sk include/linux/ipv6.h:309 [inline]
      sctp_v6_get_dst+0x91/0x1630 net/sctp/ipv6.c:241
      sctp_transport_route+0x101/0x570 net/sctp/transport.c:292
    ==================================================================
    
    Signed-off-by: Alexander Potapenko <glider@google.com>
    Reviewed-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e96bad763bdd2d092afdd6bc0c35ad84eb39ea26
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 16 07:03:15 2017 -0700

    dccp: defer ccid_hc_tx_delete() at dismantle time
    
    
    [ Upstream commit 120e9dabaf551c6dc03d3a10a1f026376cb1811c ]
    
    syszkaller team reported another problem in DCCP [1]
    
    Problem here is that the structure holding RTO timer
    (ccid2_hc_tx_rto_expire() handler) is freed too soon.
    
    We can not use del_timer_sync() to cancel the timer
    since this timer wants to grab socket lock (that would risk a dead lock)
    
    Solution is to defer the freeing of memory when all references to
    the socket were released. Socket timers do own a reference, so this
    should fix the issue.
    
    [1]
    
    ==================================================================
    BUG: KASAN: use-after-free in ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
    Read of size 4 at addr ffff8801d2660540 by task kworker/u4:7/3365
    
    CPU: 1 PID: 3365 Comm: kworker/u4:7 Not tainted 4.13.0-rc4+ #3
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: events_unbound call_usermodehelper_exec_work
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:16 [inline]
     dump_stack+0x194/0x257 lib/dump_stack.c:52
     print_address_description+0x73/0x250 mm/kasan/report.c:252
     kasan_report_error mm/kasan/report.c:351 [inline]
     kasan_report+0x24e/0x340 mm/kasan/report.c:409
     __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429
     ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
     call_timer_fn+0x233/0x830 kernel/time/timer.c:1268
     expire_timers kernel/time/timer.c:1307 [inline]
     __run_timers+0x7fd/0xb90 kernel/time/timer.c:1601
     run_timer_softirq+0x21/0x80 kernel/time/timer.c:1614
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
     invoke_softirq kernel/softirq.c:364 [inline]
     irq_exit+0x1cc/0x200 kernel/softirq.c:405
     exiting_irq arch/x86/include/asm/apic.h:638 [inline]
     smp_apic_timer_interrupt+0x76/0xa0 arch/x86/kernel/apic/apic.c:1044
     apic_timer_interrupt+0x93/0xa0 arch/x86/entry/entry_64.S:702
    RIP: 0010:arch_local_irq_enable arch/x86/include/asm/paravirt.h:824 [inline]
    RIP: 0010:__raw_write_unlock_irq include/linux/rwlock_api_smp.h:267 [inline]
    RIP: 0010:_raw_write_unlock_irq+0x56/0x70 kernel/locking/spinlock.c:343
    RSP: 0018:ffff8801cd50eaa8 EFLAGS: 00000286 ORIG_RAX: ffffffffffffff10
    RAX: dffffc0000000000 RBX: ffffffff85a090c0 RCX: 0000000000000006
    RDX: 1ffffffff0b595f3 RSI: 1ffff1003962f989 RDI: ffffffff85acaf98
    RBP: ffff8801cd50eab0 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8801cc96ea60
    R13: dffffc0000000000 R14: ffff8801cc96e4c0 R15: ffff8801cc96e4c0
     </IRQ>
     release_task+0xe9e/0x1a40 kernel/exit.c:220
     wait_task_zombie kernel/exit.c:1162 [inline]
     wait_consider_task+0x29b8/0x33c0 kernel/exit.c:1389
     do_wait_thread kernel/exit.c:1452 [inline]
     do_wait+0x441/0xa90 kernel/exit.c:1523
     kernel_wait4+0x1f5/0x370 kernel/exit.c:1665
     SYSC_wait4+0x134/0x140 kernel/exit.c:1677
     SyS_wait4+0x2c/0x40 kernel/exit.c:1673
     call_usermodehelper_exec_sync kernel/kmod.c:286 [inline]
     call_usermodehelper_exec_work+0x1a0/0x2c0 kernel/kmod.c:323
     process_one_work+0xbf3/0x1bc0 kernel/workqueue.c:2097
     worker_thread+0x223/0x1860 kernel/workqueue.c:2231
     kthread+0x35e/0x430 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:425
    
    Allocated by task 21267:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551
     kasan_slab_alloc+0x12/0x20 mm/kasan/kasan.c:489
     kmem_cache_alloc+0x127/0x750 mm/slab.c:3561
     ccid_new+0x20e/0x390 net/dccp/ccid.c:151
     dccp_hdlr_ccid+0x27/0x140 net/dccp/feat.c:44
     __dccp_feat_activate+0x142/0x2a0 net/dccp/feat.c:344
     dccp_feat_activate_values+0x34e/0xa90 net/dccp/feat.c:1538
     dccp_rcv_request_sent_state_process net/dccp/input.c:472 [inline]
     dccp_rcv_state_process+0xed1/0x1620 net/dccp/input.c:677
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __release_sock+0x124/0x360 net/core/sock.c:2269
     release_sock+0xa4/0x2a0 net/core/sock.c:2784
     inet_wait_for_connect net/ipv4/af_inet.c:557 [inline]
     __inet_stream_connect+0x671/0xf00 net/ipv4/af_inet.c:643
     inet_stream_connect+0x58/0xa0 net/ipv4/af_inet.c:682
     SYSC_connect+0x204/0x470 net/socket.c:1642
     SyS_connect+0x24/0x30 net/socket.c:1623
     entry_SYSCALL_64_fastpath+0x1f/0xbe
    
    Freed by task 3049:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524
     __cache_free mm/slab.c:3503 [inline]
     kmem_cache_free+0x77/0x280 mm/slab.c:3763
     ccid_hc_tx_delete+0xc5/0x100 net/dccp/ccid.c:190
     dccp_destroy_sock+0x1d1/0x2b0 net/dccp/proto.c:225
     inet_csk_destroy_sock+0x166/0x3f0 net/ipv4/inet_connection_sock.c:833
     dccp_done+0xb7/0xd0 net/dccp/proto.c:145
     dccp_time_wait+0x13d/0x300 net/dccp/minisocks.c:72
     dccp_rcv_reset+0x1d1/0x5b0 net/dccp/input.c:160
     dccp_rcv_state_process+0x8fc/0x1620 net/dccp/input.c:663
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __sk_receive_skb+0x33e/0xc00 net/core/sock.c:521
     dccp_v4_rcv+0xef1/0x1c00 net/dccp/ipv4.c:871
     ip_local_deliver_finish+0x2e2/0xba0 net/ipv4/ip_input.c:216
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_local_deliver+0x1ce/0x6d0 net/ipv4/ip_input.c:257
     dst_input include/net/dst.h:477 [inline]
     ip_rcv_finish+0x8db/0x19c0 net/ipv4/ip_input.c:397
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_rcv+0xc3f/0x17d0 net/ipv4/ip_input.c:488
     __netif_receive_skb_core+0x19af/0x33d0 net/core/dev.c:4417
     __netif_receive_skb+0x2c/0x1b0 net/core/dev.c:4455
     process_backlog+0x203/0x740 net/core/dev.c:5130
     napi_poll net/core/dev.c:5527 [inline]
     net_rx_action+0x792/0x1910 net/core/dev.c:5593
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
    
    The buggy address belongs to the object at ffff8801d2660100
     which belongs to the cache ccid2_hc_tx_sock of size 1240
    The buggy address is located 1088 bytes inside of
     1240-byte region [ffff8801d2660100, ffff8801d26605d8)
    The buggy address belongs to the page:
    page:ffffea0007499800 count:1 mapcount:0 mapping:ffff8801d2660100 index:0x0 compound_mapcount: 0
    flags: 0x200000000008100(slab|head)
    raw: 0200000000008100 ffff8801d2660100 0000000000000000 0000000100000005
    raw: ffffea00075271a0 ffffea0007538820 ffff8801d3aef9c0 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffff8801d2660400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ffff8801d2660480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    >ffff8801d2660500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                               ^
     ffff8801d2660580: fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc fc
     ffff8801d2660600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    ==================================================================
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a9b7f06cab1ba7b233ae10338cdde348935e37f5
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Aug 14 14:10:25 2017 -0700

    dccp: purge write queue in dccp_destroy_sock()
    
    
    [ Upstream commit 7749d4ff88d31b0be17c8683143135adaaadc6a7 ]
    
    syzkaller reported that DCCP could have a non empty
    write queue at dismantle time.
    
    WARNING: CPU: 1 PID: 2953 at net/core/stream.c:199 sk_stream_kill_queues+0x3ce/0x520 net/core/stream.c:199
    Kernel panic - not syncing: panic_on_warn set ...
    
    CPU: 1 PID: 2953 Comm: syz-executor0 Not tainted 4.13.0-rc4+ #2
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:16 [inline]
     dump_stack+0x194/0x257 lib/dump_stack.c:52
     panic+0x1e4/0x417 kernel/panic.c:180
     __warn+0x1c4/0x1d9 kernel/panic.c:541
     report_bug+0x211/0x2d0 lib/bug.c:183
     fixup_bug+0x40/0x90 arch/x86/kernel/traps.c:190
     do_trap_no_signal arch/x86/kernel/traps.c:224 [inline]
     do_trap+0x260/0x390 arch/x86/kernel/traps.c:273
     do_error_trap+0x120/0x390 arch/x86/kernel/traps.c:310
     do_invalid_op+0x1b/0x20 arch/x86/kernel/traps.c:323
     invalid_op+0x1e/0x30 arch/x86/entry/entry_64.S:846
    RIP: 0010:sk_stream_kill_queues+0x3ce/0x520 net/core/stream.c:199
    RSP: 0018:ffff8801d182f108 EFLAGS: 00010297
    RAX: ffff8801d1144140 RBX: ffff8801d13cb280 RCX: 0000000000000000
    RDX: 0000000000000000 RSI: ffffffff85137b00 RDI: ffff8801d13cb280
    RBP: ffff8801d182f148 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8801d13cb4d0
    R13: ffff8801d13cb3b8 R14: ffff8801d13cb300 R15: ffff8801d13cb3b8
     inet_csk_destroy_sock+0x175/0x3f0 net/ipv4/inet_connection_sock.c:835
     dccp_close+0x84d/0xc10 net/dccp/proto.c:1067
     inet_release+0xed/0x1c0 net/ipv4/af_inet.c:425
     sock_release+0x8d/0x1e0 net/socket.c:597
     sock_close+0x16/0x20 net/socket.c:1126
     __fput+0x327/0x7e0 fs/file_table.c:210
     ____fput+0x15/0x20 fs/file_table.c:246
     task_work_run+0x18a/0x260 kernel/task_work.c:116
     exit_task_work include/linux/task_work.h:21 [inline]
     do_exit+0xa32/0x1b10 kernel/exit.c:865
     do_group_exit+0x149/0x400 kernel/exit.c:969
     get_signal+0x7e8/0x17e0 kernel/signal.c:2330
     do_signal+0x94/0x1ee0 arch/x86/kernel/signal.c:808
     exit_to_usermode_loop+0x21c/0x2d0 arch/x86/entry/common.c:157
     prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline]
     syscall_return_slowpath+0x3a7/0x450 arch/x86/entry/common.c:263
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
