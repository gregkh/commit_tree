commit 66a613c5173456fe0edfa1a89147381d2802d4e4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 3 10:24:03 2021 +0200

    Linux 5.14.1
    
    Link: https://lore.kernel.org/r/20210901122249.520249736@linuxfoundation.org
    Tested-by: Fox Chen <foxhlchen@gmail.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Shuah Khan <skhan@linuxfoundation.org>
    Tested-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2424b0eb89f2edc1a5df217a4113d37af24058f7
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Mon Aug 23 22:04:09 2021 -0400

    audit: move put_tree() to avoid trim_trees refcount underflow and UAF
    
    commit 67d69e9d1a6c889d98951c1d74b19332ce0565af upstream.
    
    AUDIT_TRIM is expected to be idempotent, but multiple executions resulted
    in a refcount underflow and use-after-free.
    
    git bisect fingered commit fb041bb7c0a9 ("locking/refcount: Consolidate
    implementations of refcount_t") but this patch with its more thorough
    checking that wasn't in the x86 assembly code merely exposed a previously
    existing tree refcount imbalance in the case of tree trimming code that
    was refactored with prune_one() to remove a tree introduced in
    commit 8432c7006297 ("audit: Simplify locking around untag_chunk()")
    
    Move the put_tree() to cover only the prune_one() case.
    
    Passes audit-testsuite and 3 passes of "auditctl -t" with at least one
    directory watch.
    
    Cc: Jan Kara <jack@suse.cz>
    Cc: Will Deacon <will@kernel.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Seiji Nishikawa <snishika@redhat.com>
    Cc: stable@vger.kernel.org
    Fixes: 8432c7006297 ("audit: Simplify locking around untag_chunk()")
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    [PM: reformatted/cleaned-up the commit description]
    Signed-off-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7bf99c75124102fede4884355ec0d9e48c3956a7
Author: Peter Collingbourne <pcc@google.com>
Date:   Thu Aug 26 12:46:01 2021 -0700

    net: don't unconditionally copy_from_user a struct ifreq for socket ioctls
    
    commit d0efb16294d145d157432feda83877ae9d7cdf37 upstream.
    
    A common implementation of isatty(3) involves calling a ioctl passing
    a dummy struct argument and checking whether the syscall failed --
    bionic and glibc use TCGETS (passing a struct termios), and musl uses
    TIOCGWINSZ (passing a struct winsize). If the FD is a socket, we will
    copy sizeof(struct ifreq) bytes of data from the argument and return
    -EFAULT if that fails. The result is that the isatty implementations
    may return a non-POSIX-compliant value in errno in the case where part
    of the dummy struct argument is inaccessible, as both struct termios
    and struct winsize are smaller than struct ifreq (at least on arm64).
    
    Although there is usually enough stack space following the argument
    on the stack that this did not present a practical problem up to now,
    with MTE stack instrumentation it's more likely for the copy to fail,
    as the memory following the struct may have a different tag.
    
    Fix the problem by adding an early check for whether the ioctl is a
    valid socket ioctl, and return -ENOTTY if it isn't.
    
    Fixes: 44c02a2c3dc5 ("dev_ioctl(): move copyin/copyout to callers")
    Link: https://linux-review.googlesource.com/id/I869da6cf6daabc3e4b7b82ac979683ba05e27d4d
    Signed-off-by: Peter Collingbourne <pcc@google.com>
    Cc: <stable@vger.kernel.org> # 4.19
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8a5c56c2bdbcc856ab38b494a3ab58cc16d07e9b
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jul 1 23:53:49 2021 -0700

    ubifs: report correct st_size for encrypted symlinks
    
    commit 064c734986011390b4d111f1a99372b7f26c3850 upstream.
    
    The stat() family of syscalls report the wrong size for encrypted
    symlinks, which has caused breakage in several userspace programs.
    
    Fix this by calling fscrypt_symlink_getattr() after ubifs_getattr() for
    encrypted symlinks.  This function computes the correct size by reading
    and decrypting the symlink target (if it's not already cached).
    
    For more details, see the commit which added fscrypt_symlink_getattr().
    
    Fixes: ca7f85be8d6c ("ubifs: Add support for encrypted symlinks")
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210702065350.209646-5-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 753ffce1031a4e1818611f1983a1180084ded011
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jul 1 23:53:48 2021 -0700

    f2fs: report correct st_size for encrypted symlinks
    
    commit 461b43a8f92e68e96c4424b31e15f2b35f1bbfa9 upstream.
    
    The stat() family of syscalls report the wrong size for encrypted
    symlinks, which has caused breakage in several userspace programs.
    
    Fix this by calling fscrypt_symlink_getattr() after f2fs_getattr() for
    encrypted symlinks.  This function computes the correct size by reading
    and decrypting the symlink target (if it's not already cached).
    
    For more details, see the commit which added fscrypt_symlink_getattr().
    
    Fixes: cbaf042a3cc6 ("f2fs crypto: add symlink encryption")
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210702065350.209646-4-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 256fd853a717978555e168f659d8367497f9d8d6
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jul 1 23:53:47 2021 -0700

    ext4: report correct st_size for encrypted symlinks
    
    commit 8c4bca10ceafc43b1ca0a9fab5fa27e13cbce99e upstream.
    
    The stat() family of syscalls report the wrong size for encrypted
    symlinks, which has caused breakage in several userspace programs.
    
    Fix this by calling fscrypt_symlink_getattr() after ext4_getattr() for
    encrypted symlinks.  This function computes the correct size by reading
    and decrypting the symlink target (if it's not already cached).
    
    For more details, see the commit which added fscrypt_symlink_getattr().
    
    Fixes: f348c252320b ("ext4 crypto: add symlink encryption")
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210702065350.209646-3-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 38342724f13725273738a3493f08fca9a94f0253
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jul 1 23:53:46 2021 -0700

    fscrypt: add fscrypt_symlink_getattr() for computing st_size
    
    commit d18760560593e5af921f51a8c9b64b6109d634c2 upstream.
    
    Add a helper function fscrypt_symlink_getattr() which will be called
    from the various filesystems' ->getattr() methods to read and decrypt
    the target of encrypted symlinks in order to report the correct st_size.
    
    Detailed explanation:
    
    As required by POSIX and as documented in various man pages, st_size for
    a symlink is supposed to be the length of the symlink target.
    Unfortunately, st_size has always been wrong for encrypted symlinks
    because st_size is populated from i_size from disk, which intentionally
    contains the length of the encrypted symlink target.  That's slightly
    greater than the length of the decrypted symlink target (which is the
    symlink target that userspace usually sees), and usually won't match the
    length of the no-key encoded symlink target either.
    
    This hadn't been fixed yet because reporting the correct st_size would
    require reading the symlink target from disk and decrypting or encoding
    it, which historically has been considered too heavyweight to do in
    ->getattr().  Also historically, the wrong st_size had only broken a
    test (LTP lstat03) and there were no known complaints from real users.
    (This is probably because the st_size of symlinks isn't used too often,
    and when it is, typically it's for a hint for what buffer size to pass
    to readlink() -- which a slightly-too-large size still works for.)
    
    However, a couple things have changed now.  First, there have recently
    been complaints about the current behavior from real users:
    
    - Breakage in rpmbuild:
      https://github.com/rpm-software-management/rpm/issues/1682
      https://github.com/google/fscrypt/issues/305
    
    - Breakage in toybox cpio:
      https://www.mail-archive.com/toybox@lists.landley.net/msg07193.html
    
    - Breakage in libgit2: https://issuetracker.google.com/issues/189629152
      (on Android public issue tracker, requires login)
    
    Second, we now cache decrypted symlink targets in ->i_link.  Therefore,
    taking the performance hit of reading and decrypting the symlink target
    in ->getattr() wouldn't be as big a deal as it used to be, since usually
    it will just save having to do the same thing later.
    
    Also note that eCryptfs ended up having to read and decrypt symlink
    targets in ->getattr() as well, to fix this same issue; see
    commit 3a60a1686f0d ("eCryptfs: Decrypt symlink target for stat size").
    
    So, let's just bite the bullet, and read and decrypt the symlink target
    in ->getattr() in order to report the correct st_size.  Add a function
    fscrypt_symlink_getattr() which the filesystems will call to do this.
    
    (Alternatively, we could store the decrypted size of symlinks on-disk.
    But there isn't a great place to do so, and encryption is meant to hide
    the original size to some extent; that property would be lost.)
    
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210702065350.209646-2-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ebf67b94ca7a6a17f73812433b8ccd6e76754d26
Author: Denis Efremov <efremov@linux.com>
Date:   Sat Aug 7 10:37:02 2021 +0300

    Revert "floppy: reintroduce O_NDELAY fix"
    
    commit c7e9d0020361f4308a70cdfd6d5335e273eb8717 upstream.
    
    The patch breaks userspace implementations (e.g. fdutils) and introduces
    regressions in behaviour. Previously, it was possible to O_NDELAY open a
    floppy device with no media inserted or with write protected media without
    an error. Some userspace tools use this particular behavior for probing.
    
    It's not the first time when we revert this patch. Previous revert is in
    commit f2791e7eadf4 (Revert "floppy: refactor open() flags handling").
    
    This reverts commit 8a0c014cd20516ade9654fc13b51345ec58e7be8.
    
    Link: https://lore.kernel.org/linux-block/de10cb47-34d1-5a88-7751-225ca380f735@compro.net/
    Reported-by: Mark Hounschell <markh@compro.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Wim Osterholt <wim@djo.tudelft.nl>
    Cc: Kurt Garloff <kurt@garloff.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 734dabfb6918d399024063c9db9093a83f804ce5
Author: Qu Wenruo <wqu@suse.com>
Date:   Fri Aug 6 18:24:15 2021 +0800

    btrfs: fix NULL pointer dereference when deleting device by invalid id
    
    commit e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091 upstream.
    
    [BUG]
    It's easy to trigger NULL pointer dereference, just by removing a
    non-existing device id:
    
     # mkfs.btrfs -f -m single -d single /dev/test/scratch1 \
                                         /dev/test/scratch2
     # mount /dev/test/scratch1 /mnt/btrfs
     # btrfs device remove 3 /mnt/btrfs
    
    Then we have the following kernel NULL pointer dereference:
    
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor read access in kernel mode
     #PF: error_code(0x0000) - not-present page
     PGD 0 P4D 0
     Oops: 0000 [#1] PREEMPT SMP NOPTI
     CPU: 9 PID: 649 Comm: btrfs Not tainted 5.14.0-rc3-custom+ #35
     Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015
     RIP: 0010:btrfs_rm_device+0x4de/0x6b0 [btrfs]
      btrfs_ioctl+0x18bb/0x3190 [btrfs]
      ? lock_is_held_type+0xa5/0x120
      ? find_held_lock.constprop.0+0x2b/0x80
      ? do_user_addr_fault+0x201/0x6a0
      ? lock_release+0xd2/0x2d0
      ? __x64_sys_ioctl+0x83/0xb0
      __x64_sys_ioctl+0x83/0xb0
      do_syscall_64+0x3b/0x90
      entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    [CAUSE]
    Commit a27a94c2b0c7 ("btrfs: Make btrfs_find_device_by_devspec return
    btrfs_device directly") moves the "missing" device path check into
    btrfs_rm_device().
    
    But btrfs_rm_device() itself can have case where it only receives
    @devid, with NULL as @device_path.
    
    In that case, calling strcmp() on NULL will trigger the NULL pointer
    dereference.
    
    Before that commit, we handle the "missing" case inside
    btrfs_find_device_by_devspec(), which will not check @device_path at all
    if @devid is provided, thus no way to trigger the bug.
    
    [FIX]
    Before calling strcmp(), also make sure @device_path is not NULL.
    
    Fixes: a27a94c2b0c7 ("btrfs: Make btrfs_find_device_by_devspec return btrfs_device directly")
    CC: stable@vger.kernel.org # 5.4+
    Reported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8bde7b30278d099760562940b5f1ff107262206b
Author: DENG Qingfang <dqfext@gmail.com>
Date:   Wed Aug 11 17:50:43 2021 +0800

    net: dsa: mt7530: fix VLAN traffic leaks again
    
    commit 7428022b50d0fbb4846dd0f00639ea09d36dff02 upstream.
    
    When a port leaves a VLAN-aware bridge, the current code does not clear
    other ports' matrix field bit. If the bridge is later set to VLAN-unaware
    mode, traffic in the bridge may leak to that port.
    
    Remove the VLAN filtering check in mt7530_port_bridge_leave.
    
    Fixes: 474a2ddaa192 ("net: dsa: mt7530: fix VLAN traffic leaks")
    Fixes: 83163f7dca56 ("net: dsa: mediatek: add VLAN support for MT7530")
    Signed-off-by: DENG Qingfang <dqfext@gmail.com>
    Reviewed-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 53578c0483a19c5927322663ad16d6cfda0ba78f
Author: Pauli Virtanen <pav@iki.fi>
Date:   Mon Jul 26 21:02:06 2021 +0300

    Bluetooth: btusb: check conditions before enabling USB ALT 3 for WBS
    
    commit 55981d3541812234e687062926ff199c83f79a39 upstream.
    
    Some USB BT adapters don't satisfy the MTU requirement mentioned in
    commit e848dbd364ac ("Bluetooth: btusb: Add support USB ALT 3 for WBS")
    and have ALT 3 setting that produces no/garbled audio. Some adapters
    with larger MTU were also reported to have problems with ALT 3.
    
    Add a flag and check it and MTU before selecting ALT 3, falling back to
    ALT 1. Enable the flag for Realtek, restoring the previous behavior for
    non-Realtek devices.
    
    Tested with USB adapters (mtu<72, no/garbled sound with ALT3, ALT1
    works) BCM20702A1 0b05:17cb, CSR8510A10 0a12:0001, and (mtu>=72, ALT3
    works) RTL8761BU 0bda:8771, Intel AX200 8087:0029 (after disabling
    ALT6). Also got reports for (mtu>=72, ALT 3 reported to produce bad
    audio) Intel 8087:0a2b.
    
    Signed-off-by: Pauli Virtanen <pav@iki.fi>
    Fixes: e848dbd364ac ("Bluetooth: btusb: Add support USB ALT 3 for WBS")
    Tested-by: Michał Kępień <kernel@kempniu.pl>
    Tested-by: Jonathan Lampérth <jon@h4n.dev>
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit acf3c7b4fae092e7f5c170bc8a0fe2ead9b2a320
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 30 08:55:18 2021 -0700

    vt_kdsetmode: extend console locking
    
    commit 2287a51ba822384834dafc1c798453375d1107c7 upstream.
    
    As per the long-suffering comment.
    
    Reported-by: Minh Yuan <yuanmingbuaa@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jirislaby@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
