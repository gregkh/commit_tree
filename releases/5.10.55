commit 11fe69a17195cf58eff523f26f90de50660d0100
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Jul 31 08:16:13 2021 +0200

    Linux 5.10.55
    
    Link: https://lore.kernel.org/r/20210729135137.267680390@linuxfoundation.org
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Pavel Machek (CIP) <pavel@denx.de>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Shuah Khan <skhan@linuxfoundation.org>
    Tested-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Tested-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 984e93b8e20731f83e453dd056f8a3931b4a66e5
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Mon Jul 19 10:55:14 2021 +0300

    ipv6: ip6_finish_output2: set sk into newly allocated nskb
    
    [ Upstream commit 2d85a1b31dde84038ea07ad825c3d8d3e71f4344 ]
    
    skb_set_owner_w() should set sk not to old skb but to new nskb.
    
    Fixes: 5796015fa968 ("ipv6: allocate enough headroom in ip6_finish_output2()")
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Link: https://lore.kernel.org/r/70c0744f-89ae-1869-7e3e-4fa292158f4b@virtuozzo.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a74054ca75533dd9a0747b6c308daf27a6433ab4
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu Jul 1 14:21:18 2021 +0100

    ARM: dts: versatile: Fix up interrupt controller node names
    
    [ Upstream commit 82a1c67554dff610d6be4e1982c425717b3c6a23 ]
    
    Once the new schema interrupt-controller/arm,vic.yaml is added, we get
    the below warnings:
    
            arch/arm/boot/dts/versatile-ab.dt.yaml:
            intc@10140000: $nodename:0: 'intc@10140000' does not match
            '^interrupt-controller(@[0-9a-f,]+)*$'
    
            arch/arm/boot/dts/versatile-ab.dt.yaml:
            intc@10140000: 'clear-mask' does not match any of the regexes
    
    Fix the node names for the interrupt controller to conform
    to the standard node name interrupt-controller@.. Also drop invalid
    clear-mask property.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20210701132118.759454-1-sudeep.holla@arm.com'
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3510b9b41c70e2d51a05e2c6f558b522de8ab646
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jul 15 09:58:04 2021 -0700

    iomap: remove the length variable in iomap_seek_hole
    
    [ Upstream commit 49694d14ff68fa4b5f86019dbcfb44a8bd213e58 ]
    
    The length variable is rather pointless given that it can be trivially
    deduced from offset and size.  Also the initial calculation can lead
    to KASAN warnings.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reported-by: Leizhen (ThunderTown) <thunder.leizhen@huawei.com>
    Reviewed-by: Darrick J. Wong <djwong@kernel.org>
    Signed-off-by: Darrick J. Wong <djwong@kernel.org>
    Reviewed-by: Matthew Wilcox (Oracle) <willy@infradead.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8659186e72d0770720d052d39e4bee4a47366fd3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jul 15 09:58:04 2021 -0700

    iomap: remove the length variable in iomap_seek_data
    
    [ Upstream commit 3ac1d426510f97ace05093ae9f2f710d9cbe6215 ]
    
    The length variable is rather pointless given that it can be trivially
    deduced from offset and size.  Also the initial calculation can lead
    to KASAN warnings.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reported-by: Leizhen (ThunderTown) <thunder.leizhen@huawei.com>
    Reviewed-by: Darrick J. Wong <djwong@kernel.org>
    Signed-off-by: Darrick J. Wong <djwong@kernel.org>
    Reviewed-by: Matthew Wilcox (Oracle) <willy@infradead.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 65039407489c3baddbd883acc243867c2c28f9c3
Author: Hyunchul Lee <hyc.lee@gmail.com>
Date:   Mon Jul 12 19:34:02 2021 +0900

    cifs: fix the out of range assignment to bit fields in parse_server_interfaces
    
    [ Upstream commit c9c9c6815f9004ee1ec87401ed0796853bd70f1b ]
    
    Because the out of range assignment to bit fields
    are compiler-dependant, the fields could have wrong
    value.
    
    Signed-off-by: Hyunchul Lee <hyc.lee@gmail.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fe5fe0b1c8b91877c3b35482fc08c35cc9586842
Author: Cristian Marussi <cristian.marussi@arm.com>
Date:   Mon Jul 12 15:18:18 2021 +0100

    firmware: arm_scmi: Fix range check for the maximum number of pending messages
    
    [ Upstream commit bdb8742dc6f7c599c3d61959234fe4c23638727b ]
    
    SCMI message headers carry a sequence number and such field is sized to
    allow for MSG_TOKEN_MAX distinct numbers; moreover zero is not really an
    acceptable maximum number of pending in-flight messages.
    
    Fix accordingly the checks performed on the value exported by transports
    in scmi_desc.max_msg
    
    Link: https://lore.kernel.org/r/20210712141833.6628-3-cristian.marussi@arm.com
    Reported-by: Vincent Guittot <vincent.guittot@linaro.org>
    Signed-off-by: Cristian Marussi <cristian.marussi@arm.com>
    [sudeep.holla: updated the patch title and error message]
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8f8e5475a369d5424b2cac061b47ee08ef285db0
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Jul 7 14:50:28 2021 +0100

    firmware: arm_scmi: Fix possible scmi_linux_errmap buffer overflow
    
    [ Upstream commit 7a691f16ccad05d770f813d9c4b4337a30c6d63f ]
    
    The scmi_linux_errmap buffer access index is supposed to depend on the
    array size to prevent element out of bounds access. It uses SCMI_ERR_MAX
    to check bounds but that can mismatch with the array size. It also
    changes the success into -EIO though scmi_linux_errmap is never used in
    case of success, it is expected to work for success case too.
    
    It is slightly confusing code as the negative of the error code
    is used as index to the buffer. Fix it by negating it at the start and
    make it more readable.
    
    Link: https://lore.kernel.org/r/20210707135028.1869642-1-sudeep.holla@arm.com
    Reported-by: kernel test robot <lkp@intel.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Cristian Marussi <cristian.marussi@arm.com>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d01328fef6afffd1bdce6e8ead707b6f5a5de7a7
Author: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
Date:   Wed Jul 14 21:27:08 2021 -0700

    hfs: add lock nesting notation to hfs_find_init
    
    [ Upstream commit b3b2177a2d795e35dc11597b2609eb1e7e57e570 ]
    
    Syzbot reports a possible recursive lock in [1].
    
    This happens due to missing lock nesting information.  From the logs, we
    see that a call to hfs_fill_super is made to mount the hfs filesystem.
    While searching for the root inode, the lock on the catalog btree is
    grabbed.  Then, when the parent of the root isn't found, a call to
    __hfs_bnode_create is made to create the parent of the root.  This
    eventually leads to a call to hfs_ext_read_extent which grabs a lock on
    the extents btree.
    
    Since the order of locking is catalog btree -> extents btree, this lock
    hierarchy does not lead to a deadlock.
    
    To tell lockdep that this locking is safe, we add nesting notation to
    distinguish between catalog btrees, extents btrees, and attributes
    btrees (for HFS+).  This has already been done in hfsplus.
    
    Link: https://syzkaller.appspot.com/bug?id=f007ef1d7a31a469e3be7aeb0fde0769b18585db [1]
    Link: https://lkml.kernel.org/r/20210701030756.58760-4-desmondcheongzx@gmail.com
    Signed-off-by: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
    Reported-by: syzbot+b718ec84a87b7e73ade4@syzkaller.appspotmail.com
    Tested-by: syzbot+b718ec84a87b7e73ade4@syzkaller.appspotmail.com
    Reviewed-by: Viacheslav Dubeyko <slava@dubeyko.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Gustavo A. R. Silva <gustavoars@kernel.org>
    Cc: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 06b3d9923fa05f300c1d92a9259c01f7de72e670
Author: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
Date:   Wed Jul 14 21:27:05 2021 -0700

    hfs: fix high memory mapping in hfs_bnode_read
    
    [ Upstream commit 54a5ead6f5e2b47131a7385d0c0af18e7b89cb02 ]
    
    Pages that we read in hfs_bnode_read need to be kmapped into kernel
    address space.  However, currently only the 0th page is kmapped.  If the
    given offset + length exceeds this 0th page, then we have an invalid
    memory access.
    
    To fix this, we kmap relevant pages one by one and copy their relevant
    portions of data.
    
    An example of invalid memory access occurring without this fix can be seen
    in the following crash report:
    
      ==================================================================
      BUG: KASAN: use-after-free in memcpy include/linux/fortify-string.h:191 [inline]
      BUG: KASAN: use-after-free in hfs_bnode_read+0xc4/0xe0 fs/hfs/bnode.c:26
      Read of size 2 at addr ffff888125fdcffe by task syz-executor5/4634
    
      CPU: 0 PID: 4634 Comm: syz-executor5 Not tainted 5.13.0-syzkaller #0
      Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
      Call Trace:
       __dump_stack lib/dump_stack.c:79 [inline]
       dump_stack+0x195/0x1f8 lib/dump_stack.c:120
       print_address_description.constprop.0+0x1d/0x110 mm/kasan/report.c:233
       __kasan_report mm/kasan/report.c:419 [inline]
       kasan_report.cold+0x7b/0xd4 mm/kasan/report.c:436
       check_region_inline mm/kasan/generic.c:180 [inline]
       kasan_check_range+0x154/0x1b0 mm/kasan/generic.c:186
       memcpy+0x24/0x60 mm/kasan/shadow.c:65
       memcpy include/linux/fortify-string.h:191 [inline]
       hfs_bnode_read+0xc4/0xe0 fs/hfs/bnode.c:26
       hfs_bnode_read_u16 fs/hfs/bnode.c:34 [inline]
       hfs_bnode_find+0x880/0xcc0 fs/hfs/bnode.c:365
       hfs_brec_find+0x2d8/0x540 fs/hfs/bfind.c:126
       hfs_brec_read+0x27/0x120 fs/hfs/bfind.c:165
       hfs_cat_find_brec+0x19a/0x3b0 fs/hfs/catalog.c:194
       hfs_fill_super+0xc13/0x1460 fs/hfs/super.c:419
       mount_bdev+0x331/0x3f0 fs/super.c:1368
       hfs_mount+0x35/0x40 fs/hfs/super.c:457
       legacy_get_tree+0x10c/0x220 fs/fs_context.c:592
       vfs_get_tree+0x93/0x300 fs/super.c:1498
       do_new_mount fs/namespace.c:2905 [inline]
       path_mount+0x13f5/0x20e0 fs/namespace.c:3235
       do_mount fs/namespace.c:3248 [inline]
       __do_sys_mount fs/namespace.c:3456 [inline]
       __se_sys_mount fs/namespace.c:3433 [inline]
       __x64_sys_mount+0x2b8/0x340 fs/namespace.c:3433
       do_syscall_64+0x37/0xc0 arch/x86/entry/common.c:47
       entry_SYSCALL_64_after_hwframe+0x44/0xae
      RIP: 0033:0x45e63a
      Code: 48 c7 c2 bc ff ff ff f7 d8 64 89 02 b8 ff ff ff ff eb d2 e8 88 04 00 00 0f 1f 84 00 00 00 00 00 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
      RSP: 002b:00007f9404d410d8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a5
      RAX: ffffffffffffffda RBX: 0000000020000248 RCX: 000000000045e63a
      RDX: 0000000020000000 RSI: 0000000020000100 RDI: 00007f9404d41120
      RBP: 00007f9404d41120 R08: 00000000200002c0 R09: 0000000020000000
      R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000003
      R13: 0000000000000003 R14: 00000000004ad5d8 R15: 0000000000000000
    
      The buggy address belongs to the page:
      page:00000000dadbcf3e refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x125fdc
      flags: 0x2fffc0000000000(node=0|zone=2|lastcpupid=0x3fff)
      raw: 02fffc0000000000 ffffea000497f748 ffffea000497f6c8 0000000000000000
      raw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000
      page dumped because: kasan: bad access detected
    
      Memory state around the buggy address:
       ffff888125fdce80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
       ffff888125fdcf00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
      >ffff888125fdcf80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
                                                                      ^
       ffff888125fdd000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
       ffff888125fdd080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
      ==================================================================
    
    Link: https://lkml.kernel.org/r/20210701030756.58760-3-desmondcheongzx@gmail.com
    Signed-off-by: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
    Reviewed-by: Viacheslav Dubeyko <slava@dubeyko.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Gustavo A. R. Silva <gustavoars@kernel.org>
    Cc: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 680b2917e60ed0cf80d7d4479004844f9cddda81
Author: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
Date:   Wed Jul 14 21:27:01 2021 -0700

    hfs: add missing clean-up in hfs_fill_super
    
    [ Upstream commit 16ee572eaf0d09daa4c8a755fdb71e40dbf8562d ]
    
    Patch series "hfs: fix various errors", v2.
    
    This series ultimately aims to address a lockdep warning in
    hfs_find_init reported by Syzbot [1].
    
    The work done for this led to the discovery of another bug, and the
    Syzkaller repro test also reveals an invalid memory access error after
    clearing the lockdep warning.  Hence, this series is broken up into
    three patches:
    
    1. Add a missing call to hfs_find_exit for an error path in
       hfs_fill_super
    
    2. Fix memory mapping in hfs_bnode_read by fixing calls to kmap
    
    3. Add lock nesting notation to tell lockdep that the observed locking
       hierarchy is safe
    
    This patch (of 3):
    
    Before exiting hfs_fill_super, the struct hfs_find_data used in
    hfs_find_init should be passed to hfs_find_exit to be cleaned up, and to
    release the lock held on the btree.
    
    The call to hfs_find_exit is missing from an error path.  We add it back
    in by consolidating calls to hfs_find_exit for error paths.
    
    Link: https://syzkaller.appspot.com/bug?id=f007ef1d7a31a469e3be7aeb0fde0769b18585db [1]
    Link: https://lkml.kernel.org/r/20210701030756.58760-1-desmondcheongzx@gmail.com
    Link: https://lkml.kernel.org/r/20210701030756.58760-2-desmondcheongzx@gmail.com
    Signed-off-by: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
    Reviewed-by: Viacheslav Dubeyko <slava@dubeyko.com>
    Cc: Gustavo A. R. Silva <gustavoars@kernel.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Shuah Khan <skhan@linuxfoundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5c3d753b872a706af9317fef4edfb6b640d8a71e
Author: Zheyu Ma <zheyuma97@gmail.com>
Date:   Wed Jul 14 14:54:19 2021 +0000

    drm/ttm: add a check against null pointer dereference
    
    [ Upstream commit 9e5c772954406829e928dbe59891d08938ead04b ]
    
    When calling ttm_range_man_fini(), 'man' may be uninitialized, which may
    cause a null pointer dereference bug.
    
    Fix this by checking if it is a null pointer.
    
    This log reveals it:
    
    [    7.902580 ] BUG: kernel NULL pointer dereference, address: 0000000000000058
    [    7.905721 ] RIP: 0010:ttm_range_man_fini+0x40/0x160
    [    7.911826 ] Call Trace:
    [    7.911826 ]  radeon_ttm_fini+0x167/0x210
    [    7.911826 ]  radeon_bo_fini+0x15/0x40
    [    7.913767 ]  rs400_fini+0x55/0x80
    [    7.914358 ]  radeon_device_fini+0x3c/0x140
    [    7.914358 ]  radeon_driver_unload_kms+0x5c/0xe0
    [    7.914358 ]  radeon_driver_load_kms+0x13a/0x200
    [    7.914358 ]  ? radeon_driver_unload_kms+0xe0/0xe0
    [    7.914358 ]  drm_dev_register+0x1db/0x290
    [    7.914358 ]  radeon_pci_probe+0x16a/0x230
    [    7.914358 ]  local_pci_probe+0x4a/0xb0
    
    Signed-off-by: Zheyu Ma <zheyuma97@gmail.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1626274459-8148-1-git-send-email-zheyuma97@gmail.com
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2323690eb05865a657709f4d28eb9538ea97bfc2
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Mon Jul 12 09:45:06 2021 +0300

    ipv6: allocate enough headroom in ip6_finish_output2()
    
    [ Upstream commit 5796015fa968a3349027a27dcd04c71d95c53ba5 ]
    
    When TEE target mirrors traffic to another interface, sk_buff may
    not have enough headroom to be processed correctly.
    ip_finish_output2() detect this situation for ipv4 and allocates
    new skb with enogh headroom. However ipv6 lacks this logic in
    ip_finish_output2 and it leads to skb_under_panic:
    
     skbuff: skb_under_panic: text:ffffffffc0866ad4 len:96 put:24
     head:ffff97be85e31800 data:ffff97be85e317f8 tail:0x58 end:0xc0 dev:gre0
     ------------[ cut here ]------------
     kernel BUG at net/core/skbuff.c:110!
     invalid opcode: 0000 [#1] SMP PTI
     CPU: 2 PID: 393 Comm: kworker/2:2 Tainted: G           OE     5.13.0 #13
     Hardware name: Virtuozzo KVM, BIOS 1.11.0-2.vz7.4 04/01/2014
     Workqueue: ipv6_addrconf addrconf_dad_work
     RIP: 0010:skb_panic+0x48/0x4a
     Call Trace:
      skb_push.cold.111+0x10/0x10
      ipgre_header+0x24/0xf0 [ip_gre]
      neigh_connected_output+0xae/0xf0
      ip6_finish_output2+0x1a8/0x5a0
      ip6_output+0x5c/0x110
      nf_dup_ipv6+0x158/0x1000 [nf_dup_ipv6]
      tee_tg6+0x2e/0x40 [xt_TEE]
      ip6t_do_table+0x294/0x470 [ip6_tables]
      nf_hook_slow+0x44/0xc0
      nf_hook.constprop.34+0x72/0xe0
      ndisc_send_skb+0x20d/0x2e0
      ndisc_send_ns+0xd1/0x210
      addrconf_dad_work+0x3c8/0x540
      process_one_work+0x1d1/0x370
      worker_thread+0x30/0x390
      kthread+0x116/0x130
      ret_from_fork+0x22/0x30
    
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 86cb49e7314eb1ef53a4f7a015536febc889995e
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Tue May 25 11:28:40 2021 -0700

    rcu-tasks: Don't delete holdouts within trc_wait_for_one_reader()
    
    [ Upstream commit a9ab9cce9367a2cc02a3c7eb57a004dc0b8f380d ]
    
    Invoking trc_del_holdout() from within trc_wait_for_one_reader() is
    only a performance optimization because the RCU Tasks Trace grace-period
    kthread will eventually do this within check_all_holdout_tasks_trace().
    But it is not a particularly important performance optimization because
    it only applies to the grace-period kthread, of which there is but one.
    This commit therefore removes this invocation of trc_del_holdout() in
    favor of the one in check_all_holdout_tasks_trace() in the grace-period
    kthread.
    
    Reported-by: "Xu, Yanfei" <yanfei.xu@windriver.com>
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 55ddab2bfd7035347765e62748fd1e30cb3528d6
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Tue May 25 10:12:45 2021 -0700

    rcu-tasks: Don't delete holdouts within trc_inspect_reader()
    
    [ Upstream commit 1d10bf55d85d34eb73dd8263635f43fd72135d2d ]
    
    As Yanfei pointed out, although invoking trc_del_holdout() is safe
    from the viewpoint of the integrity of the holdout list itself,
    the put_task_struct() invoked by trc_del_holdout() can result in
    use-after-free errors due to later accesses to this task_struct structure
    by the RCU Tasks Trace grace-period kthread.
    
    This commit therefore removes this call to trc_del_holdout() from
    trc_inspect_reader() in favor of the grace-period thread's existing call
    to trc_del_holdout(), thus eliminating that particular class of
    use-after-free errors.
    
    Reported-by: "Xu, Yanfei" <yanfei.xu@windriver.com>
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4d972881f8d8e80e0320169e681284785cfe51e2
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Jun 29 23:34:08 2021 -0400

    sctp: move 198 addresses from unusable to private scope
    
    [ Upstream commit 1d11fa231cabeae09a95cb3e4cf1d9dd34e00f08 ]
    
    The doc draft-stewart-tsvwg-sctp-ipv4-00 that restricts 198 addresses
    was never published. These addresses as private addresses should be
    allowed to use in SCTP.
    
    As Michael Tuexen suggested, this patch is to move 198 addresses from
    unusable to private scope.
    
    Reported-by: Sérgio <surkamp@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 915226f31fd489f9a37894caacd9b4e5f5904a26
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Jun 29 07:12:45 2021 -0700

    net: annotate data race around sk_ll_usec
    
    [ Upstream commit 0dbffbb5335a1e3aa6855e4ee317e25e669dd302 ]
    
    sk_ll_usec is read locklessly from sk_can_busy_loop()
    while another thread can change its value in sock_setsockopt()
    
    This is correct but needs annotations.
    
    BUG: KCSAN: data-race in __skb_try_recv_datagram / sock_setsockopt
    
    write to 0xffff88814eb5f904 of 4 bytes by task 14011 on cpu 0:
     sock_setsockopt+0x1287/0x2090 net/core/sock.c:1175
     __sys_setsockopt+0x14f/0x200 net/socket.c:2100
     __do_sys_setsockopt net/socket.c:2115 [inline]
     __se_sys_setsockopt net/socket.c:2112 [inline]
     __x64_sys_setsockopt+0x62/0x70 net/socket.c:2112
     do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47
     entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    read to 0xffff88814eb5f904 of 4 bytes by task 14001 on cpu 1:
     sk_can_busy_loop include/net/busy_poll.h:41 [inline]
     __skb_try_recv_datagram+0x14f/0x320 net/core/datagram.c:273
     unix_dgram_recvmsg+0x14c/0x870 net/unix/af_unix.c:2101
     unix_seqpacket_recvmsg+0x5a/0x70 net/unix/af_unix.c:2067
     ____sys_recvmsg+0x15d/0x310 include/linux/uio.h:244
     ___sys_recvmsg net/socket.c:2598 [inline]
     do_recvmmsg+0x35c/0x9f0 net/socket.c:2692
     __sys_recvmmsg net/socket.c:2771 [inline]
     __do_sys_recvmmsg net/socket.c:2794 [inline]
     __se_sys_recvmmsg net/socket.c:2787 [inline]
     __x64_sys_recvmmsg+0xcf/0x150 net/socket.c:2787
     do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47
     entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    value changed: 0x00000000 -> 0x00000101
    
    Reported by Kernel Concurrency Sanitizer on:
    CPU: 1 PID: 14001 Comm: syz-executor.3 Not tainted 5.13.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 92289f58f01d1a7f76c763dbdf1ae4f02ddfab75
Author: Yang Yingliang <yangyingliang@huawei.com>
Date:   Tue Jun 29 19:53:28 2021 +0800

    net/802/garp: fix memleak in garp_request_join()
    
    [ Upstream commit 42ca63f980842918560b25f0244307fd83b4777c ]
    
    I got kmemleak report when doing fuzz test:
    
    BUG: memory leak
    unreferenced object 0xffff88810c909b80 (size 64):
      comm "syz", pid 957, jiffies 4295220394 (age 399.090s)
      hex dump (first 32 bytes):
        01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        00 00 00 00 00 00 00 00 08 00 00 00 01 02 00 04  ................
      backtrace:
        [<00000000ca1f2e2e>] garp_request_join+0x285/0x3d0
        [<00000000bf153351>] vlan_gvrp_request_join+0x15b/0x190
        [<0000000024005e72>] vlan_dev_open+0x706/0x980
        [<00000000dc20c4d4>] __dev_open+0x2bb/0x460
        [<0000000066573004>] __dev_change_flags+0x501/0x650
        [<0000000035b42f83>] rtnl_configure_link+0xee/0x280
        [<00000000a5e69de0>] __rtnl_newlink+0xed5/0x1550
        [<00000000a5258f4a>] rtnl_newlink+0x66/0x90
        [<00000000506568ee>] rtnetlink_rcv_msg+0x439/0xbd0
        [<00000000b7eaeae1>] netlink_rcv_skb+0x14d/0x420
        [<00000000c373ce66>] netlink_unicast+0x550/0x750
        [<00000000ec74ce74>] netlink_sendmsg+0x88b/0xda0
        [<00000000381ff246>] sock_sendmsg+0xc9/0x120
        [<000000008f6a2db3>] ____sys_sendmsg+0x6e8/0x820
        [<000000008d9c1735>] ___sys_sendmsg+0x145/0x1c0
        [<00000000aa39dd8b>] __sys_sendmsg+0xfe/0x1d0
    
    Calling garp_request_leave() after garp_request_join(), the attr->state
    is set to GARP_APPLICANT_VO, garp_attr_destroy() won't be called in last
    transmit event in garp_uninit_applicant(), the attr of applicant will be
    leaked. To fix this leak, iterate and free each attr of applicant before
    rerturning from garp_uninit_applicant().
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5d93810761b4beda2341372bd9d34a78cb9b22c2
Author: Yang Yingliang <yangyingliang@huawei.com>
Date:   Tue Jun 29 15:22:37 2021 +0800

    net/802/mrp: fix memleak in mrp_request_join()
    
    [ Upstream commit 996af62167d0e0ec69b938a3561e96f84ffff1aa ]
    
    I got kmemleak report when doing fuzz test:
    
    BUG: memory leak
    unreferenced object 0xffff88810c239500 (size 64):
    comm "syz-executor940", pid 882, jiffies 4294712870 (age 14.631s)
    hex dump (first 32 bytes):
    01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
    00 00 00 00 00 00 00 00 01 00 00 00 01 02 00 04 ................
    backtrace:
    [<00000000a323afa4>] slab_alloc_node mm/slub.c:2972 [inline]
    [<00000000a323afa4>] slab_alloc mm/slub.c:2980 [inline]
    [<00000000a323afa4>] __kmalloc+0x167/0x340 mm/slub.c:4130
    [<000000005034ca11>] kmalloc include/linux/slab.h:595 [inline]
    [<000000005034ca11>] mrp_attr_create net/802/mrp.c:276 [inline]
    [<000000005034ca11>] mrp_request_join+0x265/0x550 net/802/mrp.c:530
    [<00000000fcfd81f3>] vlan_mvrp_request_join+0x145/0x170 net/8021q/vlan_mvrp.c:40
    [<000000009258546e>] vlan_dev_open+0x477/0x890 net/8021q/vlan_dev.c:292
    [<0000000059acd82b>] __dev_open+0x281/0x410 net/core/dev.c:1609
    [<000000004e6dc695>] __dev_change_flags+0x424/0x560 net/core/dev.c:8767
    [<00000000471a09af>] rtnl_configure_link+0xd9/0x210 net/core/rtnetlink.c:3122
    [<0000000037a4672b>] __rtnl_newlink+0xe08/0x13e0 net/core/rtnetlink.c:3448
    [<000000008d5d0fda>] rtnl_newlink+0x64/0xa0 net/core/rtnetlink.c:3488
    [<000000004882fe39>] rtnetlink_rcv_msg+0x369/0xa10 net/core/rtnetlink.c:5552
    [<00000000907e6c54>] netlink_rcv_skb+0x134/0x3d0 net/netlink/af_netlink.c:2504
    [<00000000e7d7a8c4>] netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]
    [<00000000e7d7a8c4>] netlink_unicast+0x4a0/0x6a0 net/netlink/af_netlink.c:1340
    [<00000000e0645d50>] netlink_sendmsg+0x78e/0xc90 net/netlink/af_netlink.c:1929
    [<00000000c24559b7>] sock_sendmsg_nosec net/socket.c:654 [inline]
    [<00000000c24559b7>] sock_sendmsg+0x139/0x170 net/socket.c:674
    [<00000000fc210bc2>] ____sys_sendmsg+0x658/0x7d0 net/socket.c:2350
    [<00000000be4577b5>] ___sys_sendmsg+0xf8/0x170 net/socket.c:2404
    
    Calling mrp_request_leave() after mrp_request_join(), the attr->state
    is set to MRP_APPLICANT_VO, mrp_attr_destroy() won't be called in last
    TX event in mrp_uninit_applicant(), the attr of applicant will be leaked.
    To fix this leak, iterate and free each attr of applicant before rerturning
    from mrp_uninit_applicant().
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit df34f888628e961d8158dbd9712ebf04dfa4ad8c
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jun 16 08:51:57 2021 -0400

    cgroup1: fix leaked context root causing sporadic NULL deref in LTP
    
    commit 1e7107c5ef44431bc1ebbd4c353f1d7c22e5f2ec upstream.
    
    Richard reported sporadic (roughly one in 10 or so) null dereferences and
    other strange behaviour for a set of automated LTP tests.  Things like:
    
       BUG: kernel NULL pointer dereference, address: 0000000000000008
       #PF: supervisor read access in kernel mode
       #PF: error_code(0x0000) - not-present page
       PGD 0 P4D 0
       Oops: 0000 [#1] PREEMPT SMP PTI
       CPU: 0 PID: 1516 Comm: umount Not tainted 5.10.0-yocto-standard #1
       Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-48-gd9c812dda519-prebuilt.qemu.org 04/01/2014
       RIP: 0010:kernfs_sop_show_path+0x1b/0x60
    
    ...or these others:
    
       RIP: 0010:do_mkdirat+0x6a/0xf0
       RIP: 0010:d_alloc_parallel+0x98/0x510
       RIP: 0010:do_readlinkat+0x86/0x120
    
    There were other less common instances of some kind of a general scribble
    but the common theme was mount and cgroup and a dubious dentry triggering
    the NULL dereference.  I was only able to reproduce it under qemu by
    replicating Richard's setup as closely as possible - I never did get it
    to happen on bare metal, even while keeping everything else the same.
    
    In commit 71d883c37e8d ("cgroup_do_mount(): massage calling conventions")
    we see this as a part of the overall change:
    
       --------------
               struct cgroup_subsys *ss;
       -       struct dentry *dentry;
    
       [...]
    
       -       dentry = cgroup_do_mount(&cgroup_fs_type, fc->sb_flags, root,
       -                                CGROUP_SUPER_MAGIC, ns);
    
       [...]
    
       -       if (percpu_ref_is_dying(&root->cgrp.self.refcnt)) {
       -               struct super_block *sb = dentry->d_sb;
       -               dput(dentry);
       +       ret = cgroup_do_mount(fc, CGROUP_SUPER_MAGIC, ns);
       +       if (!ret && percpu_ref_is_dying(&root->cgrp.self.refcnt)) {
       +               struct super_block *sb = fc->root->d_sb;
       +               dput(fc->root);
                       deactivate_locked_super(sb);
                       msleep(10);
                       return restart_syscall();
               }
       --------------
    
    In changing from the local "*dentry" variable to using fc->root, we now
    export/leave that dentry pointer in the file context after doing the dput()
    in the unlikely "is_dying" case.   With LTP doing a crazy amount of back to
    back mount/unmount [testcases/bin/cgroup_regression_5_1.sh] the unlikely
    becomes slightly likely and then bad things happen.
    
    A fix would be to not leave the stale reference in fc->root as follows:
    
       --------------
                      dput(fc->root);
      +               fc->root = NULL;
                      deactivate_locked_super(sb);
       --------------
    
    ...but then we are just open-coding a duplicate of fc_drop_locked() so we
    simply use that instead.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Zefan Li <lizefan.x@bytedance.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: stable@vger.kernel.org      # v5.1+
    Reported-by: Richard Purdie <richard.purdie@linuxfoundation.org>
    Fixes: 71d883c37e8d ("cgroup_do_mount(): massage calling conventions")
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dcd00801f3d93bd898b697b7cfc5a5a8069648d2
Author: Yang Yingliang <yangyingliang@huawei.com>
Date:   Wed Jul 14 17:19:33 2021 +0800

    workqueue: fix UAF in pwq_unbound_release_workfn()
    
    commit b42b0bddcbc87b4c66f6497f66fc72d52b712aa7 upstream.
    
    I got a UAF report when doing fuzz test:
    
    [  152.880091][ T8030] ==================================================================
    [  152.881240][ T8030] BUG: KASAN: use-after-free in pwq_unbound_release_workfn+0x50/0x190
    [  152.882442][ T8030] Read of size 4 at addr ffff88810d31bd00 by task kworker/3:2/8030
    [  152.883578][ T8030]
    [  152.883932][ T8030] CPU: 3 PID: 8030 Comm: kworker/3:2 Not tainted 5.13.0+ #249
    [  152.885014][ T8030] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
    [  152.886442][ T8030] Workqueue: events pwq_unbound_release_workfn
    [  152.887358][ T8030] Call Trace:
    [  152.887837][ T8030]  dump_stack_lvl+0x75/0x9b
    [  152.888525][ T8030]  ? pwq_unbound_release_workfn+0x50/0x190
    [  152.889371][ T8030]  print_address_description.constprop.10+0x48/0x70
    [  152.890326][ T8030]  ? pwq_unbound_release_workfn+0x50/0x190
    [  152.891163][ T8030]  ? pwq_unbound_release_workfn+0x50/0x190
    [  152.891999][ T8030]  kasan_report.cold.15+0x82/0xdb
    [  152.892740][ T8030]  ? pwq_unbound_release_workfn+0x50/0x190
    [  152.893594][ T8030]  __asan_load4+0x69/0x90
    [  152.894243][ T8030]  pwq_unbound_release_workfn+0x50/0x190
    [  152.895057][ T8030]  process_one_work+0x47b/0x890
    [  152.895778][ T8030]  worker_thread+0x5c/0x790
    [  152.896439][ T8030]  ? process_one_work+0x890/0x890
    [  152.897163][ T8030]  kthread+0x223/0x250
    [  152.897747][ T8030]  ? set_kthread_struct+0xb0/0xb0
    [  152.898471][ T8030]  ret_from_fork+0x1f/0x30
    [  152.899114][ T8030]
    [  152.899446][ T8030] Allocated by task 8884:
    [  152.900084][ T8030]  kasan_save_stack+0x21/0x50
    [  152.900769][ T8030]  __kasan_kmalloc+0x88/0xb0
    [  152.901416][ T8030]  __kmalloc+0x29c/0x460
    [  152.902014][ T8030]  alloc_workqueue+0x111/0x8e0
    [  152.902690][ T8030]  __btrfs_alloc_workqueue+0x11e/0x2a0
    [  152.903459][ T8030]  btrfs_alloc_workqueue+0x6d/0x1d0
    [  152.904198][ T8030]  scrub_workers_get+0x1e8/0x490
    [  152.904929][ T8030]  btrfs_scrub_dev+0x1b9/0x9c0
    [  152.905599][ T8030]  btrfs_ioctl+0x122c/0x4e50
    [  152.906247][ T8030]  __x64_sys_ioctl+0x137/0x190
    [  152.906916][ T8030]  do_syscall_64+0x34/0xb0
    [  152.907535][ T8030]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  152.908365][ T8030]
    [  152.908688][ T8030] Freed by task 8884:
    [  152.909243][ T8030]  kasan_save_stack+0x21/0x50
    [  152.909893][ T8030]  kasan_set_track+0x20/0x30
    [  152.910541][ T8030]  kasan_set_free_info+0x24/0x40
    [  152.911265][ T8030]  __kasan_slab_free+0xf7/0x140
    [  152.911964][ T8030]  kfree+0x9e/0x3d0
    [  152.912501][ T8030]  alloc_workqueue+0x7d7/0x8e0
    [  152.913182][ T8030]  __btrfs_alloc_workqueue+0x11e/0x2a0
    [  152.913949][ T8030]  btrfs_alloc_workqueue+0x6d/0x1d0
    [  152.914703][ T8030]  scrub_workers_get+0x1e8/0x490
    [  152.915402][ T8030]  btrfs_scrub_dev+0x1b9/0x9c0
    [  152.916077][ T8030]  btrfs_ioctl+0x122c/0x4e50
    [  152.916729][ T8030]  __x64_sys_ioctl+0x137/0x190
    [  152.917414][ T8030]  do_syscall_64+0x34/0xb0
    [  152.918034][ T8030]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  152.918872][ T8030]
    [  152.919203][ T8030] The buggy address belongs to the object at ffff88810d31bc00
    [  152.919203][ T8030]  which belongs to the cache kmalloc-512 of size 512
    [  152.921155][ T8030] The buggy address is located 256 bytes inside of
    [  152.921155][ T8030]  512-byte region [ffff88810d31bc00, ffff88810d31be00)
    [  152.922993][ T8030] The buggy address belongs to the page:
    [  152.923800][ T8030] page:ffffea000434c600 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10d318
    [  152.925249][ T8030] head:ffffea000434c600 order:2 compound_mapcount:0 compound_pincount:0
    [  152.926399][ T8030] flags: 0x57ff00000010200(slab|head|node=1|zone=2|lastcpupid=0x7ff)
    [  152.927515][ T8030] raw: 057ff00000010200 dead000000000100 dead000000000122 ffff888009c42c80
    [  152.928716][ T8030] raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000
    [  152.929890][ T8030] page dumped because: kasan: bad access detected
    [  152.930759][ T8030]
    [  152.931076][ T8030] Memory state around the buggy address:
    [  152.931851][ T8030]  ffff88810d31bc00: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  152.932967][ T8030]  ffff88810d31bc80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  152.934068][ T8030] >ffff88810d31bd00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  152.935189][ T8030]                    ^
    [  152.935763][ T8030]  ffff88810d31bd80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  152.936847][ T8030]  ffff88810d31be00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  152.937940][ T8030] ==================================================================
    
    If apply_wqattrs_prepare() fails in alloc_workqueue(), it will call put_pwq()
    which invoke a work queue to call pwq_unbound_release_workfn() and use the 'wq'.
    The 'wq' allocated in alloc_workqueue() will be freed in error path when
    apply_wqattrs_prepare() fails. So it will lead a UAF.
    
    CPU0                                          CPU1
    alloc_workqueue()
    alloc_and_link_pwqs()
    apply_wqattrs_prepare() fails
    apply_wqattrs_cleanup()
    schedule_work(&pwq->unbound_release_work)
    kfree(wq)
                                                  worker_thread()
                                                  pwq_unbound_release_workfn() <- trigger uaf here
    
    If apply_wqattrs_prepare() fails, the new pwq are not linked, it doesn't
    hold any reference to the 'wq', 'wq' is invalid to access in the worker,
    so add check pwq if linked to fix this.
    
    Fixes: 2d5f0764b526 ("workqueue: split apply_workqueue_attrs() into 3 stages")
    Cc: stable@vger.kernel.org # v4.2+
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Suggested-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
    Reviewed-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Tested-by: Pavel Skripkin <paskripkin@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 93c5951e0ce137e994237c19cd75a7caa1f80543
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 28 14:47:20 2021 +0200

    af_unix: fix garbage collect vs MSG_PEEK
    
    commit cbcf01128d0a92e131bd09f1688fe032480b65ca upstream.
    
    unix_gc() assumes that candidate sockets can never gain an external
    reference (i.e.  be installed into an fd) while the unix_gc_lock is
    held.  Except for MSG_PEEK this is guaranteed by modifying inflight
    count under the unix_gc_lock.
    
    MSG_PEEK does not touch any variable protected by unix_gc_lock (file
    count is not), yet it needs to be serialized with garbage collection.
    Do this by locking/unlocking unix_gc_lock:
    
     1) increment file count
    
     2) lock/unlock barrier to make sure incremented file count is visible
        to garbage collection
    
     3) install file into fd
    
    This is a lock barrier (unlike smp_mb()) that ensures that garbage
    collection is run completely before or completely after the barrier.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dee8119eaa9e00f0d1e14f050e1867813a49a1bb
Author: Maxim Levitsky <mlevitsk@redhat.com>
Date:   Thu Feb 25 17:41:32 2021 +0200

    KVM: x86: determine if an exception has an error code only when injecting it.
    
    commit b97f074583736c42fb36f2da1164e28c73758912 upstream.
    
    A page fault can be queued while vCPU is in real paged mode on AMD, and
    AMD manual asks the user to always intercept it
    (otherwise result is undefined).
    The resulting VM exit, does have an error code.
    
    Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
    Message-Id: <20210225154135.405125-2-mlevitsk@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Zubin Mithra <zsm@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6f5d7a45f58d3abe3a936de1441b8d6318f978ff
Author: Pavel Begunkov <asml.silence@gmail.com>
Date:   Mon Jul 26 16:17:20 2021 +0100

    io_uring: fix link timeout refs
    
    [ Upstream commit a298232ee6b9a1d5d732aa497ff8be0d45b5bd82 ]
    
    WARNING: CPU: 0 PID: 10242 at lib/refcount.c:28 refcount_warn_saturate+0x15b/0x1a0 lib/refcount.c:28
    RIP: 0010:refcount_warn_saturate+0x15b/0x1a0 lib/refcount.c:28
    Call Trace:
     __refcount_sub_and_test include/linux/refcount.h:283 [inline]
     __refcount_dec_and_test include/linux/refcount.h:315 [inline]
     refcount_dec_and_test include/linux/refcount.h:333 [inline]
     io_put_req fs/io_uring.c:2140 [inline]
     io_queue_linked_timeout fs/io_uring.c:6300 [inline]
     __io_queue_sqe+0xbef/0xec0 fs/io_uring.c:6354
     io_submit_sqe fs/io_uring.c:6534 [inline]
     io_submit_sqes+0x2bbd/0x7c50 fs/io_uring.c:6660
     __do_sys_io_uring_enter fs/io_uring.c:9240 [inline]
     __se_sys_io_uring_enter+0x256/0x1d60 fs/io_uring.c:9182
    
    io_link_timeout_fn() should put only one reference of the linked timeout
    request, however in case of racing with the master request's completion
    first io_req_complete() puts one and then io_put_req_deferred() is
    called.
    
    Cc: stable@vger.kernel.org # 5.12+
    Fixes: 9ae1f8dd372e0 ("io_uring: fix inconsistent lock state")
    Reported-by: syzbot+a2910119328ce8e7996f@syzkaller.appspotmail.com
    Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
    Link: https://lore.kernel.org/r/ff51018ff29de5ffa76f09273ef48cb24c720368.1620417627.git.asml.silence@gmail.com
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Tested-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 475312897ea6b4b9a9a56c838aec6370c42f7315
Author: Yonghong Song <yhs@fb.com>
Date:   Tue Apr 13 08:34:19 2021 -0700

    tools: Allow proper CC/CXX/... override with LLVM=1 in Makefile.include
    
    commit f62700ce63a315b4607cc9e97aa15ea409a677b9 upstream.
    
    selftests/bpf/Makefile includes tools/scripts/Makefile.include.
    With the following command
      make -j60 LLVM=1 LLVM_IAS=1  <=== compile kernel
      make -j60 -C tools/testing/selftests/bpf LLVM=1 LLVM_IAS=1 V=1
    some files are still compiled with gcc. This patch
    fixed the case if CC/AR/LD/CXX/STRIP is allowed to be
    overridden, it will be written to clang/llvm-ar/..., instead of
    gcc binaries. The definition of CC_NO_CLANG is also relocated
    to the place after the above CC is defined.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20210413153419.3028165-1-yhs@fb.com
    Cc: Anders Roxell <anders.roxell@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
