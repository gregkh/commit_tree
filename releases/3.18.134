commit 49ab1e524f6a1fd0b42aefc827d57413e5332e92
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Feb 6 17:34:54 2019 +0100

    Linux 3.18.134

commit 9b59612715f8615864d758ef29c6975b21cf6383
Author: David Hildenbrand <david@redhat.com>
Date:   Fri Feb 1 14:21:19 2019 -0800

    mm: migrate: don't rely on __PageMovable() of newpage after unlocking it
    
    commit e0a352fabce61f730341d119fbedf71ffdb8663f upstream.
    
    We had a race in the old balloon compaction code before b1123ea6d3b3
    ("mm: balloon: use general non-lru movable page feature") refactored it
    that became visible after backporting 195a8c43e93d ("virtio-balloon:
    deflate via a page list") without the refactoring.
    
    The bug existed from commit d6d86c0a7f8d ("mm/balloon_compaction:
    redesign ballooned pages management") till b1123ea6d3b3 ("mm: balloon:
    use general non-lru movable page feature").  d6d86c0a7f8d
    ("mm/balloon_compaction: redesign ballooned pages management") was
    backported to 3.12, so the broken kernels are stable kernels [3.12 -
    4.7].
    
    There was a subtle race between dropping the page lock of the newpage in
    __unmap_and_move() and checking for __is_movable_balloon_page(newpage).
    
    Just after dropping this page lock, virtio-balloon could go ahead and
    deflate the newpage, effectively dequeueing it and clearing PageBalloon,
    in turn making __is_movable_balloon_page(newpage) fail.
    
    This resulted in dropping the reference of the newpage via
    putback_lru_page(newpage) instead of put_page(newpage), leading to
    page->lru getting modified and a !LRU page ending up in the LRU lists.
    With 195a8c43e93d ("virtio-balloon: deflate via a page list")
    backported, one would suddenly get corrupted lists in
    release_pages_balloon():
    
    - WARNING: CPU: 13 PID: 6586 at lib/list_debug.c:59 __list_del_entry+0xa1/0xd0
    - list_del corruption. prev->next should be ffffe253961090a0, but was dead000000000100
    
    Nowadays this race is no longer possible, but it is hidden behind very
    ugly handling of __ClearPageMovable() and __PageMovable().
    
    __ClearPageMovable() will not make __PageMovable() fail, only
    PageMovable().  So the new check (__PageMovable(newpage)) will still
    hold even after newpage was dequeued by virtio-balloon.
    
    If anybody would ever change that special handling, the BUG would be
    introduced again.  So instead, make it explicit and use the information
    of the original isolated page before migration.
    
    This patch can be backported fairly easy to stable kernels (in contrast
    to the refactoring).
    
    Link: http://lkml.kernel.org/r/20190129233217.10747-1-david@redhat.com
    Fixes: d6d86c0a7f8d ("mm/balloon_compaction: redesign ballooned pages management")
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Reported-by: Vratislav Bendel <vbendel@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Rafael Aquini <aquini@redhat.com>
    Cc: Mel Gorman <mgorman@techsingularity.net>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Vratislav Bendel <vbendel@redhat.com>
    Cc: Rafael Aquini <aquini@redhat.com>
    Cc: Konstantin Khlebnikov <k.khlebnikov@samsung.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: <stable@vger.kernel.org>    [3.12 - 4.7]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 98ea95b83600fa5193497b5deb81f67650b3ea12
Author: Shakeel Butt <shakeelb@google.com>
Date:   Fri Feb 1 14:20:54 2019 -0800

    mm, oom: fix use-after-free in oom_kill_process
    
    commit cefc7ef3c87d02fc9307835868ff721ea12cc597 upstream.
    
    Syzbot instance running on upstream kernel found a use-after-free bug in
    oom_kill_process.  On further inspection it seems like the process
    selected to be oom-killed has exited even before reaching
    read_lock(&tasklist_lock) in oom_kill_process().  More specifically the
    tsk->usage is 1 which is due to get_task_struct() in oom_evaluate_task()
    and the put_task_struct within for_each_thread() frees the tsk and
    for_each_thread() tries to access the tsk.  The easiest fix is to do
    get/put across the for_each_thread() on the selected task.
    
    Now the next question is should we continue with the oom-kill as the
    previously selected task has exited? However before adding more
    complexity and heuristics, let's answer why we even look at the children
    of oom-kill selected task? The select_bad_process() has already selected
    the worst process in the system/memcg.  Due to race, the selected
    process might not be the worst at the kill time but does that matter?
    The userspace can use the oom_score_adj interface to prefer children to
    be killed before the parent.  I looked at the history but it seems like
    this is there before git history.
    
    Link: http://lkml.kernel.org/r/20190121215850.221745-1-shakeelb@google.com
    Reported-by: syzbot+7fbbfa368521945f0e3d@syzkaller.appspotmail.com
    Fixes: 6b0c81b3be11 ("mm, oom: reduce dependency on tasklist_lock")
    Signed-off-by: Shakeel Butt <shakeelb@google.com>
    Reviewed-by: Roman Gushchin <guro@fb.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 844e011513fbccc60fd059d9e8e15011490bd37e
Author: Jo達o Paulo Rechi Vita <jprvita@gmail.com>
Date:   Wed Oct 31 17:21:28 2018 -0700

    platform/x86: asus-nb-wmi: Drop mapping of 0x33 and 0x34 scan codes
    
    [ Upstream commit 71b12beaf12f21a53bfe100795d0797f1035b570 ]
    
    According to Asus firmware engineers, the meaning of these codes is only
    to notify the OS that the screen brightness has been turned on/off by
    the EC. This does not match the meaning of KEY_DISPLAYTOGGLE /
    KEY_DISPLAY_OFF, where userspace is expected to change the display
    brightness.
    
    Signed-off-by: Jo達o Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 15890adab2e6e05d9795d3cfec78c3b06b50f8f7
Author: Jo達o Paulo Rechi Vita <jprvita@gmail.com>
Date:   Wed Oct 31 17:21:27 2018 -0700

    platform/x86: asus-nb-wmi: Map 0x35 to KEY_SCREENLOCK
    
    [ Upstream commit b3f2f3799a972d3863d0fdc2ab6287aef6ca631f ]
    
    When the OS registers to handle events from the display off hotkey the
    EC will send a notification with 0x35 for every key press, independent
    of the backlight state.
    
    The behavior of this key on Windows, with the ATKACPI driver from Asus
    installed, is turning off the backlight of all connected displays with a
    fading effect, and any cursor input or key press turning the backlight
    back on. The key press or cursor input that wakes up the display is also
    passed through to the application under the cursor or under focus.
    
    The key that matches this behavior the closest is KEY_SCREENLOCK.
    
    Signed-off-by: Jo達o Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 01c06a4553106a91e0b1fb002d13d32ddfbc9447
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Jan 30 21:30:36 2019 +0100

    gfs2: Revert "Fix loop in gfs2_rbm_find"
    
    commit e74c98ca2d6ae4376cc15fa2a22483430909d96b upstream.
    
    This reverts commit 2d29f6b96d8f80322ed2dd895bca590491c38d34.
    
    It turns out that the fix can lead to a ~20 percent performance regression
    in initial writes to the page cache according to iozone.  Let's revert this
    for now to have more time for a proper fix.
    
    Cc: stable@vger.kernel.org # v3.13+
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2eca8cac47adc3beabbc786f8855034206004ee6
Author: Waiman Long <longman@redhat.com>
Date:   Wed Jan 30 13:52:36 2019 -0500

    fs/dcache: Fix incorrect nr_dentry_unused accounting in shrink_dcache_sb()
    
    commit 1dbd449c9943e3145148cc893c2461b72ba6fef0 upstream.
    
    The nr_dentry_unused per-cpu counter tracks dentries in both the LRU
    lists and the shrink lists where the DCACHE_LRU_LIST bit is set.
    
    The shrink_dcache_sb() function moves dentries from the LRU list to a
    shrink list and subtracts the dentry count from nr_dentry_unused.  This
    is incorrect as the nr_dentry_unused count will also be decremented in
    shrink_dentry_list() via d_shrink_del().
    
    To fix this double decrement, the decrement in the shrink_dcache_sb()
    function is taken out.
    
    Fixes: 4e717f5c1083 ("list_lru: remove special case function list_lru_dispose_all."
    Cc: stable@kernel.org
    Signed-off-by: Waiman Long <longman@redhat.com>
    Reviewed-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3a4b0cbdca0665a5e2935ad686c585945247c5dd
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Sat Jan 26 12:21:32 2019 -0800

    CIFS: Do not count -ENODATA as failure for query directory
    
    commit 8e6e72aeceaaed5aeeb1cb43d3085de7ceb14f79 upstream.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ed38538f3833b238e4a1e8cbd918fadf01c3b2de
Author: Jacob Wen <jian.w.wen@oracle.com>
Date:   Wed Jan 30 14:55:14 2019 +0800

    l2tp: fix reading optional fields of L2TPv3
    
    [ Upstream commit 4522a70db7aa5e77526a4079628578599821b193 ]
    
    Use pskb_may_pull() to make sure the optional fields are in skb linear
    parts, so we can safely read them later.
    
    It's easy to reproduce the issue with a net driver that supports paged
    skb data. Just create a L2TPv3 over IP tunnel and then generates some
    network traffic.
    Once reproduced, rx err in /sys/kernel/debug/l2tp/tunnels will increase.
    
    Changes in v4:
    1. s/l2tp_v3_pull_opt/l2tp_v3_ensure_opt_in_linear/
    2. s/tunnel->version != L2TP_HDR_VER_2/tunnel->version == L2TP_HDR_VER_3/
    3. Add 'Fixes' in commit messages.
    
    Changes in v3:
    1. To keep consistency, move the code out of l2tp_recv_common.
    2. Use "net" instead of "net-next", since this is a bug fix.
    
    Changes in v2:
    1. Only fix L2TPv3 to make code simple.
       To fix both L2TPv3 and L2TPv2, we'd better refactor l2tp_recv_common.
       It's complicated to do so.
    2. Reloading pointers after pskb_may_pull
    
    Fixes: f7faffa3ff8e ("l2tp: Add L2TPv3 protocol support")
    Fixes: 0d76751fad77 ("l2tp: Add L2TPv3 IP encapsulation (no UDP) support")
    Fixes: a32e0eec7042 ("l2tp: introduce L2TPv3 IP encapsulation support for IPv6")
    Signed-off-by: Jacob Wen <jian.w.wen@oracle.com>
    Acked-by: Guillaume Nault <gnault@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 78e36d3887bcb75396bc0f5d2561f4a8f9c2fb19
Author: Lorenzo Bianconi <lorenzo.bianconi@redhat.com>
Date:   Tue Jan 16 23:01:55 2018 +0100

    l2tp: remove l2specific_len dependency in l2tp_core
    
    commit 62e7b6a57c7b9bf3c6fd99418eeec05b08a85c38 upstream.
    
    Remove l2specific_len dependency while building l2tpv3 header or
    parsing the received frame since default L2-Specific Sublayer is
    always four bytes long and we don't need to rely on a user supplied
    value.
    Moreover in l2tp netlink code there are no sanity checks to
    enforce the relation between l2specific_len and l2specific_type,
    so sending a malformed netlink message is possible to set
    l2specific_type to L2TP_L2SPECTYPE_DEFAULT (or even
    L2TP_L2SPECTYPE_NONE) and set l2specific_len to a value greater than
    4 leaking memory on the wire and sending corrupted frames.
    
    Reviewed-by: Guillaume Nault <g.nault@alphalink.fr>
    Tested-by: Guillaume Nault <g.nault@alphalink.fr>
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c970a01de93a122a8e014a1e91107ba4a7c363fb
Author: Mathias Thore <mathias.thore@infinera.com>
Date:   Mon Jan 28 10:07:47 2019 +0100

    ucc_geth: Reset BQL queue when stopping device
    
    [ Upstream commit e15aa3b2b1388c399c1a2ce08550d2cc4f7e3e14 ]
    
    After a timeout event caused by for example a broadcast storm, when
    the MAC and PHY are reset, the BQL TX queue needs to be reset as
    well. Otherwise, the device will exhibit severe performance issues
    even after the storm has ended.
    
    Co-authored-by: David Gounaris <david.gounaris@infinera.com>
    Signed-off-by: Mathias Thore <mathias.thore@infinera.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 537e674b96f8dc6d466419c5336fb082bad97b94
Author: Bernard Pidoux <f6bvp@free.fr>
Date:   Fri Jan 25 11:46:40 2019 +0100

    net/rose: fix NULL ax25_cb kernel panic
    
    [ Upstream commit b0cf029234f9b18e10703ba5147f0389c382bccc ]
    
    When an internally generated frame is handled by rose_xmit(),
    rose_route_frame() is called:
    
            if (!rose_route_frame(skb, NULL)) {
                    dev_kfree_skb(skb);
                    stats->tx_errors++;
                    return NETDEV_TX_OK;
            }
    
    We have the same code sequence in Net/Rom where an internally generated
    frame is handled by nr_xmit() calling nr_route_frame(skb, NULL).
    However, in this function NULL argument is tested while it is not in
    rose_route_frame().
    Then kernel panic occurs later on when calling ax25cmp() with a NULL
    ax25_cb argument as reported many times and recently with syzbot.
    
    We need to test if ax25 is NULL before using it.
    
    Testing:
    Built kernel with CONFIG_ROSE=y.
    
    Signed-off-by: Bernard Pidoux <f6bvp@free.fr>
    Acked-by: Dmitry Vyukov <dvyukov@google.com>
    Reported-by: syzbot+1a2c456a1ea08fa5b5f7@syzkaller.appspotmail.com
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Bernard Pidoux <f6bvp@free.fr>
    Cc: linux-hams@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f1d9a1f2ef6ff17293d21d5e6b80e04bea0cf508
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Thu Jan 24 14:18:18 2019 -0800

    netrom: switch to sock timer API
    
    [ Upstream commit 63346650c1a94a92be61a57416ac88c0a47c4327 ]
    
    sk_reset_timer() and sk_stop_timer() properly handle
    sock refcnt for timer function. Switching to them
    could fix a refcounting bug reported by syzbot.
    
    Reported-and-tested-by: syzbot+defa700d16f1bd1b9a05@syzkaller.appspotmail.com
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-hams@vger.kernel.org
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5f91b3a3ef756a52f137298f5b5d8c34838c00b0
Author: Jacob Wen <jian.w.wen@oracle.com>
Date:   Thu Jan 31 15:18:56 2019 +0800

    l2tp: copy 4 more bytes to linear part if necessary
    
    [ Upstream commit 91c524708de6207f59dd3512518d8a1c7b434ee3 ]
    
    The size of L2TPv2 header with all optional fields is 14 bytes.
    l2tp_udp_recv_core only moves 10 bytes to the linear part of a
    skb. This may lead to l2tp_recv_common read data outside of a skb.
    
    This patch make sure that there is at least 14 bytes in the linear
    part of a skb to meet the maximum need of l2tp_udp_recv_core and
    l2tp_recv_common. The minimum size of both PPP HDLC-like frame and
    Ethernet frame is larger than 14 bytes, so we are safe to do so.
    
    Also remove L2TP_HDR_SIZE_NOSEQ, it is unused now.
    
    Fixes: fd558d186df2 ("l2tp: Split pppol2tp patch into separate l2tp and ppp parts")
    Suggested-by: Guillaume Nault <gnault@redhat.com>
    Signed-off-by: Jacob Wen <jian.w.wen@oracle.com>
    Acked-by: Guillaume Nault <gnault@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 85d72db871830adafc06411969171c1ae7e6af78
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Jan 2 18:57:09 2019 -0800

    ipv6: Consider sk_bound_dev_if when binding a socket to an address
    
    [ Upstream commit c5ee066333ebc322a24a00a743ed941a0c68617e ]
    
    IPv6 does not consider if the socket is bound to a device when binding
    to an address. The result is that a socket can be bound to eth0 and then
    bound to the address of eth1. If the device is a VRF, the result is that
    a socket can only be bound to an address in the default VRF.
    
    Resolve by considering the device if sk_bound_dev_if is set.
    
    This problem exists from the beginning of git history.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 41dd4d6473300032ee6fd1c2b107ea7db4100bc8
Author: Pan Bian <bianpan2016@163.com>
Date:   Thu Nov 22 18:58:46 2018 +0800

    f2fs: read page index before freeing
    
    commit 0ea295dd853e0879a9a30ab61f923c26be35b902 upstream.
    
    The function truncate_node frees the page with f2fs_put_page. However,
    the page index is read after that. So, the patch reads the index before
    freeing the page.
    
    Fixes: bf39c00a9a7f ("f2fs: drop obsolete node page when it is truncated")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Pan Bian <bianpan2016@163.com>
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1330478d468cbbfefa2cb7d6cbdc8c3cc61d5a37
Author: Milian Wolff <milian.wolff@kdab.com>
Date:   Mon Oct 29 15:16:44 2018 +0100

    perf unwind: Take pgoff into account when reporting elf to libdwfl
    
    [ Upstream commit 1fe627da30331024f453faef04d500079b901107 ]
    
    libdwfl parses an ELF file itself and creates mappings for the
    individual sections. perf on the other hand sees raw mmap events which
    represent individual sections. When we encounter an address pointing
    into a mapping with pgoff != 0, we must take that into account and
    report the file at the non-offset base address.
    
    This fixes unwinding with libdwfl in some cases. E.g. for a file like:
    
    ```
    
    using namespace std;
    
    mutex g_mutex;
    
    double worker()
    {
        lock_guard<mutex> guard(g_mutex);
        uniform_real_distribution<double> uniform(-1E5, 1E5);
        default_random_engine engine;
        double s = 0;
        for (int i = 0; i < 1000; ++i) {
            s += norm(complex<double>(uniform(engine), uniform(engine)));
        }
        cout << s << endl;
        return s;
    }
    
    int main()
    {
        vector<std::future<double>> results;
        for (int i = 0; i < 10000; ++i) {
            results.push_back(async(launch::async, worker));
        }
        return 0;
    }
    ```
    
    Compile it with `g++ -g -O2 -lpthread cpp-locking.cpp  -o cpp-locking`,
    then record it with `perf record --call-graph dwarf -e
    sched:sched_switch`.
    
    When you analyze it with `perf script` and libunwind, you should see:
    
    ```
    cpp-locking 20038 [005] 54830.236589: sched:sched_switch: prev_comm=cpp-locking prev_pid=20038 prev_prio=120 prev_state=T ==> next_comm=swapper/5 next_pid=0 next_prio=120
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1670208 schedule+0x28 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb16737cc rwsem_down_read_failed+0xec (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1665e04 call_rwsem_down_read_failed+0x14 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1672a03 down_read+0x13 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb106bd85 __do_page_fault+0x445 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb18015f5 page_fault+0x45 (/lib/modules/4.14.78-1-lts/build/vmlinux)
                7f38e4252591 new_heap+0x101 (/usr/lib/libc-2.28.so)
                7f38e4252d0b arena_get2.part.4+0x2fb (/usr/lib/libc-2.28.so)
                7f38e4255b1c tcache_init.part.6+0xec (/usr/lib/libc-2.28.so)
                7f38e42569e5 __GI___libc_malloc+0x115 (inlined)
                7f38e4241790 __GI__IO_file_doallocate+0x90 (inlined)
                7f38e424fbbf __GI__IO_doallocbuf+0x4f (inlined)
                7f38e424ee47 __GI__IO_file_overflow+0x197 (inlined)
                7f38e424df36 _IO_new_file_xsputn+0x116 (inlined)
                7f38e4242bfb __GI__IO_fwrite+0xdb (inlined)
                7f38e463fa6d std::basic_streambuf<char, std::char_traits<char> >::sputn(char const*, long)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> >::_M_put(char const*, long)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> > std::__write<char>(std::ostreambuf_iterator<char, std::char_traits<char> >, char const*, int)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_float<double>(std::ostreambuf_iterator<c>
                7f38e464bd70 std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, double) const+0x90 (inl>
                7f38e464bd70 std::ostream& std::ostream::_M_insert<double>(double)+0x90 (/usr/lib/libstdc++.so.6.0.25)
                563b9cb502f7 std::ostream::operator<<(double)+0xb7 (inlined)
                563b9cb502f7 worker()+0xb7 (/ssd/milian/projects/kdab/rnd/hotspot/build/tests/test-clients/cpp-locking/cpp-locking)
                563b9cb506fb double std::__invoke_impl<double, double (*)()>(std::__invoke_other, double (*&&)())+0x2b (inlined)
                563b9cb506fb std::__invoke_result<double (*)()>::type std::__invoke<double (*)()>(double (*&&)())+0x2b (inlined)
                563b9cb506fb decltype (__invoke((_S_declval<0ul>)())) std::thread::_Invoker<std::tuple<double (*)()> >::_M_invoke<0ul>(std::_Index_tuple<0ul>)+0x2b (inlined)
                563b9cb506fb std::thread::_Invoker<std::tuple<double (*)()> >::operator()()+0x2b (inlined)
                563b9cb506fb std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<double>, std::__future_base::_Result_base::_Deleter>, std::thread::_Invoker<std::tuple<double (*)()> >, dou>
                563b9cb506fb std::_Function_handler<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (), std::__future_base::_Task_setter<std::unique_ptr<std::__future_>
                563b9cb507e8 std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>::operator()() const+0x28 (inlined)
                563b9cb507e8 std::__future_base::_State_baseV2::_M_do_set(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)+0x28 (/ssd/milian/>
                7f38e46d24fe __pthread_once_slow+0xbe (/usr/lib/libpthread-2.28.so)
                563b9cb51149 __gthread_once+0xe9 (inlined)
                563b9cb51149 void std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>*, bool*)>
                563b9cb51149 std::__future_base::_State_baseV2::_M_set_result(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> ()>, bool)+0xe9 (inlined)
                563b9cb51149 std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread::_Invoker<std::tuple<double (*)()> >&&)::{lambda()#1}::op>
                563b9cb51149 void std::__invoke_impl<void, std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread::_Invoker<std::tuple<double>
                563b9cb51149 std::__invoke_result<std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread::_Invoker<std::tuple<double (*)()> >>
                563b9cb51149 decltype (__invoke((_S_declval<0ul>)())) std::thread::_Invoker<std::tuple<std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_>
                563b9cb51149 std::thread::_Invoker<std::tuple<std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread::_Invoker<std::tuple<dou>
                563b9cb51149 std::thread::_State_impl<std::thread::_Invoker<std::tuple<std::__future_base::_Async_state_impl<std::thread::_Invoker<std::tuple<double (*)()> >, double>::_Async_state_impl(std::thread>
                7f38e45f0062 execute_native_thread_routine+0x12 (/usr/lib/libstdc++.so.6.0.25)
                7f38e46caa9c start_thread+0xfc (/usr/lib/libpthread-2.28.so)
                7f38e42ccb22 __GI___clone+0x42 (inlined)
    ```
    
    Before this patch, using libdwfl, you would see:
    
    ```
    cpp-locking 20038 [005] 54830.236589: sched:sched_switch: prev_comm=cpp-locking prev_pid=20038 prev_prio=120 prev_state=T ==> next_comm=swapper/5 next_pid=0 next_prio=120
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1670208 schedule+0x28 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb16737cc rwsem_down_read_failed+0xec (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1665e04 call_rwsem_down_read_failed+0x14 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1672a03 down_read+0x13 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb106bd85 __do_page_fault+0x445 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb18015f5 page_fault+0x45 (/lib/modules/4.14.78-1-lts/build/vmlinux)
                7f38e4252591 new_heap+0x101 (/usr/lib/libc-2.28.so)
            a041161e77950c5c [unknown] ([unknown])
    ```
    
    With this patch applied, we get a bit further in unwinding:
    
    ```
    cpp-locking 20038 [005] 54830.236589: sched:sched_switch: prev_comm=cpp-locking prev_pid=20038 prev_prio=120 prev_state=T ==> next_comm=swapper/5 next_pid=0 next_prio=120
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb166fec5 __sched_text_start+0x545 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1670208 schedule+0x28 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb16737cc rwsem_down_read_failed+0xec (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1665e04 call_rwsem_down_read_failed+0x14 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb1672a03 down_read+0x13 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb106bd85 __do_page_fault+0x445 (/lib/modules/4.14.78-1-lts/build/vmlinux)
            ffffffffb18015f5 page_fault+0x45 (/lib/modules/4.14.78-1-lts/build/vmlinux)
                7f38e4252591 new_heap+0x101 (/usr/lib/libc-2.28.so)
                7f38e4252d0b arena_get2.part.4+0x2fb (/usr/lib/libc-2.28.so)
                7f38e4255b1c tcache_init.part.6+0xec (/usr/lib/libc-2.28.so)
                7f38e42569e5 __GI___libc_malloc+0x115 (inlined)
                7f38e4241790 __GI__IO_file_doallocate+0x90 (inlined)
                7f38e424fbbf __GI__IO_doallocbuf+0x4f (inlined)
                7f38e424ee47 __GI__IO_file_overflow+0x197 (inlined)
                7f38e424df36 _IO_new_file_xsputn+0x116 (inlined)
                7f38e4242bfb __GI__IO_fwrite+0xdb (inlined)
                7f38e463fa6d std::basic_streambuf<char, std::char_traits<char> >::sputn(char const*, long)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> >::_M_put(char const*, long)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> > std::__write<char>(std::ostreambuf_iterator<char, std::char_traits<char> >, char const*, int)+0x1cd (inlined)
                7f38e463fa6d std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_float<double>(std::ostreambuf_iterator<c>
                7f38e464bd70 std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, double) const+0x90 (inl>
                7f38e464bd70 std::ostream& std::ostream::_M_insert<double>(double)+0x90 (/usr/lib/libstdc++.so.6.0.25)
                563b9cb502f7 std::ostream::operator<<(double)+0xb7 (inlined)
                563b9cb502f7 worker()+0xb7 (/ssd/milian/projects/kdab/rnd/hotspot/build/tests/test-clients/cpp-locking/cpp-locking)
            6eab825c1ee3e4ff [unknown] ([unknown])
    ```
    
    Note that the backtrace is still stopping too early, when compared to
    the nice results obtained via libunwind. It's unclear so far what the
    reason for that is.
    
    Committer note:
    
    Further comment by Milian on the thread started on the Link: tag below:
    
     ---
    The remaining issue is due to a bug in elfutils:
    
    https://sourceware.org/ml/elfutils-devel/2018-q4/msg00089.html
    
    With both patches applied, libunwind and elfutils produce the same output for
    the above scenario.
     ---
    
    Signed-off-by: Milian Wolff <milian.wolff@kdab.com>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Link: http://lkml.kernel.org/r/20181029141644.3907-1-milian.wolff@kdab.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0ebdf0080949db2b9ddd02ee8c969954736c9f86
Author: Martin Vuille <jpmv27@aim.com>
Date:   Sun Feb 11 16:24:20 2018 -0500

    perf unwind: Unwind with libdw doesn't take symfs into account
    
    [ Upstream commit 3d20c6246690219881786de10d2dda93f616d0ac ]
    
    Path passed to libdw for unwinding doesn't include symfs path
    if specified, so unwinding fails because ELF file is not found.
    
    Similar to unwinding with libunwind, pass symsrc_filename instead
    of long_name. If there is no symsrc_filename, fallback to long_name.
    
    Signed-off-by: Martin Vuille <jpmv27@aim.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/r/20180211212420.18388-1-jpmv27@aim.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3a1dab76b8496473fad3bce70fe526f699e0fb95
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Tue Jan 8 22:55:01 2019 -0500

    vt: invoke notifier on screen size change
    
    commit 0c9b1965faddad7534b6974b5b36c4ad37998f8e upstream.
    
    User space using poll() on /dev/vcs devices are not awaken when a
    screen size change occurs. Let's fix that.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c84fb9ca5f7bc2f1c9934508f6321248317ec154
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Sun Jan 13 19:31:43 2019 +0100

    can: bcm: check timer values before ktime conversion
    
    commit 93171ba6f1deffd82f381d36cb13177872d023f6 upstream.
    
    Kyungtae Kim detected a potential integer overflow in bcm_[rx|tx]_setup()
    when the conversion into ktime multiplies the given value with NSEC_PER_USEC
    (1000).
    
    Reference: https://marc.info/?l=linux-can&m=154732118819828&w=2
    
    Add a check for the given tv_usec, so that the value stays below one second.
    Additionally limit the tv_sec value to a reasonable value for CAN related
    use-cases of 400 days and ensure all values to be positive.
    
    Reported-by: Kyungtae Kim <kt0755@gmail.com>
    Tested-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Cc: linux-stable <stable@vger.kernel.org> # versions 2.6.26 to 4.7
    Tested-by: Kyungtae Kim <kt0755@gmail.com>
    Acked-by: Andre Naujoks <nautsch2@gmail.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3670c9c5ca572288de121ba5096bf651d558ae8b
Author: Manfred Schlaegl <manfred.schlaegl@ginzinger.com>
Date:   Wed Dec 19 19:39:58 2018 +0100

    can: dev: __can_get_echo_skb(): fix bogous check for non-existing skb by removing it
    
    commit 7b12c8189a3dc50638e7d53714c88007268d47ef upstream.
    
    This patch revert commit 7da11ba5c506
    ("can: dev: __can_get_echo_skb(): print error message, if trying to echo non existing skb")
    
    After introduction of this change we encountered following new error
    message on various i.MX plattforms (flexcan):
    
    | flexcan 53fc8000.can can0: __can_get_echo_skb: BUG! Trying to echo non
    | existing skb: can_priv::echo_skb[0]
    
    The introduction of the message was a mistake because
    priv->echo_skb[idx] = NULL is a perfectly valid in following case: If
    CAN_RAW_LOOPBACK is disabled (setsockopt) in applications, the pkt_type
    of the tx skb's given to can_put_echo_skb is set to PACKET_LOOPBACK. In
    this case can_put_echo_skb will not set priv->echo_skb[idx]. It is
    therefore kept NULL.
    
    As additional argument for revert: The order of check and usage of idx
    was changed. idx is used to access an array element before checking it's
    boundaries.
    
    Signed-off-by: Manfred Schlaegl <manfred.schlaegl@ginzinger.com>
    Fixes: 7da11ba5c506 ("can: dev: __can_get_echo_skb(): print error message, if trying to echo non existing skb")
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 444fc5b3c8040ec3b50b8df83f73184b6496d5e7
Author: Daniel Drake <drake@endlessm.com>
Date:   Mon Jan 7 11:40:24 2019 +0800

    x86/kaslr: Fix incorrect i8254 outb() parameters
    
    commit 7e6fc2f50a3197d0e82d1c0e86282976c9e6c8a4 upstream.
    
    The outb() function takes parameters value and port, in that order.  Fix
    the parameters used in the kalsr i8254 fallback code.
    
    Fixes: 5bfce5ef55cb ("x86, kaslr: Provide randomness functions")
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: bp@alien8.de
    Cc: hpa@zytor.com
    Cc: linux@endlessm.com
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190107034024.15005-1-drake@endlessm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bed3eafc0d600d0efd71db8c13d20ac4292c6f16
Author: Tom Panfil <tom@steelseries.com>
Date:   Fri Jan 11 17:49:40 2019 -0800

    Input: xpad - add support for SteelSeries Stratus Duo
    
    commit fe2bfd0d40c935763812973ce15f5764f1c12833 upstream.
    
    Add support for the SteelSeries Stratus Duo, a wireless Xbox 360
    controller. The Stratus Duo ships with a USB dongle to enable wireless
    connectivity, but it can also function as a wired controller by connecting
    it directly to a PC via USB, hence the need for two USD PIDs. 0x1430 is the
    dongle, and 0x1431 is the controller.
    
    Signed-off-by: Tom Panfil <tom@steelseries.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e2a07b39388ff5852fc85c3306dff9aa195648a8
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Thu Jan 17 08:21:24 2019 -0800

    CIFS: Fix possible hang during async MTU reads and writes
    
    commit acc58d0bab55a50e02c25f00bd6a210ee121595f upstream.
    
    When doing MTU i/o we need to leave some credits for
    possible reopen requests and other operations happening
    in parallel. Currently we leave 1 credit which is not
    enough even for reopen only: we need at least 2 credits
    if durable handle reconnect fails. Also there may be
    other operations at the same time including compounding
    ones which require 3 credits at a time each. Fix this
    by leaving 8 credits which is big enough to cover most
    scenarios.
    
    Was able to reproduce this when server was configured
    to give out fewer credits than usual.
    
    The proper fix would be to reconnect a file handle first
    and then obtain credits for an MTU request but this leads
    to bigger code changes and should happen in other patches.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 19a17b01d7e0ba83615b5bddb12bc12da05dd311
Author: Paul Fulghum <paulkf@microgate.com>
Date:   Tue Jan 1 12:28:53 2019 -0800

    tty/n_hdlc: fix __might_sleep warning
    
    commit fc01d8c61ce02c034e67378cd3e645734bc18c8c upstream.
    
    Fix __might_sleep warning[1] in tty/n_hdlc.c read due to copy_to_user
    call while current is TASK_INTERRUPTIBLE.  This is a false positive
    since the code path does not depend on current state remaining
    TASK_INTERRUPTIBLE.  The loop breaks out and sets TASK_RUNNING after
    calling copy_to_user.
    
    This patch supresses the warning by setting TASK_RUNNING before calling
    copy_to_user.
    
    [1] https://syzkaller.appspot.com/bug?id=17d5de7f1fcab794cb8c40032f893f52de899324
    
    Signed-off-by: Paul Fulghum <paulkf@microgate.com>
    Reported-by: syzbot <syzbot+c244af085a0159d22879@syzkaller.appspotmail.com>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ccf4ecf43373d5e56943cbc3cf725bd02036b4da
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Jan 20 10:46:58 2019 +0100

    tty: Handle problem if line discipline does not have receive_buf
    
    commit 27cfb3a53be46a54ec5e0bd04e51995b74c90343 upstream.
    
    Some tty line disciplines do not have a receive buf callback, so
    properly check for that before calling it.  If they do not have this
    callback, just eat the character quietly, as we can't fail this call.
    
    Reported-by: Jann Horn <jannh@google.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bf9702a73e24e99050f5428059b7255043f51086
Author: Michael Straube <straube.linux@gmail.com>
Date:   Mon Jan 7 18:28:58 2019 +0100

    staging: rtl8188eu: Add device code for D-Link DWA-121 rev B1
    
    commit 5f74a8cbb38d10615ed46bc3e37d9a4c9af8045a upstream.
    
    This device was added to the stand-alone driver on github.
    Add it to the staging driver as well.
    
    Link: https://github.com/lwfinger/rtl8188eu/commit/a0619a07cd1e
    Signed-off-by: Michael Straube <straube.linux@gmail.com>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0c4373e61d68178be9f20cd465e48579b799922a
Author: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Date:   Wed Jan 9 13:00:03 2019 +0100

    s390/smp: fix CPU hotplug deadlock with CPU rescan
    
    commit b7cb707c373094ce4008d4a6ac9b6b366ec52da5 upstream.
    
    smp_rescan_cpus() is called without the device_hotplug_lock, which can lead
    to a dedlock when a new CPU is found and immediately set online by a udev
    rule.
    
    This was observed on an older kernel version, where the cpu_hotplug_begin()
    loop was still present, and it resulted in hanging chcpu and systemd-udev
    processes. This specific deadlock will not show on current kernels. However,
    there may be other possible deadlocks, and since smp_rescan_cpus() can still
    trigger a CPU hotplug operation, the device_hotplug_lock should be held.
    
    For reference, this was the deadlock with the old cpu_hotplug_begin() loop:
    
            chcpu (rescan)                       systemd-udevd
    
     echo 1 > /sys/../rescan
     -> smp_rescan_cpus()
     -> (*) get_online_cpus()
        (increases refcount)
     -> smp_add_present_cpu()
        (new CPU found)
     -> register_cpu()
     -> device_add()
     -> udev "add" event triggered -----------> udev rule sets CPU online
                                             -> echo 1 > /sys/.../online
                                             -> lock_device_hotplug_sysfs()
                                                (this is missing in rescan path)
                                             -> device_online()
                                             -> (**) device_lock(new CPU dev)
                                             -> cpu_up()
                                             -> cpu_hotplug_begin()
                                                (loops until refcount == 0)
                                                -> deadlock with (*)
     -> bus_probe_device()
     -> device_attach()
     -> device_lock(new CPU dev)
        -> deadlock with (**)
    
    Fix this by taking the device_hotplug_lock in the CPU rescan path.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 345304901febcb896591b41f2fbc6c45752d1f46
Author: Charles Yeh <charlesyeh522@gmail.com>
Date:   Tue Jan 15 23:13:56 2019 +0800

    USB: serial: pl2303: add new PID to support PL2303TB
    
    commit 4dcf9ddc9ad5ab649abafa98c5a4d54b1a33dabb upstream.
    
    Add new PID to support PL2303TB (TYPE_HX)
    
    Signed-off-by: Charles Yeh <charlesyeh522@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 09a42430830e92ee301d702110a7c9853037b9fc
Author: Max Schulze <max.schulze@posteo.de>
Date:   Mon Jan 7 08:31:49 2019 +0100

    USB: serial: simple: add Motorola Tetra TPG2200 device id
    
    commit b81c2c33eab79dfd3650293b2227ee5c6036585c upstream.
    
    Add new Motorola Tetra device id for Motorola Solutions TETRA PEI device
    
    T:  Bus=02 Lev=01 Prnt=01 Port=01 Cnt=01 Dev#=  4 Spd=480 MxCh= 0
    D:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1
    P:  Vendor=0cad ProdID=9016 Rev=24.16
    S:  Manufacturer=Motorola Solutions, Inc.
    S:  Product=TETRA PEI interface
    C:  #Ifs= 2 Cfg#= 1 Atr=80 MxPwr=500mA
    I:  If#= 0 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=00 Prot=00 Driver=usb_serial_simple
    I:  If#= 1 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=00 Prot=00 Driver=usb_serial_simple
    
    Signed-off-by: Max Schulze <max.schulze@posteo.de>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit af9ab785576527aa4fbcfef6f33846068755cabd
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 14 09:16:56 2019 +0000

    openvswitch: Avoid OOB read when parsing flow nlattrs
    
    [ Upstream commit 04a4af334b971814eedf4e4a413343ad3287d9a9 ]
    
    For nested and variable attributes, the expected length of an attribute
    is not known and marked by a negative number.  This results in an OOB
    read when the expected length is later used to check if the attribute is
    all zeros. Fix this by using the actual length of the attribute rather
    than the expected length.
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Acked-by: Pravin B Shelar <pshelar@ovn.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
