commit 94cb1fed447ac8d328a8b50f9583df4ce70793e2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 4 12:22:17 2021 +0200

    Linux 4.14.242
    
    Link: https://lore.kernel.org/r/20210802134334.835358048@linuxfoundation.org
    Tested-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Hulk Robot <hulkrobot@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c925d063b187c02e3f9a6003f0255b3f696858e4
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Jul 30 18:26:22 2021 -0300

    Revert "perf map: Fix dso->nsinfo refcounting"
    
    commit 9bac1bd6e6d36459087a728a968e79e37ebcea1a upstream.
    
    This makes 'perf top' abort in some cases, and the right fix will
    involve surgery that is too much to do at this stage, so revert for now
    and fix it in the next merge window.
    
    This reverts commit 2d6b74baa7147251c30a46c4996e8cc224aa2dc5.
    
    Cc: Riccardo Mancini <rickyman7@gmail.com>
    Cc: Ian Rogers <irogers@google.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Krister Johansen <kjlx@templeofstupid.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit af3493a59fd8e493fa97ef42bb52b5017603de65
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jul 29 17:12:46 2021 +0300

    can: hi311x: fix a signedness bug in hi3110_cmd()
    
    [ Upstream commit f6b3c7848e66e9046c8a79a5b88fd03461cc252b ]
    
    The hi3110_cmd() is supposed to return zero on success and negative
    error codes on failure, but it was accidentally declared as a u8 when
    it needs to be an int type.
    
    Fixes: 57e83fb9b746 ("can: hi311x: Add Holt HI-311x CAN driver")
    Link: https://lore.kernel.org/r/20210729141246.GA1267@kili
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6846170b0be30257c75901aeb7664cc1fc4477d2
Author: Wang Hai <wanghai38@huawei.com>
Date:   Wed Jul 28 20:11:07 2021 +0800

    sis900: Fix missing pci_disable_device() in probe and remove
    
    [ Upstream commit 89fb62fde3b226f99b7015280cf132e2a7438edf ]
    
    Replace pci_enable_device() with pcim_enable_device(),
    pci_disable_device() and pci_release_regions() will be
    called in release automatically.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Wang Hai <wanghai38@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b5c7e5b95afb908d1c23ebb55709bc03c47d171f
Author: Wang Hai <wanghai38@huawei.com>
Date:   Wed Jul 28 15:43:13 2021 +0800

    tulip: windbond-840: Fix missing pci_disable_device() in probe and remove
    
    [ Upstream commit 76a16be07b209a3f507c72abe823bd3af1c8661a ]
    
    Replace pci_enable_device() with pcim_enable_device(),
    pci_disable_device() and pci_release_regions() will be
    called in release automatically.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Wang Hai <wanghai38@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1ad35d7d7fb3d160535b301ba0763e7ea373b062
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Jul 27 23:40:54 2021 -0300

    sctp: fix return value check in __sctp_rcv_asconf_lookup
    
    [ Upstream commit 557fb5862c9272ad9b21407afe1da8acfd9b53eb ]
    
    As Ben Hutchings noticed, this check should have been inverted: the call
    returns true in case of success.
    
    Reported-by: Ben Hutchings <ben@decadent.org.uk>
    Fixes: 0c5dc070ff3d ("sctp: validate from_addr_param return")
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Reviewed-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 766807b77ba14c5dfde8dd1823e637ad9a54b88a
Author: Maor Gottlieb <maorg@nvidia.com>
Date:   Mon Jul 26 09:20:14 2021 +0300

    net/mlx5: Fix flow table chaining
    
    [ Upstream commit 8b54874ef1617185048029a3083d510569e93751 ]
    
    Fix a bug when flow table is created in priority that already
    has other flow tables as shown in the below diagram.
    If the new flow table (FT-B) has the lowest level in the priority,
    we need to connect the flow tables from the previous priority (p0)
    to this new table. In addition when this flow table is destroyed
    (FT-B), we need to connect the flow tables from the previous
    priority (p0) to the next level flow table (FT-C) in the same
    priority of the destroyed table (if exists).
    
                           ---------
                           |root_ns|
                           ---------
                                |
                --------------------------------
                |               |              |
           ----------      ----------      ---------
           |p(prio)-x|     |   p-y  |      |   p-n |
           ----------      ----------      ---------
                |               |
         ----------------  ------------------
         |ns(e.g bypass)|  |ns(e.g. kernel) |
         ----------------  ------------------
                |            |           |
            -------        ------       ----
            |  p0 |        | p1 |       |p2|
            -------        ------       ----
               |             |    \
            --------       ------- ------
            | FT-A |       |FT-B | |FT-C|
            --------       ------- ------
    
    Fixes: f90edfd279f3 ("net/mlx5_core: Connect flow tables")
    Signed-off-by: Maor Gottlieb <maorg@nvidia.com>
    Reviewed-by: Mark Bloch <mbloch@nvidia.com>
    Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f3f6b1ecb11c0b2bba73d90eeae833f120215dc2
Author: Pavel Skripkin <paskripkin@gmail.com>
Date:   Sun Jul 25 00:11:59 2021 +0300

    net: llc: fix skb_over_panic
    
    [ Upstream commit c7c9d2102c9c098916ab9e0ab248006107d00d6c ]
    
    Syzbot reported skb_over_panic() in llc_pdu_init_as_xid_cmd(). The
    problem was in wrong LCC header manipulations.
    
    Syzbot's reproducer tries to send XID packet. llc_ui_sendmsg() is
    doing following steps:
    
            1. skb allocation with size = len + header size
                    len is passed from userpace and header size
                    is 3 since addr->sllc_xid is set.
    
            2. skb_reserve() for header_len = 3
            3. filling all other space with memcpy_from_msg()
    
    Ok, at this moment we have fully loaded skb, only headers needs to be
    filled.
    
    Then code comes to llc_sap_action_send_xid_c(). This function pushes 3
    bytes for LLC PDU header and initializes it. Then comes
    llc_pdu_init_as_xid_cmd(). It initalizes next 3 bytes *AFTER* LLC PDU
    header and call skb_push(skb, 3). This looks wrong for 2 reasons:
    
            1. Bytes rigth after LLC header are user data, so this function
               was overwriting payload.
    
            2. skb_push(skb, 3) call can cause skb_over_panic() since
               all free space was filled in llc_ui_sendmsg(). (This can
               happen is user passed 686 len: 686 + 14 (eth header) + 3 (LLC
               header) = 703. SKB_DATA_ALIGN(703) = 704)
    
    So, in this patch I added 2 new private constansts: LLC_PDU_TYPE_U_XID
    and LLC_PDU_LEN_U_XID. LLC_PDU_LEN_U_XID is used to correctly reserve
    header size to handle LLC + XID case. LLC_PDU_TYPE_U_XID is used by
    llc_pdu_header_init() function to push 6 bytes instead of 3. And finally
    I removed skb_push() call from llc_pdu_init_as_xid_cmd().
    
    This changes should not affect other parts of LLC, since after
    all steps we just transmit buffer.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Reported-and-tested-by: syzbot+5e5a981ad7cc54c4b2b4@syzkaller.appspotmail.com
    Signed-off-by: Pavel Skripkin <paskripkin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3af1c181ee75fc89678cbddc0a925386a56dceed
Author: Jiapeng Chong <jiapeng.chong@linux.alibaba.com>
Date:   Fri Jul 23 18:36:09 2021 +0800

    mlx4: Fix missing error code in mlx4_load_one()
    
    [ Upstream commit 7e4960b3d66d7248b23de3251118147812b42da2 ]
    
    The error code is missing in this code scenario, add the error code
    '-EINVAL' to the return value 'err'.
    
    Eliminate the follow smatch warning:
    
    drivers/net/ethernet/mellanox/mlx4/main.c:3538 mlx4_load_one() warn:
    missing error code 'err'.
    
    Reported-by: Abaci Robot <abaci@linux.alibaba.com>
    Fixes: 7ae0e400cd93 ("net/mlx4_core: Flexible (asymmetric) allocation of EQs and MSI-X vectors for PF/VFs")
    Signed-off-by: Jiapeng Chong <jiapeng.chong@linux.alibaba.com>
    Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cf76aa1aab8089d271ea827995099a914dec7c98
Author: Hoang Le <hoang.h.le@dektech.com.au>
Date:   Fri Jul 23 09:25:34 2021 +0700

    tipc: fix sleeping in tipc accept routine
    
    [ Upstream commit d237a7f11719ff9320721be5818352e48071aab6 ]
    
    The release_sock() is blocking function, it would change the state
    after sleeping. In order to evaluate the stated condition outside
    the socket lock context, switch to use wait_woken() instead.
    
    Fixes: 6398e23cdb1d8 ("tipc: standardize accept routine")
    Acked-by: Jon Maloy <jmaloy@redhat.com>
    Signed-off-by: Hoang Le <hoang.h.le@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 37fb1aa49cfa538ea5a8db660918fea5dd6ca1e2
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Tue Jul 20 18:22:50 2021 +0200

    netfilter: nft_nat: allow to specify layer 4 protocol NAT only
    
    [ Upstream commit a33f387ecd5aafae514095c2c4a8c24f7aea7e8b ]
    
    nft_nat reports a bogus EAFNOSUPPORT if no layer 3 information is specified.
    
    Fixes: d07db9884a5f ("netfilter: nf_tables: introduce nft_validate_register_load()")
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d5103628648e030fa8d5e7f784f771b4159195a8
Author: Florian Westphal <fw@strlen.de>
Date:   Sun Jul 18 18:36:00 2021 +0200

    netfilter: conntrack: adjust stop timestamp to real expiry value
    
    [ Upstream commit 30a56a2b881821625f79837d4d968c679852444e ]
    
    In case the entry is evicted via garbage collection there is
    delay between the timeout value and the eviction event.
    
    This adjusts the stop value based on how much time has passed.
    
    Fixes: b87a2f9199ea82 ("netfilter: conntrack: add gc worker to remove timed-out entries")
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c788a2936aecb87b7085e6826c6024099e27f9c3
Author: Nguyen Dinh Phi <phind.uet@gmail.com>
Date:   Mon Jun 28 21:23:34 2021 +0800

    cfg80211: Fix possible memory leak in function cfg80211_bss_update
    
    commit f9a5c358c8d26fed0cc45f2afc64633d4ba21dff upstream.
    
    When we exceed the limit of BSS entries, this function will free the
    new entry, however, at this time, it is the last door to access the
    inputed ies, so these ies will be unreferenced objects and cause memory
    leak.
    Therefore we should free its ies before deallocating the new entry, beside
    of dropping it from hidden_list.
    
    Signed-off-by: Nguyen Dinh Phi <phind.uet@gmail.com>
    Link: https://lore.kernel.org/r/20210628132334.851095-1-phind.uet@gmail.com
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f51e5229c24b016567d829455d4762a5fb645a9f
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Sun Apr 11 10:12:16 2021 +0200

    x86/asm: Ensure asm/proto.h can be included stand-alone
    
    [ Upstream commit f7b21a0e41171d22296b897dac6e4c41d2a3643c ]
    
    Fix:
    
      ../arch/x86/include/asm/proto.h:14:30: warning: ‘struct task_struct’ declared \
        inside parameter list will not be visible outside of this definition or declaration
      long do_arch_prctl_64(struct task_struct *task, int option, unsigned long arg2);
                                   ^~~~~~~~~~~
    
      .../arch/x86/include/asm/proto.h:40:34: warning: ‘struct task_struct’ declared \
        inside parameter list will not be visible outside of this definition or declaration
       long do_arch_prctl_common(struct task_struct *task, int option,
                                        ^~~~~~~~~~~
    
    if linux/sched.h hasn't be included previously. This fixes a build error
    when this header is used outside of the kernel tree.
    
     [ bp: Massage commit message. ]
    
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: https://lkml.kernel.org/r/b76b4be3-cf66-f6b2-9a6c-3e7ef54f9845@web.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 546b6dcf837f5ad0a34ac5be5249aa1bb4855d00
Author: Krzysztof Kozlowski <krzysztof.kozlowski@canonical.com>
Date:   Wed Jul 28 08:49:09 2021 +0200

    nfc: nfcsim: fix use after free during module unload
    
    commit 5e7b30d24a5b8cb691c173b45b50e3ca0191be19 upstream.
    
    There is a use after free memory corruption during module exit:
     - nfcsim_exit()
      - nfcsim_device_free(dev0)
        - nfc_digital_unregister_device()
          This iterates over command queue and frees all commands,
        - dev->up = false
        - nfcsim_link_shutdown()
          - nfcsim_link_recv_wake()
            This wakes the sleeping thread nfcsim_link_recv_skb().
    
     - nfcsim_link_recv_skb()
       Wake from wait_event_interruptible_timeout(),
       call directly the deb->cb callback even though (dev->up == false),
       - digital_send_cmd_complete()
         Dereference of "struct digital_cmd" cmd which was freed earlier by
         nfc_digital_unregister_device().
    
    This causes memory corruption shortly after (with unrelated stack
    trace):
    
      nfc nfc0: NFC: nfcsim_recv_wq: Device is down
      llcp: nfc_llcp_recv: err -19
      nfc nfc1: NFC: nfcsim_recv_wq: Device is down
      BUG: unable to handle page fault for address: ffffffffffffffed
      Call Trace:
       fsnotify+0x54b/0x5c0
       __fsnotify_parent+0x1fe/0x300
       ? vfs_write+0x27c/0x390
       vfs_write+0x27c/0x390
       ksys_write+0x63/0xe0
       do_syscall_64+0x3b/0x90
       entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    KASAN report:
    
      BUG: KASAN: use-after-free in digital_send_cmd_complete+0x16/0x50
      Write of size 8 at addr ffff88800a05f720 by task kworker/0:2/71
      Workqueue: events nfcsim_recv_wq [nfcsim]
      Call Trace:
       dump_stack_lvl+0x45/0x59
       print_address_description.constprop.0+0x21/0x140
       ? digital_send_cmd_complete+0x16/0x50
       ? digital_send_cmd_complete+0x16/0x50
       kasan_report.cold+0x7f/0x11b
       ? digital_send_cmd_complete+0x16/0x50
       ? digital_dep_link_down+0x60/0x60
       digital_send_cmd_complete+0x16/0x50
       nfcsim_recv_wq+0x38f/0x3d5 [nfcsim]
       ? nfcsim_in_send_cmd+0x4a/0x4a [nfcsim]
       ? lock_is_held_type+0x98/0x110
       ? finish_wait+0x110/0x110
       ? rcu_read_lock_sched_held+0x9c/0xd0
       ? rcu_read_lock_bh_held+0xb0/0xb0
       ? lockdep_hardirqs_on_prepare+0x12e/0x1f0
    
    This flow of calling digital_send_cmd_complete() callback on driver exit
    is specific to nfcsim which implements reading and sending work queues.
    Since the NFC digital device was unregistered, the callback should not
    be called.
    
    Fixes: 204bddcb508f ("NFC: nfcsim: Make use of the Digital layer")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Krzysztof Kozlowski <krzysztof.kozlowski@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0be68b80c323b6447c6c57a90de5108858bd9555
Author: Paul Jakma <paul@jakma.org>
Date:   Fri Jul 23 16:13:04 2021 +0100

    NIU: fix incorrect error return, missed in previous revert
    
    commit 15bbf8bb4d4ab87108ecf5f4155ec8ffa3c141d6 upstream.
    
    Commit 7930742d6, reverting 26fd962, missed out on reverting an incorrect
    change to a return value.  The niu_pci_vpd_scan_props(..) == 1 case appears
    to be a normal path - treating it as an error and return -EINVAL was
    breaking VPD_SCAN and causing the driver to fail to load.
    
    Fix, so my Neptune card works again.
    
    Cc: Kangjie Lu <kjlu@umn.edu>
    Cc: Shannon Nelson <shannon.lee.nelson@gmail.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: stable <stable@vger.kernel.org>
    Fixes: 7930742d ('Revert "niu: fix missing checks of niu_pci_eeprom_read"')
    Signed-off-by: Paul Jakma <paul@jakma.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 27be2b5ce9001ebbf5fe9b3843192dc672d15080
Author: Pavel Skripkin <paskripkin@gmail.com>
Date:   Tue Jul 27 20:00:46 2021 +0300

    can: esd_usb2: fix memory leak
    
    commit 928150fad41ba16df7fcc9f7f945747d0f56cbb6 upstream.
    
    In esd_usb2_setup_rx_urbs() MAX_RX_URBS coherent buffers are allocated
    and there is nothing, that frees them:
    
    1) In callback function the urb is resubmitted and that's all
    2) In disconnect function urbs are simply killed, but URB_FREE_BUFFER
       is not set (see esd_usb2_setup_rx_urbs) and this flag cannot be used
       with coherent buffers.
    
    So, all allocated buffers should be freed with usb_free_coherent()
    explicitly.
    
    Side note: This code looks like a copy-paste of other can drivers. The
    same patch was applied to mcba_usb driver and it works nice with real
    hardware. There is no change in functionality, only clean-up code for
    coherent buffers.
    
    Fixes: 96d8e90382dc ("can: Add driver for esd CAN-USB/2 device")
    Link: https://lore.kernel.org/r/b31b096926dcb35998ad0271aac4b51770ca7cc8.1627404470.git.paskripkin@gmail.com
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Pavel Skripkin <paskripkin@gmail.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ad3f58662e82894a144e5c43a029b39e1322e785
Author: Pavel Skripkin <paskripkin@gmail.com>
Date:   Tue Jul 27 20:00:33 2021 +0300

    can: ems_usb: fix memory leak
    
    commit 9969e3c5f40c166e3396acc36c34f9de502929f6 upstream.
    
    In ems_usb_start() MAX_RX_URBS coherent buffers are allocated and
    there is nothing, that frees them:
    
    1) In callback function the urb is resubmitted and that's all
    2) In disconnect function urbs are simply killed, but URB_FREE_BUFFER
       is not set (see ems_usb_start) and this flag cannot be used with
       coherent buffers.
    
    So, all allocated buffers should be freed with usb_free_coherent()
    explicitly.
    
    Side note: This code looks like a copy-paste of other can drivers. The
    same patch was applied to mcba_usb driver and it works nice with real
    hardware. There is no change in functionality, only clean-up code for
    coherent buffers.
    
    Fixes: 702171adeed3 ("ems_usb: Added support for EMS CPC-USB/ARM7 CAN/USB interface")
    Link: https://lore.kernel.org/r/59aa9fbc9a8cbf9af2bbd2f61a659c480b415800.1627404470.git.paskripkin@gmail.com
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Pavel Skripkin <paskripkin@gmail.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 94344109266efd6fffaae3afcdd882602407afec
Author: Pavel Skripkin <paskripkin@gmail.com>
Date:   Tue Jul 27 19:59:57 2021 +0300

    can: usb_8dev: fix memory leak
    
    commit 0e865f0c31928d6a313269ef624907eec55287c4 upstream.
    
    In usb_8dev_start() MAX_RX_URBS coherent buffers are allocated and
    there is nothing, that frees them:
    
    1) In callback function the urb is resubmitted and that's all
    2) In disconnect function urbs are simply killed, but URB_FREE_BUFFER
       is not set (see usb_8dev_start) and this flag cannot be used with
       coherent buffers.
    
    So, all allocated buffers should be freed with usb_free_coherent()
    explicitly.
    
    Side note: This code looks like a copy-paste of other can drivers. The
    same patch was applied to mcba_usb driver and it works nice with real
    hardware. There is no change in functionality, only clean-up code for
    coherent buffers.
    
    Fixes: 0024d8ad1639 ("can: usb_8dev: Add support for USB2CAN interface from 8 devices")
    Link: https://lore.kernel.org/r/d39b458cd425a1cf7f512f340224e6e9563b07bd.1627404470.git.paskripkin@gmail.com
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Pavel Skripkin <paskripkin@gmail.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8c85c006a2bbf68ad300ce6f1ce468f3b6c97afa
Author: Pavel Skripkin <paskripkin@gmail.com>
Date:   Sun Jul 25 13:36:30 2021 +0300

    can: mcba_usb_start(): add missing urb->transfer_dma initialization
    
    commit fc43fb69a7af92839551f99c1a96a37b77b3ae7a upstream.
    
    Yasushi reported, that his Microchip CAN Analyzer stopped working
    since commit 91c02557174b ("can: mcba_usb: fix memory leak in
    mcba_usb"). The problem was in missing urb->transfer_dma
    initialization.
    
    In my previous patch to this driver I refactored mcba_usb_start() code
    to avoid leaking usb coherent buffers. To archive it, I passed local
    stack variable to usb_alloc_coherent() and then saved it to private
    array to correctly free all coherent buffers on ->close() call. But I
    forgot to initialize urb->transfer_dma with variable passed to
    usb_alloc_coherent().
    
    All of this was causing device to not work, since dma addr 0 is not
    valid and following log can be found on bug report page, which points
    exactly to problem described above.
    
    | DMAR: [DMA Write] Request device [00:14.0] PASID ffffffff fault addr 0 [fault reason 05] PTE Write access is not set
    
    Fixes: 91c02557174b ("can: mcba_usb: fix memory leak in mcba_usb")
    Link: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=990850
    Link: https://lore.kernel.org/r/20210725103630.23864-1-paskripkin@gmail.com
    Cc: linux-stable <stable@vger.kernel.org>
    Reported-by: Yasushi SHOJI <yasushi.shoji@gmail.com>
    Signed-off-by: Pavel Skripkin <paskripkin@gmail.com>
    Tested-by: Yasushi SHOJI <yashi@spacecubics.com>
    [mkl: fixed typos in commit message - thanks Yasushi SHOJI]
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 919c9a0b3cbbb4b67fce7c066c8278db67349bc4
Author: Ziyang Xuan <william.xuanziyang@huawei.com>
Date:   Thu Jul 22 15:08:19 2021 +0800

    can: raw: raw_setsockopt(): fix raw_rcv panic for sock UAF
    
    commit 54f93336d000229f72c26d8a3f69dd256b744528 upstream.
    
    We get a bug during ltp can_filter test as following.
    
    ===========================================
    [60919.264984] BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
    [60919.265223] PGD 8000003dda726067 P4D 8000003dda726067 PUD 3dda727067 PMD 0
    [60919.265443] Oops: 0000 [#1] SMP PTI
    [60919.265550] CPU: 30 PID: 3638365 Comm: can_filter Kdump: loaded Tainted: G        W         4.19.90+ #1
    [60919.266068] RIP: 0010:selinux_socket_sock_rcv_skb+0x3e/0x200
    [60919.293289] RSP: 0018:ffff8d53bfc03cf8 EFLAGS: 00010246
    [60919.307140] RAX: 0000000000000000 RBX: 000000000000001d RCX: 0000000000000007
    [60919.320756] RDX: 0000000000000001 RSI: ffff8d5104a8ed00 RDI: ffff8d53bfc03d30
    [60919.334319] RBP: ffff8d9338056800 R08: ffff8d53bfc29d80 R09: 0000000000000001
    [60919.347969] R10: ffff8d53bfc03ec0 R11: ffffb8526ef47c98 R12: ffff8d53bfc03d30
    [60919.350320] perf: interrupt took too long (3063 > 2500), lowering kernel.perf_event_max_sample_rate to 65000
    [60919.361148] R13: 0000000000000001 R14: ffff8d53bcf90000 R15: 0000000000000000
    [60919.361151] FS:  00007fb78b6b3600(0000) GS:ffff8d53bfc00000(0000) knlGS:0000000000000000
    [60919.400812] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [60919.413730] CR2: 0000000000000010 CR3: 0000003e3f784006 CR4: 00000000007606e0
    [60919.426479] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [60919.439339] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [60919.451608] PKRU: 55555554
    [60919.463622] Call Trace:
    [60919.475617]  <IRQ>
    [60919.487122]  ? update_load_avg+0x89/0x5d0
    [60919.498478]  ? update_load_avg+0x89/0x5d0
    [60919.509822]  ? account_entity_enqueue+0xc5/0xf0
    [60919.520709]  security_sock_rcv_skb+0x2a/0x40
    [60919.531413]  sk_filter_trim_cap+0x47/0x1b0
    [60919.542178]  ? kmem_cache_alloc+0x38/0x1b0
    [60919.552444]  sock_queue_rcv_skb+0x17/0x30
    [60919.562477]  raw_rcv+0x110/0x190 [can_raw]
    [60919.572539]  can_rcv_filter+0xbc/0x1b0 [can]
    [60919.582173]  can_receive+0x6b/0xb0 [can]
    [60919.591595]  can_rcv+0x31/0x70 [can]
    [60919.600783]  __netif_receive_skb_one_core+0x5a/0x80
    [60919.609864]  process_backlog+0x9b/0x150
    [60919.618691]  net_rx_action+0x156/0x400
    [60919.627310]  ? sched_clock_cpu+0xc/0xa0
    [60919.635714]  __do_softirq+0xe8/0x2e9
    [60919.644161]  do_softirq_own_stack+0x2a/0x40
    [60919.652154]  </IRQ>
    [60919.659899]  do_softirq.part.17+0x4f/0x60
    [60919.667475]  __local_bh_enable_ip+0x60/0x70
    [60919.675089]  __dev_queue_xmit+0x539/0x920
    [60919.682267]  ? finish_wait+0x80/0x80
    [60919.689218]  ? finish_wait+0x80/0x80
    [60919.695886]  ? sock_alloc_send_pskb+0x211/0x230
    [60919.702395]  ? can_send+0xe5/0x1f0 [can]
    [60919.708882]  can_send+0xe5/0x1f0 [can]
    [60919.715037]  raw_sendmsg+0x16d/0x268 [can_raw]
    
    It's because raw_setsockopt() concurrently with
    unregister_netdevice_many(). Concurrent scenario as following.
    
            cpu0                                            cpu1
    raw_bind
    raw_setsockopt                                  unregister_netdevice_many
                                                    unlist_netdevice
    dev_get_by_index                                raw_notifier
    raw_enable_filters                              ......
    can_rx_register
    can_rcv_list_find(..., net->can.rx_alldev_list)
    
    ......
    
    sock_close
    raw_release(sock_a)
    
    ......
    
    can_receive
    can_rcv_filter(net->can.rx_alldev_list, ...)
    raw_rcv(skb, sock_a)
    BUG
    
    After unlist_netdevice(), dev_get_by_index() return NULL in
    raw_setsockopt(). Function raw_enable_filters() will add sock
    and can_filter to net->can.rx_alldev_list. Then the sock is closed.
    Followed by, we sock_sendmsg() to a new vcan device use the same
    can_filter. Protocol stack match the old receiver whose sock has
    been released on net->can.rx_alldev_list in can_rcv_filter().
    Function raw_rcv() uses the freed sock. UAF BUG is triggered.
    
    We can find that the key issue is that net_device has not been
    protected in raw_setsockopt(). Use rtnl_lock to protect net_device
    in raw_setsockopt().
    
    Fixes: c18ce101f2e4 ("[CAN]: Add raw protocol")
    Link: https://lore.kernel.org/r/20210722070819.1048263-1-william.xuanziyang@huawei.com
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Ziyang Xuan <william.xuanziyang@huawei.com>
    Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bed629679a3c3fb75fca40ca33c07fee72c98550
Author: Junxiao Bi <junxiao.bi@oracle.com>
Date:   Thu Jul 29 14:53:41 2021 -0700

    ocfs2: issue zeroout to EOF blocks
    
    commit 9449ad33be8480f538b11a593e2dda2fb33ca06d upstream.
    
    For punch holes in EOF blocks, fallocate used buffer write to zero the
    EOF blocks in last cluster.  But since ->writepage will ignore EOF
    pages, those zeros will not be flushed.
    
    This "looks" ok as commit 6bba4471f0cc ("ocfs2: fix data corruption by
    fallocate") will zero the EOF blocks when extend the file size, but it
    isn't.  The problem happened on those EOF pages, before writeback, those
    pages had DIRTY flag set and all buffer_head in them also had DIRTY flag
    set, when writeback run by write_cache_pages(), DIRTY flag on the page
    was cleared, but DIRTY flag on the buffer_head not.
    
    When next write happened to those EOF pages, since buffer_head already
    had DIRTY flag set, it would not mark page DIRTY again.  That made
    writeback ignore them forever.  That will cause data corruption.  Even
    directio write can't work because it will fail when trying to drop pages
    caches before direct io, as it found the buffer_head for those pages
    still had DIRTY flag set, then it will fall back to buffer io mode.
    
    To make a summary of the issue, as writeback ingores EOF pages, once any
    EOF page is generated, any write to it will only go to the page cache,
    it will never be flushed to disk even file size extends and that page is
    not EOF page any more.  The fix is to avoid zero EOF blocks with buffer
    write.
    
    The following code snippet from qemu-img could trigger the corruption.
    
      656   open("6b3711ae-3306-4bdd-823c-cf1c0060a095.conv.2", O_RDWR|O_DIRECT|O_CLOEXEC) = 11
      ...
      660   fallocate(11, FALLOC_FL_KEEP_SIZE|FALLOC_FL_PUNCH_HOLE, 2275868672, 327680 <unfinished ...>
      660   fallocate(11, 0, 2275868672, 327680) = 0
      658   pwrite64(11, "
    
    Link: https://lkml.kernel.org/r/20210722054923.24389-2-junxiao.bi@oracle.com
    Signed-off-by: Junxiao Bi <junxiao.bi@oracle.com>
    Reviewed-by: Joseph Qi <joseph.qi@linux.alibaba.com>
    Cc: Mark Fasheh <mark@fasheh.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Changwei Ge <gechangwei@live.cn>
    Cc: Gang He <ghe@suse.com>
    Cc: Jun Piao <piaojun@huawei.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 97bb422f071e573677218966affdf6c3a115fc6e
Author: Junxiao Bi <junxiao.bi@oracle.com>
Date:   Thu Jul 29 14:53:38 2021 -0700

    ocfs2: fix zero out valid data
    
    commit f267aeb6dea5e468793e5b8eb6a9c72c0020d418 upstream.
    
    If append-dio feature is enabled, direct-io write and fallocate could
    run in parallel to extend file size, fallocate used "orig_isize" to
    record i_size before taking "ip_alloc_sem", when
    ocfs2_zeroout_partial_cluster() zeroout EOF blocks, i_size maybe already
    extended by ocfs2_dio_end_io_write(), that will cause valid data zeroed
    out.
    
    Link: https://lkml.kernel.org/r/20210722054923.24389-1-junxiao.bi@oracle.com
    Fixes: 6bba4471f0cc ("ocfs2: fix data corruption by fallocate")
    Signed-off-by: Junxiao Bi <junxiao.bi@oracle.com>
    Reviewed-by: Joseph Qi <joseph.qi@linux.alibaba.com>
    Cc: Changwei Ge <gechangwei@live.cn>
    Cc: Gang He <ghe@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Jun Piao <piaojun@huawei.com>
    Cc: Mark Fasheh <mark@fasheh.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5e6cfccad137cf184e78689fbe414d09db062618
Author: Juergen Gross <jgross@suse.com>
Date:   Thu Jul 1 17:41:00 2021 +0200

    x86/kvm: fix vcpu-id indexed array sizes
    
    commit 76b4f357d0e7d8f6f0013c733e6cba1773c266d3 upstream.
    
    KVM_MAX_VCPU_ID is the maximum vcpu-id of a guest, and not the number
    of vcpu-ids. Fix array indexed by vcpu-id to have KVM_MAX_VCPU_ID+1
    elements.
    
    Note that this is currently no real problem, as KVM_MAX_VCPU_ID is
    an odd number, resulting in always enough padding being available at
    the end of those arrays.
    
    Nevertheless this should be fixed in order to avoid rare problems in
    case someone is using an even number for KVM_MAX_VCPU_ID.
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Message-Id: <20210701154105.23215-2-jgross@suse.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b2ac545efdb8ad273df23be34aa6644067ecd3b6
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Apr 13 05:41:35 2021 -0700

    gro: ensure frag0 meets IP header alignment
    
    commit 38ec4944b593fd90c5ef42aaaa53e66ae5769d04 upstream.
    
    After commit 0f6925b3e8da ("virtio_net: Do not pull payload in skb->head")
    Guenter Roeck reported one failure in his tests using sh architecture.
    
    After much debugging, we have been able to spot silent unaligned accesses
    in inet_gro_receive()
    
    The issue at hand is that upper networking stacks assume their header
    is word-aligned. Low level drivers are supposed to reserve NET_IP_ALIGN
    bytes before the Ethernet header to make that happen.
    
    This patch hardens skb_gro_reset_offset() to not allow frag0 fast-path
    if the fragment is not properly aligned.
    
    Some arches like x86, arm64 and powerpc do not care and define NET_IP_ALIGN
    as 0, this extra check will be a NOP for them.
    
    Note that if frag0 is not used, GRO will call pskb_may_pull()
    as many times as needed to pull network and transport headers.
    
    Fixes: 0f6925b3e8da ("virtio_net: Do not pull payload in skb->head")
    Fixes: 78a478d0efd9 ("gro: Inline skb_gro_header and cache frag0 virtual address")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Xuan Zhuo <xuanzhuo@linux.alibaba.com>
    Cc: "Michael S. Tsirkin" <mst@redhat.com>
    Cc: Jason Wang <jasowang@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Matthieu Baerts <matthieu.baerts@tessares.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2789bc090f4a2caef0cceb3f108867de608bb23a
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Apr 2 06:26:02 2021 -0700

    virtio_net: Do not pull payload in skb->head
    
    commit 0f6925b3e8da0dbbb52447ca8a8b42b371aac7db upstream.
    
    Xuan Zhuo reported that commit 3226b158e67c ("net: avoid 32 x truesize
    under-estimation for tiny skbs") brought  a ~10% performance drop.
    
    The reason for the performance drop was that GRO was forced
    to chain sk_buff (using skb_shinfo(skb)->frag_list), which
    uses more memory but also cause packet consumers to go over
    a lot of overhead handling all the tiny skbs.
    
    It turns out that virtio_net page_to_skb() has a wrong strategy :
    It allocates skbs with GOOD_COPY_LEN (128) bytes in skb->head, then
    copies 128 bytes from the page, before feeding the packet to GRO stack.
    
    This was suboptimal before commit 3226b158e67c ("net: avoid 32 x truesize
    under-estimation for tiny skbs") because GRO was using 2 frags per MSS,
    meaning we were not packing MSS with 100% efficiency.
    
    Fix is to pull only the ethernet header in page_to_skb()
    
    Then, we change virtio_net_hdr_to_skb() to pull the missing
    headers, instead of assuming they were already pulled by callers.
    
    This fixes the performance regression, but could also allow virtio_net
    to accept packets with more than 128bytes of headers.
    
    Many thanks to Xuan Zhuo for his report, and his tests/help.
    
    Fixes: 3226b158e67c ("net: avoid 32 x truesize under-estimation for tiny skbs")
    Reported-by: Xuan Zhuo <xuanzhuo@linux.alibaba.com>
    Link: https://www.spinics.net/lists/netdev/msg731397.html
    Co-Developed-by: Xuan Zhuo <xuanzhuo@linux.alibaba.com>
    Signed-off-by: Xuan Zhuo <xuanzhuo@linux.alibaba.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: "Michael S. Tsirkin" <mst@redhat.com>
    Cc: Jason Wang <jasowang@redhat.com>
    Cc: virtualization@lists.linux-foundation.org
    Acked-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Matthieu Baerts <matthieu.baerts@tessares.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 316f526ab0adf88b704cdd33258df1e48933331a
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu Jul 1 14:21:18 2021 +0100

    ARM: dts: versatile: Fix up interrupt controller node names
    
    [ Upstream commit 82a1c67554dff610d6be4e1982c425717b3c6a23 ]
    
    Once the new schema interrupt-controller/arm,vic.yaml is added, we get
    the below warnings:
    
            arch/arm/boot/dts/versatile-ab.dt.yaml:
            intc@10140000: $nodename:0: 'intc@10140000' does not match
            '^interrupt-controller(@[0-9a-f,]+)*$'
    
            arch/arm/boot/dts/versatile-ab.dt.yaml:
            intc@10140000: 'clear-mask' does not match any of the regexes
    
    Fix the node names for the interrupt controller to conform
    to the standard node name interrupt-controller@.. Also drop invalid
    clear-mask property.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20210701132118.759454-1-sudeep.holla@arm.com'
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b744d40f21bd4565169522be484752cddad8e894
Author: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
Date:   Wed Jul 14 21:27:08 2021 -0700

    hfs: add lock nesting notation to hfs_find_init
    
    [ Upstream commit b3b2177a2d795e35dc11597b2609eb1e7e57e570 ]
    
    Syzbot reports a possible recursive lock in [1].
    
    This happens due to missing lock nesting information.  From the logs, we
    see that a call to hfs_fill_super is made to mount the hfs filesystem.
    While searching for the root inode, the lock on the catalog btree is
    grabbed.  Then, when the parent of the root isn't found, a call to
    __hfs_bnode_create is made to create the parent of the root.  This
    eventually leads to a call to hfs_ext_read_extent which grabs a lock on
    the extents btree.
    
    Since the order of locking is catalog btree -> extents btree, this lock
    hierarchy does not lead to a deadlock.
    
    To tell lockdep that this locking is safe, we add nesting notation to
    distinguish between catalog btrees, extents btrees, and attributes
    btrees (for HFS+).  This has already been done in hfsplus.
    
    Link: https://syzkaller.appspot.com/bug?id=f007ef1d7a31a469e3be7aeb0fde0769b18585db [1]
    Link: https://lkml.kernel.org/r/20210701030756.58760-4-desmondcheongzx@gmail.com
    Signed-off-by: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
    Reported-by: syzbot+b718ec84a87b7e73ade4@syzkaller.appspotmail.com
    Tested-by: syzbot+b718ec84a87b7e73ade4@syzkaller.appspotmail.com
    Reviewed-by: Viacheslav Dubeyko <slava@dubeyko.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Gustavo A. R. Silva <gustavoars@kernel.org>
    Cc: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7aefafe48668176fe9511f3472d491538f1027fb
Author: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
Date:   Wed Jul 14 21:27:05 2021 -0700

    hfs: fix high memory mapping in hfs_bnode_read
    
    [ Upstream commit 54a5ead6f5e2b47131a7385d0c0af18e7b89cb02 ]
    
    Pages that we read in hfs_bnode_read need to be kmapped into kernel
    address space.  However, currently only the 0th page is kmapped.  If the
    given offset + length exceeds this 0th page, then we have an invalid
    memory access.
    
    To fix this, we kmap relevant pages one by one and copy their relevant
    portions of data.
    
    An example of invalid memory access occurring without this fix can be seen
    in the following crash report:
    
      ==================================================================
      BUG: KASAN: use-after-free in memcpy include/linux/fortify-string.h:191 [inline]
      BUG: KASAN: use-after-free in hfs_bnode_read+0xc4/0xe0 fs/hfs/bnode.c:26
      Read of size 2 at addr ffff888125fdcffe by task syz-executor5/4634
    
      CPU: 0 PID: 4634 Comm: syz-executor5 Not tainted 5.13.0-syzkaller #0
      Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
      Call Trace:
       __dump_stack lib/dump_stack.c:79 [inline]
       dump_stack+0x195/0x1f8 lib/dump_stack.c:120
       print_address_description.constprop.0+0x1d/0x110 mm/kasan/report.c:233
       __kasan_report mm/kasan/report.c:419 [inline]
       kasan_report.cold+0x7b/0xd4 mm/kasan/report.c:436
       check_region_inline mm/kasan/generic.c:180 [inline]
       kasan_check_range+0x154/0x1b0 mm/kasan/generic.c:186
       memcpy+0x24/0x60 mm/kasan/shadow.c:65
       memcpy include/linux/fortify-string.h:191 [inline]
       hfs_bnode_read+0xc4/0xe0 fs/hfs/bnode.c:26
       hfs_bnode_read_u16 fs/hfs/bnode.c:34 [inline]
       hfs_bnode_find+0x880/0xcc0 fs/hfs/bnode.c:365
       hfs_brec_find+0x2d8/0x540 fs/hfs/bfind.c:126
       hfs_brec_read+0x27/0x120 fs/hfs/bfind.c:165
       hfs_cat_find_brec+0x19a/0x3b0 fs/hfs/catalog.c:194
       hfs_fill_super+0xc13/0x1460 fs/hfs/super.c:419
       mount_bdev+0x331/0x3f0 fs/super.c:1368
       hfs_mount+0x35/0x40 fs/hfs/super.c:457
       legacy_get_tree+0x10c/0x220 fs/fs_context.c:592
       vfs_get_tree+0x93/0x300 fs/super.c:1498
       do_new_mount fs/namespace.c:2905 [inline]
       path_mount+0x13f5/0x20e0 fs/namespace.c:3235
       do_mount fs/namespace.c:3248 [inline]
       __do_sys_mount fs/namespace.c:3456 [inline]
       __se_sys_mount fs/namespace.c:3433 [inline]
       __x64_sys_mount+0x2b8/0x340 fs/namespace.c:3433
       do_syscall_64+0x37/0xc0 arch/x86/entry/common.c:47
       entry_SYSCALL_64_after_hwframe+0x44/0xae
      RIP: 0033:0x45e63a
      Code: 48 c7 c2 bc ff ff ff f7 d8 64 89 02 b8 ff ff ff ff eb d2 e8 88 04 00 00 0f 1f 84 00 00 00 00 00 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
      RSP: 002b:00007f9404d410d8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a5
      RAX: ffffffffffffffda RBX: 0000000020000248 RCX: 000000000045e63a
      RDX: 0000000020000000 RSI: 0000000020000100 RDI: 00007f9404d41120
      RBP: 00007f9404d41120 R08: 00000000200002c0 R09: 0000000020000000
      R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000003
      R13: 0000000000000003 R14: 00000000004ad5d8 R15: 0000000000000000
    
      The buggy address belongs to the page:
      page:00000000dadbcf3e refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x125fdc
      flags: 0x2fffc0000000000(node=0|zone=2|lastcpupid=0x3fff)
      raw: 02fffc0000000000 ffffea000497f748 ffffea000497f6c8 0000000000000000
      raw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000
      page dumped because: kasan: bad access detected
    
      Memory state around the buggy address:
       ffff888125fdce80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
       ffff888125fdcf00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
      >ffff888125fdcf80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
                                                                      ^
       ffff888125fdd000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
       ffff888125fdd080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
      ==================================================================
    
    Link: https://lkml.kernel.org/r/20210701030756.58760-3-desmondcheongzx@gmail.com
    Signed-off-by: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
    Reviewed-by: Viacheslav Dubeyko <slava@dubeyko.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Gustavo A. R. Silva <gustavoars@kernel.org>
    Cc: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6004efa7047db44270788a79536993d34ecc506c
Author: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
Date:   Wed Jul 14 21:27:01 2021 -0700

    hfs: add missing clean-up in hfs_fill_super
    
    [ Upstream commit 16ee572eaf0d09daa4c8a755fdb71e40dbf8562d ]
    
    Patch series "hfs: fix various errors", v2.
    
    This series ultimately aims to address a lockdep warning in
    hfs_find_init reported by Syzbot [1].
    
    The work done for this led to the discovery of another bug, and the
    Syzkaller repro test also reveals an invalid memory access error after
    clearing the lockdep warning.  Hence, this series is broken up into
    three patches:
    
    1. Add a missing call to hfs_find_exit for an error path in
       hfs_fill_super
    
    2. Fix memory mapping in hfs_bnode_read by fixing calls to kmap
    
    3. Add lock nesting notation to tell lockdep that the observed locking
       hierarchy is safe
    
    This patch (of 3):
    
    Before exiting hfs_fill_super, the struct hfs_find_data used in
    hfs_find_init should be passed to hfs_find_exit to be cleaned up, and to
    release the lock held on the btree.
    
    The call to hfs_find_exit is missing from an error path.  We add it back
    in by consolidating calls to hfs_find_exit for error paths.
    
    Link: https://syzkaller.appspot.com/bug?id=f007ef1d7a31a469e3be7aeb0fde0769b18585db [1]
    Link: https://lkml.kernel.org/r/20210701030756.58760-1-desmondcheongzx@gmail.com
    Link: https://lkml.kernel.org/r/20210701030756.58760-2-desmondcheongzx@gmail.com
    Signed-off-by: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>
    Reviewed-by: Viacheslav Dubeyko <slava@dubeyko.com>
    Cc: Gustavo A. R. Silva <gustavoars@kernel.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Shuah Khan <skhan@linuxfoundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 43b699d129a08fc0bd6735b6d25686712a9bdabb
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Jun 29 23:34:08 2021 -0400

    sctp: move 198 addresses from unusable to private scope
    
    [ Upstream commit 1d11fa231cabeae09a95cb3e4cf1d9dd34e00f08 ]
    
    The doc draft-stewart-tsvwg-sctp-ipv4-00 that restricts 198 addresses
    was never published. These addresses as private addresses should be
    allowed to use in SCTP.
    
    As Michael Tuexen suggested, this patch is to move 198 addresses from
    unusable to private scope.
    
    Reported-by: Sérgio <surkamp@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e7d0a2680cce2bdf82a9da44dbb72b9b960052ab
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Jun 29 07:12:45 2021 -0700

    net: annotate data race around sk_ll_usec
    
    [ Upstream commit 0dbffbb5335a1e3aa6855e4ee317e25e669dd302 ]
    
    sk_ll_usec is read locklessly from sk_can_busy_loop()
    while another thread can change its value in sock_setsockopt()
    
    This is correct but needs annotations.
    
    BUG: KCSAN: data-race in __skb_try_recv_datagram / sock_setsockopt
    
    write to 0xffff88814eb5f904 of 4 bytes by task 14011 on cpu 0:
     sock_setsockopt+0x1287/0x2090 net/core/sock.c:1175
     __sys_setsockopt+0x14f/0x200 net/socket.c:2100
     __do_sys_setsockopt net/socket.c:2115 [inline]
     __se_sys_setsockopt net/socket.c:2112 [inline]
     __x64_sys_setsockopt+0x62/0x70 net/socket.c:2112
     do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47
     entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    read to 0xffff88814eb5f904 of 4 bytes by task 14001 on cpu 1:
     sk_can_busy_loop include/net/busy_poll.h:41 [inline]
     __skb_try_recv_datagram+0x14f/0x320 net/core/datagram.c:273
     unix_dgram_recvmsg+0x14c/0x870 net/unix/af_unix.c:2101
     unix_seqpacket_recvmsg+0x5a/0x70 net/unix/af_unix.c:2067
     ____sys_recvmsg+0x15d/0x310 include/linux/uio.h:244
     ___sys_recvmsg net/socket.c:2598 [inline]
     do_recvmmsg+0x35c/0x9f0 net/socket.c:2692
     __sys_recvmmsg net/socket.c:2771 [inline]
     __do_sys_recvmmsg net/socket.c:2794 [inline]
     __se_sys_recvmmsg net/socket.c:2787 [inline]
     __x64_sys_recvmmsg+0xcf/0x150 net/socket.c:2787
     do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47
     entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    value changed: 0x00000000 -> 0x00000101
    
    Reported by Kernel Concurrency Sanitizer on:
    CPU: 1 PID: 14001 Comm: syz-executor.3 Not tainted 5.13.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0b38430491af6580e219237ad65945128d185fe9
Author: Yang Yingliang <yangyingliang@huawei.com>
Date:   Tue Jun 29 19:53:28 2021 +0800

    net/802/garp: fix memleak in garp_request_join()
    
    [ Upstream commit 42ca63f980842918560b25f0244307fd83b4777c ]
    
    I got kmemleak report when doing fuzz test:
    
    BUG: memory leak
    unreferenced object 0xffff88810c909b80 (size 64):
      comm "syz", pid 957, jiffies 4295220394 (age 399.090s)
      hex dump (first 32 bytes):
        01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        00 00 00 00 00 00 00 00 08 00 00 00 01 02 00 04  ................
      backtrace:
        [<00000000ca1f2e2e>] garp_request_join+0x285/0x3d0
        [<00000000bf153351>] vlan_gvrp_request_join+0x15b/0x190
        [<0000000024005e72>] vlan_dev_open+0x706/0x980
        [<00000000dc20c4d4>] __dev_open+0x2bb/0x460
        [<0000000066573004>] __dev_change_flags+0x501/0x650
        [<0000000035b42f83>] rtnl_configure_link+0xee/0x280
        [<00000000a5e69de0>] __rtnl_newlink+0xed5/0x1550
        [<00000000a5258f4a>] rtnl_newlink+0x66/0x90
        [<00000000506568ee>] rtnetlink_rcv_msg+0x439/0xbd0
        [<00000000b7eaeae1>] netlink_rcv_skb+0x14d/0x420
        [<00000000c373ce66>] netlink_unicast+0x550/0x750
        [<00000000ec74ce74>] netlink_sendmsg+0x88b/0xda0
        [<00000000381ff246>] sock_sendmsg+0xc9/0x120
        [<000000008f6a2db3>] ____sys_sendmsg+0x6e8/0x820
        [<000000008d9c1735>] ___sys_sendmsg+0x145/0x1c0
        [<00000000aa39dd8b>] __sys_sendmsg+0xfe/0x1d0
    
    Calling garp_request_leave() after garp_request_join(), the attr->state
    is set to GARP_APPLICANT_VO, garp_attr_destroy() won't be called in last
    transmit event in garp_uninit_applicant(), the attr of applicant will be
    leaked. To fix this leak, iterate and free each attr of applicant before
    rerturning from garp_uninit_applicant().
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4d565fccc539334f563e41e1a05eb5e8e4e2281a
Author: Yang Yingliang <yangyingliang@huawei.com>
Date:   Tue Jun 29 15:22:37 2021 +0800

    net/802/mrp: fix memleak in mrp_request_join()
    
    [ Upstream commit 996af62167d0e0ec69b938a3561e96f84ffff1aa ]
    
    I got kmemleak report when doing fuzz test:
    
    BUG: memory leak
    unreferenced object 0xffff88810c239500 (size 64):
    comm "syz-executor940", pid 882, jiffies 4294712870 (age 14.631s)
    hex dump (first 32 bytes):
    01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
    00 00 00 00 00 00 00 00 01 00 00 00 01 02 00 04 ................
    backtrace:
    [<00000000a323afa4>] slab_alloc_node mm/slub.c:2972 [inline]
    [<00000000a323afa4>] slab_alloc mm/slub.c:2980 [inline]
    [<00000000a323afa4>] __kmalloc+0x167/0x340 mm/slub.c:4130
    [<000000005034ca11>] kmalloc include/linux/slab.h:595 [inline]
    [<000000005034ca11>] mrp_attr_create net/802/mrp.c:276 [inline]
    [<000000005034ca11>] mrp_request_join+0x265/0x550 net/802/mrp.c:530
    [<00000000fcfd81f3>] vlan_mvrp_request_join+0x145/0x170 net/8021q/vlan_mvrp.c:40
    [<000000009258546e>] vlan_dev_open+0x477/0x890 net/8021q/vlan_dev.c:292
    [<0000000059acd82b>] __dev_open+0x281/0x410 net/core/dev.c:1609
    [<000000004e6dc695>] __dev_change_flags+0x424/0x560 net/core/dev.c:8767
    [<00000000471a09af>] rtnl_configure_link+0xd9/0x210 net/core/rtnetlink.c:3122
    [<0000000037a4672b>] __rtnl_newlink+0xe08/0x13e0 net/core/rtnetlink.c:3448
    [<000000008d5d0fda>] rtnl_newlink+0x64/0xa0 net/core/rtnetlink.c:3488
    [<000000004882fe39>] rtnetlink_rcv_msg+0x369/0xa10 net/core/rtnetlink.c:5552
    [<00000000907e6c54>] netlink_rcv_skb+0x134/0x3d0 net/netlink/af_netlink.c:2504
    [<00000000e7d7a8c4>] netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]
    [<00000000e7d7a8c4>] netlink_unicast+0x4a0/0x6a0 net/netlink/af_netlink.c:1340
    [<00000000e0645d50>] netlink_sendmsg+0x78e/0xc90 net/netlink/af_netlink.c:1929
    [<00000000c24559b7>] sock_sendmsg_nosec net/socket.c:654 [inline]
    [<00000000c24559b7>] sock_sendmsg+0x139/0x170 net/socket.c:674
    [<00000000fc210bc2>] ____sys_sendmsg+0x658/0x7d0 net/socket.c:2350
    [<00000000be4577b5>] ___sys_sendmsg+0xf8/0x170 net/socket.c:2404
    
    Calling mrp_request_leave() after mrp_request_join(), the attr->state
    is set to MRP_APPLICANT_VO, mrp_attr_destroy() won't be called in last
    TX event in mrp_uninit_applicant(), the attr of applicant will be leaked.
    To fix this leak, iterate and free each attr of applicant before rerturning
    from mrp_uninit_applicant().
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ad7ae9e2a39cd7d0052b721a0dd6f2da0cf99dfc
Author: Yang Yingliang <yangyingliang@huawei.com>
Date:   Wed Jul 14 17:19:33 2021 +0800

    workqueue: fix UAF in pwq_unbound_release_workfn()
    
    commit b42b0bddcbc87b4c66f6497f66fc72d52b712aa7 upstream.
    
    I got a UAF report when doing fuzz test:
    
    [  152.880091][ T8030] ==================================================================
    [  152.881240][ T8030] BUG: KASAN: use-after-free in pwq_unbound_release_workfn+0x50/0x190
    [  152.882442][ T8030] Read of size 4 at addr ffff88810d31bd00 by task kworker/3:2/8030
    [  152.883578][ T8030]
    [  152.883932][ T8030] CPU: 3 PID: 8030 Comm: kworker/3:2 Not tainted 5.13.0+ #249
    [  152.885014][ T8030] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
    [  152.886442][ T8030] Workqueue: events pwq_unbound_release_workfn
    [  152.887358][ T8030] Call Trace:
    [  152.887837][ T8030]  dump_stack_lvl+0x75/0x9b
    [  152.888525][ T8030]  ? pwq_unbound_release_workfn+0x50/0x190
    [  152.889371][ T8030]  print_address_description.constprop.10+0x48/0x70
    [  152.890326][ T8030]  ? pwq_unbound_release_workfn+0x50/0x190
    [  152.891163][ T8030]  ? pwq_unbound_release_workfn+0x50/0x190
    [  152.891999][ T8030]  kasan_report.cold.15+0x82/0xdb
    [  152.892740][ T8030]  ? pwq_unbound_release_workfn+0x50/0x190
    [  152.893594][ T8030]  __asan_load4+0x69/0x90
    [  152.894243][ T8030]  pwq_unbound_release_workfn+0x50/0x190
    [  152.895057][ T8030]  process_one_work+0x47b/0x890
    [  152.895778][ T8030]  worker_thread+0x5c/0x790
    [  152.896439][ T8030]  ? process_one_work+0x890/0x890
    [  152.897163][ T8030]  kthread+0x223/0x250
    [  152.897747][ T8030]  ? set_kthread_struct+0xb0/0xb0
    [  152.898471][ T8030]  ret_from_fork+0x1f/0x30
    [  152.899114][ T8030]
    [  152.899446][ T8030] Allocated by task 8884:
    [  152.900084][ T8030]  kasan_save_stack+0x21/0x50
    [  152.900769][ T8030]  __kasan_kmalloc+0x88/0xb0
    [  152.901416][ T8030]  __kmalloc+0x29c/0x460
    [  152.902014][ T8030]  alloc_workqueue+0x111/0x8e0
    [  152.902690][ T8030]  __btrfs_alloc_workqueue+0x11e/0x2a0
    [  152.903459][ T8030]  btrfs_alloc_workqueue+0x6d/0x1d0
    [  152.904198][ T8030]  scrub_workers_get+0x1e8/0x490
    [  152.904929][ T8030]  btrfs_scrub_dev+0x1b9/0x9c0
    [  152.905599][ T8030]  btrfs_ioctl+0x122c/0x4e50
    [  152.906247][ T8030]  __x64_sys_ioctl+0x137/0x190
    [  152.906916][ T8030]  do_syscall_64+0x34/0xb0
    [  152.907535][ T8030]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  152.908365][ T8030]
    [  152.908688][ T8030] Freed by task 8884:
    [  152.909243][ T8030]  kasan_save_stack+0x21/0x50
    [  152.909893][ T8030]  kasan_set_track+0x20/0x30
    [  152.910541][ T8030]  kasan_set_free_info+0x24/0x40
    [  152.911265][ T8030]  __kasan_slab_free+0xf7/0x140
    [  152.911964][ T8030]  kfree+0x9e/0x3d0
    [  152.912501][ T8030]  alloc_workqueue+0x7d7/0x8e0
    [  152.913182][ T8030]  __btrfs_alloc_workqueue+0x11e/0x2a0
    [  152.913949][ T8030]  btrfs_alloc_workqueue+0x6d/0x1d0
    [  152.914703][ T8030]  scrub_workers_get+0x1e8/0x490
    [  152.915402][ T8030]  btrfs_scrub_dev+0x1b9/0x9c0
    [  152.916077][ T8030]  btrfs_ioctl+0x122c/0x4e50
    [  152.916729][ T8030]  __x64_sys_ioctl+0x137/0x190
    [  152.917414][ T8030]  do_syscall_64+0x34/0xb0
    [  152.918034][ T8030]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  152.918872][ T8030]
    [  152.919203][ T8030] The buggy address belongs to the object at ffff88810d31bc00
    [  152.919203][ T8030]  which belongs to the cache kmalloc-512 of size 512
    [  152.921155][ T8030] The buggy address is located 256 bytes inside of
    [  152.921155][ T8030]  512-byte region [ffff88810d31bc00, ffff88810d31be00)
    [  152.922993][ T8030] The buggy address belongs to the page:
    [  152.923800][ T8030] page:ffffea000434c600 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10d318
    [  152.925249][ T8030] head:ffffea000434c600 order:2 compound_mapcount:0 compound_pincount:0
    [  152.926399][ T8030] flags: 0x57ff00000010200(slab|head|node=1|zone=2|lastcpupid=0x7ff)
    [  152.927515][ T8030] raw: 057ff00000010200 dead000000000100 dead000000000122 ffff888009c42c80
    [  152.928716][ T8030] raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000
    [  152.929890][ T8030] page dumped because: kasan: bad access detected
    [  152.930759][ T8030]
    [  152.931076][ T8030] Memory state around the buggy address:
    [  152.931851][ T8030]  ffff88810d31bc00: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  152.932967][ T8030]  ffff88810d31bc80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  152.934068][ T8030] >ffff88810d31bd00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  152.935189][ T8030]                    ^
    [  152.935763][ T8030]  ffff88810d31bd80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  152.936847][ T8030]  ffff88810d31be00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  152.937940][ T8030] ==================================================================
    
    If apply_wqattrs_prepare() fails in alloc_workqueue(), it will call put_pwq()
    which invoke a work queue to call pwq_unbound_release_workfn() and use the 'wq'.
    The 'wq' allocated in alloc_workqueue() will be freed in error path when
    apply_wqattrs_prepare() fails. So it will lead a UAF.
    
    CPU0                                          CPU1
    alloc_workqueue()
    alloc_and_link_pwqs()
    apply_wqattrs_prepare() fails
    apply_wqattrs_cleanup()
    schedule_work(&pwq->unbound_release_work)
    kfree(wq)
                                                  worker_thread()
                                                  pwq_unbound_release_workfn() <- trigger uaf here
    
    If apply_wqattrs_prepare() fails, the new pwq are not linked, it doesn't
    hold any reference to the 'wq', 'wq' is invalid to access in the worker,
    so add check pwq if linked to fix this.
    
    Fixes: 2d5f0764b526 ("workqueue: split apply_workqueue_attrs() into 3 stages")
    Cc: stable@vger.kernel.org # v4.2+
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Suggested-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
    Reviewed-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Tested-by: Pavel Skripkin <paskripkin@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit af3e2b87b36100c28feb71da52c57293c4540690
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 28 14:47:20 2021 +0200

    af_unix: fix garbage collect vs MSG_PEEK
    
    commit cbcf01128d0a92e131bd09f1688fe032480b65ca upstream.
    
    unix_gc() assumes that candidate sockets can never gain an external
    reference (i.e.  be installed into an fd) while the unix_gc_lock is
    held.  Except for MSG_PEEK this is guaranteed by modifying inflight
    count under the unix_gc_lock.
    
    MSG_PEEK does not touch any variable protected by unix_gc_lock (file
    count is not), yet it needs to be serialized with garbage collection.
    Do this by locking/unlocking unix_gc_lock:
    
     1) increment file count
    
     2) lock/unlock barrier to make sure incremented file count is visible
        to garbage collection
    
     3) install file into fd
    
    This is a lock barrier (unlike smp_mb()) that ensures that garbage
    collection is run completely before or completely after the barrier.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eee65a1282369eedfcbb664d0c865a0ef3eb7017
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Feb 8 09:01:44 2019 -0700

    net: split out functions related to registering inflight socket files
    
    commit f4e65870e5cede5ca1ec0006b6c9803994e5f7b8 upstream.
    
    We need this functionality for the io_uring file registration, but
    we cannot rely on it since CONFIG_UNIX can be modular. Move the helpers
    to a separate file, that's always builtin to the kernel if CONFIG_UNIX is
    m/y.
    
    No functional changes in this patch, just moving code around.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    [ backported to older kernels to get access to unix_gc_lock - gregkh ]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7b6b8db362d2949c09b88ffdfb095796ae854972
Author: Maxim Levitsky <mlevitsk@redhat.com>
Date:   Thu Feb 25 17:41:32 2021 +0200

    KVM: x86: determine if an exception has an error code only when injecting it.
    
    commit b97f074583736c42fb36f2da1164e28c73758912 upstream.
    
    A page fault can be queued while vCPU is in real paged mode on AMD, and
    AMD manual asks the user to always intercept it
    (otherwise result is undefined).
    The resulting VM exit, does have an error code.
    
    Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
    Message-Id: <20210225154135.405125-2-mlevitsk@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Zubin Mithra <zsm@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 53e61d6ec0ea1add13e9f0e927bdd534632f7ce5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 28 13:51:58 2021 +0200

    selftest: fix build error in tools/testing/selftests/vm/userfaultfd.c
    
    When backporting 0db282ba2c12 ("selftest: use mmap instead of
    posix_memalign to allocate memory") to this stable branch, I forgot a {
    breaking the build.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
