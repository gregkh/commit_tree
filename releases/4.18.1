commit 529bea37411759c2b5b41a187b3020723c67c16d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 15 17:37:34 2018 +0200

    Linux 4.18.1

commit c5b169d4c6bda4e822f7d0994a3a39f55ed412e7
Author: Vlastimil Babka <vbabka@suse.cz>
Date:   Tue Aug 14 20:50:47 2018 +0200

    x86/init: fix build with CONFIG_SWAP=n
    
    commit 792adb90fa724ce07c0171cbc96b9215af4b1045 upstream.
    
    The introduction of generic_max_swapfile_size and arch-specific versions has
    broken linking on x86 with CONFIG_SWAP=n due to undefined reference to
    'generic_max_swapfile_size'. Fix it by compiling the x86-specific
    max_swapfile_size() only with CONFIG_SWAP=y.
    
    Reported-by: Tomas Pruzina <pruzinat@gmail.com>
    Fixes: 377eeaa8e11f ("x86/speculation/l1tf: Limit swap file size to MAX_PA/2")
    Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f6be6903fc10637c7cd831b267da5427bd0ce653
Author: Abel Vesa <abelvesa@linux.com>
Date:   Wed Aug 15 00:26:00 2018 +0300

    cpu/hotplug: Non-SMP machines do not make use of booted_once
    
    commit 269777aa530f3438ec1781586cdac0b5fe47b061 upstream.
    
    Commit 0cc3cd21657b ("cpu/hotplug: Boot HT siblings at least once")
    breaks non-SMP builds.
    
    [ I suspect the 'bool' fields should just be made to be bitfields and be
      exposed regardless of configuration, but that's a separate cleanup
      that I'll leave to the owners of this file for later.   - Linus ]
    
    Fixes: 0cc3cd21657b ("cpu/hotplug: Boot HT siblings at least once")
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Abel Vesa <abelvesa@linux.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3b39dc7463a9867208f68de91f665c2d996f2806
Author: Vlastimil Babka <vbabka@suse.cz>
Date:   Tue Aug 14 23:38:57 2018 +0200

    x86/smp: fix non-SMP broken build due to redefinition of apic_id_is_primary_thread
    
    commit d0055f351e647f33f3b0329bff022213bf8aa085 upstream.
    
    The function has an inline "return false;" definition with CONFIG_SMP=n
    but the "real" definition is also visible leading to "redefinition of
    ‘apic_id_is_primary_thread’" compiler error.
    
    Guard it with #ifdef CONFIG_SMP
    
    Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
    Fixes: 6a4d2657e048 ("x86/smp: Provide topology_is_primary_thread()")
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit abf914eefa19098727455f11acd895c57621a822
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Fri Aug 10 08:31:10 2018 +0100

    x86/microcode: Allow late microcode loading with SMT disabled
    
    commit 07d981ad4cf1e78361c6db1c28ee5ba105f96cc1 upstream.
    
    The kernel unnecessarily prevents late microcode loading when SMT is
    disabled.  It should be safe to allow it if all the primary threads are
    online.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 573864e6570eed55a85aba6b4d10d8c673af806f
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Aug 8 11:00:16 2018 +0100

    tools headers: Synchronise x86 cpufeatures.h for L1TF additions
    
    commit e24f14b0ff985f3e09e573ba1134bfdf42987e05 upstream.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 862b9e18a0a33b79635122857ee9c20733542271
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Aug 7 15:09:38 2018 -0700

    x86/mm/kmmio: Make the tracer robust against L1TF
    
    commit 1063711b57393c1999248cccb57bebfaf16739e7 upstream.
    
    The mmio tracer sets io mapping PTEs and PMDs to non present when enabled
    without inverting the address bits, which makes the PTE entry vulnerable
    for L1TF.
    
    Make it use the right low level macros to actually invert the address bits
    to protect against L1TF.
    
    In principle this could be avoided because MMIO tracing is not likely to be
    enabled on production machines, but the fix is straigt forward and for
    consistency sake it's better to get rid of the open coded PTE manipulation.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9fc384dd5354b46ef967f7187764a485935b0dc6
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Aug 7 15:09:39 2018 -0700

    x86/mm/pat: Make set_memory_np() L1TF safe
    
    commit 958f79b9ee55dfaf00c8106ed1c22a2919e0028b upstream.
    
    set_memory_np() is used to mark kernel mappings not present, but it has
    it's own open coded mechanism which does not have the L1TF protection of
    inverting the address bits.
    
    Replace the open coded PTE manipulation with the L1TF protecting low level
    PTE routines.
    
    Passes the CPA self test.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 43b0b90df51125979137b4ca9debb5c479b8e7de
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Aug 7 15:09:37 2018 -0700

    x86/speculation/l1tf: Make pmd/pud_mknotpresent() invert
    
    commit 0768f91530ff46683e0b372df14fd79fe8d156e5 upstream.
    
    Some cases in THP like:
      - MADV_FREE
      - mprotect
      - split
    
    mark the PMD non present for temporarily to prevent races. The window for
    an L1TF attack in these contexts is very small, but it wants to be fixed
    for correctness sake.
    
    Use the proper low level functions for pmd/pud_mknotpresent() to address
    this.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 330e5973bb501a6ac1a4e52aa14423876e145bfc
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Aug 7 15:09:36 2018 -0700

    x86/speculation/l1tf: Invert all not present mappings
    
    commit f22cc87f6c1f771b57c407555cfefd811cdd9507 upstream.
    
    For kernel mappings PAGE_PROTNONE is not necessarily set for a non present
    mapping, but the inversion logic explicitely checks for !PRESENT and
    PROT_NONE.
    
    Remove the PROT_NONE check and make the inversion unconditional for all not
    present mappings.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4d3579f7f904cddf55264c427b746e1ac1a83d7c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Aug 7 08:19:57 2018 +0200

    cpu/hotplug: Fix SMT supported evaluation
    
    commit bc2d8d262cba5736332cbc866acb11b1c5748aa9 upstream.
    
    Josh reported that the late SMT evaluation in cpu_smt_state_init() sets
    cpu_smt_control to CPU_SMT_NOT_SUPPORTED in case that 'nosmt' was supplied
    on the kernel command line as it cannot differentiate between SMT disabled
    by BIOS and SMT soft disable via 'nosmt'. That wreckages the state and
    makes the sysfs interface unusable.
    
    Rework this so that during bringup of the non boot CPUs the availability of
    SMT is determined in cpu_smt_allowed(). If a newly booted CPU is not a
    'primary' thread then set the local cpu_smt_available marker and evaluate
    this explicitely right after the initial SMP bringup has finished.
    
    SMT evaulation on x86 is a trainwreck as the firmware has all the
    information _before_ booting the kernel, but there is no interface to query
    it.
    
    Fixes: 73d5e2b47264 ("cpu/hotplug: detect SMT disabled by BIOS")
    Reported-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3dde2643295d5ca5550adc331564134301dd14ba
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Sun Aug 5 16:07:47 2018 +0200

    KVM: VMX: Tell the nested hypervisor to skip L1D flush on vmentry
    
    commit 5b76a3cff011df2dcb6186c965a2e4d809a05ad4 upstream.
    
    When nested virtualization is in use, VMENTER operations from the nested
    hypervisor into the nested guest will always be processed by the bare metal
    hypervisor, and KVM's "conditional cache flushes" mode in particular does a
    flush on nested vmentry.  Therefore, include the "skip L1D flush on
    vmentry" bit in KVM's suggested ARCH_CAPABILITIES setting.
    
    Add the relevant Documentation.
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ee82c13f6cc127a30c59ef8ee2dfc723b3f2ecf6
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Sun Aug 5 16:07:46 2018 +0200

    x86/speculation: Use ARCH_CAPABILITIES to skip L1D flush on vmentry
    
    commit 8e0b2b916662e09dd4d09e5271cdf214c6b80e62 upstream.
    
    Bit 3 of ARCH_CAPABILITIES tells a hypervisor that L1D flush on vmentry is
    not needed.  Add a new value to enum vmx_l1d_flush_state, which is used
    either if there is no L1TF bug at all, or if bit 3 is set in ARCH_CAPABILITIES.
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3ba71a6ffc5a6353a7d87b0166e53bcd38b4fe29
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Sun Aug 5 16:07:45 2018 +0200

    x86/speculation: Simplify sysfs report of VMX L1TF vulnerability
    
    commit ea156d192f5257a5bf393d33910d3b481bf8a401 upstream.
    
    Three changes to the content of the sysfs file:
    
     - If EPT is disabled, L1TF cannot be exploited even across threads on the
       same core, and SMT is irrelevant.
    
     - If mitigation is completely disabled, and SMT is enabled, print "vulnerable"
       instead of "vulnerable, SMT vulnerable"
    
     - Reorder the two parts so that the main vulnerability state comes first
       and the detail on SMT is second.
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e41eed5736eeb48090b413cf2823929d5069aba8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Aug 5 17:06:12 2018 +0200

    Documentation/l1tf: Remove Yonah processors from not vulnerable list
    
    commit 58331136136935c631c2b5f06daf4c3006416e91 upstream.
    
    Dave reported, that it's not confirmed that Yonah processors are
    unaffected. Remove them from the list.
    
    Reported-by: ave Hansen <dave.hansen@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b16ff629f3403fd3b50fa5c626064b9dff70cacb
Author: Nicolai Stange <nstange@suse.de>
Date:   Sun Jul 22 13:38:18 2018 +0200

    x86/KVM/VMX: Don't set l1tf_flush_l1d from vmx_handle_external_intr()
    
    commit 18b57ce2eb8c8b9a24174a89250cf5f57c76ecdc upstream.
    
    For VMEXITs caused by external interrupts, vmx_handle_external_intr()
    indirectly calls into the interrupt handlers through the host's IDT.
    
    It follows that these interrupts get accounted for in the
    kvm_cpu_l1tf_flush_l1d per-cpu flag.
    
    The subsequently executed vmx_l1d_flush() will thus be aware that some
    interrupts have happened and conduct a L1d flush anyway.
    
    Setting l1tf_flush_l1d from vmx_handle_external_intr() isn't needed
    anymore. Drop it.
    
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3131918d536055f456bc453fa96a083080112bc5
Author: Nicolai Stange <nstange@suse.de>
Date:   Sun Jul 29 13:06:04 2018 +0200

    x86/irq: Let interrupt handlers set kvm_cpu_l1tf_flush_l1d
    
    commit ffcba43ff66c7dab34ec700debd491d2a4d319b4 upstream.
    
    The last missing piece to having vmx_l1d_flush() take interrupts after
    VMEXIT into account is to set the kvm_cpu_l1tf_flush_l1d per-cpu flag on
    irq entry.
    
    Issue calls to kvm_set_cpu_l1tf_flush_l1d() from entering_irq(),
    ipi_entering_ack_irq(), smp_reschedule_interrupt() and
    uv_bau_message_interrupt().
    
    Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5ab84cf0c2ba831d58566c783333661053c90ef1
Author: Nicolai Stange <nstange@suse.de>
Date:   Sun Jul 29 12:15:33 2018 +0200

    x86: Don't include linux/irq.h from asm/hardirq.h
    
    commit 447ae316670230d7d29430e2cbf1f5db4f49d14c upstream.
    
    The next patch in this series will have to make the definition of
    irq_cpustat_t available to entering_irq().
    
    Inclusion of asm/hardirq.h into asm/apic.h would cause circular header
    dependencies like
    
      asm/smp.h
        asm/apic.h
          asm/hardirq.h
            linux/irq.h
              linux/topology.h
                linux/smp.h
                  asm/smp.h
    
    or
    
      linux/gfp.h
        linux/mmzone.h
          asm/mmzone.h
            asm/mmzone_64.h
              asm/smp.h
                asm/apic.h
                  asm/hardirq.h
                    linux/irq.h
                      linux/irqdesc.h
                        linux/kobject.h
                          linux/sysfs.h
                            linux/kernfs.h
                              linux/idr.h
                                linux/gfp.h
    
    and others.
    
    This causes compilation errors because of the header guards becoming
    effective in the second inclusion: symbols/macros that had been defined
    before wouldn't be available to intermediate headers in the #include chain
    anymore.
    
    A possible workaround would be to move the definition of irq_cpustat_t
    into its own header and include that from both, asm/hardirq.h and
    asm/apic.h.
    
    However, this wouldn't solve the real problem, namely asm/harirq.h
    unnecessarily pulling in all the linux/irq.h cruft: nothing in
    asm/hardirq.h itself requires it. Also, note that there are some other
    archs, like e.g. arm64, which don't have that #include in their
    asm/hardirq.h.
    
    Remove the linux/irq.h #include from x86' asm/hardirq.h.
    
    Fix resulting compilation errors by adding appropriate #includes to *.c
    files as needed.
    
    Note that some of these *.c files could be cleaned up a bit wrt. to their
    set of #includes, but that should better be done from separate patches, if
    at all.
    
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 516ed9db64f44c6f467b7a1fb43b9d5e7b8fdc5c
Author: Nicolai Stange <nstange@suse.de>
Date:   Fri Jul 27 13:22:16 2018 +0200

    x86/KVM/VMX: Introduce per-host-cpu analogue of l1tf_flush_l1d
    
    commit 45b575c00d8e72d69d75dd8c112f044b7b01b069 upstream.
    
    Part of the L1TF mitigation for vmx includes flushing the L1D cache upon
    VMENTRY.
    
    L1D flushes are costly and two modes of operations are provided to users:
    "always" and the more selective "conditional" mode.
    
    If operating in the latter, the cache would get flushed only if a host side
    code path considered unconfined had been traversed. "Unconfined" in this
    context means that it might have pulled in sensitive data like user data
    or kernel crypto keys.
    
    The need for L1D flushes is tracked by means of the per-vcpu flag
    l1tf_flush_l1d. KVM exit handlers considered unconfined set it. A
    vmx_l1d_flush() subsequently invoked before the next VMENTER will conduct a
    L1d flush based on its value and reset that flag again.
    
    Currently, interrupts delivered "normally" while in root operation between
    VMEXIT and VMENTER are not taken into account. Part of the reason is that
    these don't leave any traces and thus, the vmx code is unable to tell if
    any such has happened.
    
    As proposed by Paolo Bonzini, prepare for tracking all interrupts by
    introducing a new per-cpu flag, "kvm_cpu_l1tf_flush_l1d". It will be in
    strong analogy to the per-vcpu ->l1tf_flush_l1d.
    
    A later patch will make interrupt handlers set it.
    
    For the sake of cache locality, group kvm_cpu_l1tf_flush_l1d into x86'
    per-cpu irq_cpustat_t as suggested by Peter Zijlstra.
    
    Provide the helpers kvm_set_cpu_l1tf_flush_l1d(),
    kvm_clear_cpu_l1tf_flush_l1d() and kvm_get_cpu_l1tf_flush_l1d(). Make them
    trivial resp. non-existent for !CONFIG_KVM_INTEL as appropriate.
    
    Let vmx_l1d_flush() handle kvm_cpu_l1tf_flush_l1d in the same way as
    l1tf_flush_l1d.
    
    Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6120bb28672d72e6df1459bd4aeaf1520ca5bc30
Author: Nicolai Stange <nstange@suse.de>
Date:   Fri Jul 27 12:46:29 2018 +0200

    x86/irq: Demote irq_cpustat_t::__softirq_pending to u16
    
    commit 9aee5f8a7e30330d0a8f4c626dc924ca5590aba5 upstream.
    
    An upcoming patch will extend KVM's L1TF mitigation in conditional mode
    to also cover interrupts after VMEXITs. For tracking those, stores to a
    new per-cpu flag from interrupt handlers will become necessary.
    
    In order to improve cache locality, this new flag will be added to x86's
    irq_cpustat_t.
    
    Make some space available there by shrinking the ->softirq_pending bitfield
    from 32 to 16 bits: the number of bits actually used is only NR_SOFTIRQS,
    i.e. 10.
    
    Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2754f7c6ec884c9fec1d9e100a78c88512fa6b4e
Author: Nicolai Stange <nstange@suse.de>
Date:   Sat Jul 21 22:35:28 2018 +0200

    x86/KVM/VMX: Move the l1tf_flush_l1d test to vmx_l1d_flush()
    
    commit 5b6ccc6c3b1a477fbac9ec97a0b4c1c48e765209 upstream.
    
    Currently, vmx_vcpu_run() checks if l1tf_flush_l1d is set and invokes
    vmx_l1d_flush() if so.
    
    This test is unncessary for the "always flush L1D" mode.
    
    Move the check to vmx_l1d_flush()'s conditional mode code path.
    
    Notes:
    - vmx_l1d_flush() is likely to get inlined anyway and thus, there's no
      extra function call.
    
    - This inverts the (static) branch prediction, but there hadn't been any
      explicit likely()/unlikely() annotations before and so it stays as is.
    
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7f29a7c2505ef69ed3f29c616e8384b06a98c01a
Author: Nicolai Stange <nstange@suse.de>
Date:   Sat Jul 21 22:25:00 2018 +0200

    x86/KVM/VMX: Replace 'vmx_l1d_flush_always' with 'vmx_l1d_flush_cond'
    
    commit 427362a142441f08051369db6fbe7f61c73b3dca upstream.
    
    The vmx_l1d_flush_always static key is only ever evaluated if
    vmx_l1d_should_flush is enabled. In that case however, there are only two
    L1d flushing modes possible: "always" and "conditional".
    
    The "conditional" mode's implementation tends to require more sophisticated
    logic than the "always" mode.
    
    Avoid inverted logic by replacing the 'vmx_l1d_flush_always' static key
    with a 'vmx_l1d_flush_cond' one.
    
    There is no change in functionality.
    
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d3cc70af8e59ebacaf030f3e0d0293211f170494
Author: Nicolai Stange <nstange@suse.de>
Date:   Sat Jul 21 22:16:56 2018 +0200

    x86/KVM/VMX: Don't set l1tf_flush_l1d to true from vmx_l1d_flush()
    
    commit 379fd0c7e6a391e5565336a646f19f218fb98c6c upstream.
    
    vmx_l1d_flush() gets invoked only if l1tf_flush_l1d is true. There's no
    point in setting l1tf_flush_l1d to true from there again.
    
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 89f5f7582732de8845e98c23bccae46a6252a601
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Tue Jul 24 18:17:40 2018 +0200

    cpu/hotplug: detect SMT disabled by BIOS
    
    commit 73d5e2b472640b1fcdb61ae8be389912ef211bda upstream.
    
    If SMT is disabled in BIOS, the CPU code doesn't properly detect it.
    The /sys/devices/system/cpu/smt/control file shows 'on', and the 'l1tf'
    vulnerabilities file shows SMT as vulnerable.
    
    Fix it by forcing 'cpu_smt_control' to CPU_SMT_NOT_SUPPORTED in such a
    case.  Unfortunately the detection can only be done after bringing all
    the CPUs online, so we have to overwrite any previous writes to the
    variable.
    
    Reported-by: Joe Mario <jmario@redhat.com>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Fixes: f048c399e0f7 ("x86/topology: Provide topology_smt_supported()")
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 00cfc2f506a93719eb6a3dd739108568cf6d441a
Author: Tony Luck <tony.luck@intel.com>
Date:   Thu Jul 19 13:49:58 2018 -0700

    Documentation/l1tf: Fix typos
    
    commit 1949f9f49792d65dba2090edddbe36a5f02e3ba3 upstream.
    
    Fix spelling and other typos
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 62de9c5ed2a73c1692829e83e7aa72a73742247a
Author: Nicolai Stange <nstange@suse.de>
Date:   Wed Jul 18 19:07:38 2018 +0200

    x86/KVM/VMX: Initialize the vmx_l1d_flush_pages' content
    
    commit 288d152c23dcf3c09da46c5c481903ca10ebfef7 upstream.
    
    The slow path in vmx_l1d_flush() reads from vmx_l1d_flush_pages in order
    to evict the L1d cache.
    
    However, these pages are never cleared and, in theory, their data could be
    leaked.
    
    More importantly, KSM could merge a nested hypervisor's vmx_l1d_flush_pages
    to fewer than 1 << L1D_CACHE_ORDER host physical pages and this would break
    the L1d flushing algorithm: L1D on x86_64 is tagged by physical addresses.
    
    Fix this by initializing the individual vmx_l1d_flush_pages with a
    different pattern each.
    
    Rename the "empty_zp" asm constraint identifier in vmx_l1d_flush() to
    "flush_pages" to reflect this change.
    
    Fixes: a47dd5f06714 ("x86/KVM/VMX: Add L1D flush algorithm")
    Signed-off-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b8b75ff14fb09357937e1781f5bc830ed14b7033
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Sat Jul 14 21:56:13 2018 +0200

    x86/speculation/l1tf: Unbreak !__HAVE_ARCH_PFN_MODIFY_ALLOWED architectures
    
    commit 6c26fcd2abfe0a56bbd95271fce02df2896cfd24 upstream.
    
    pfn_modify_allowed() and arch_has_pfn_modify_check() are outside of the
    !__ASSEMBLY__ section in include/asm-generic/pgtable.h, which confuses
    assembler on archs that don't have __HAVE_ARCH_PFN_MODIFY_ALLOWED (e.g.
    ia64) and breaks build:
    
        include/asm-generic/pgtable.h: Assembler messages:
        include/asm-generic/pgtable.h:538: Error: Unknown opcode `static inline bool pfn_modify_allowed(unsigned long pfn,pgprot_t prot)'
        include/asm-generic/pgtable.h:540: Error: Unknown opcode `return true'
        include/asm-generic/pgtable.h:543: Error: Unknown opcode `static inline bool arch_has_pfn_modify_check(void)'
        include/asm-generic/pgtable.h:545: Error: Unknown opcode `return false'
        arch/ia64/kernel/entry.S:69: Error: `mov' does not fit into bundle
    
    Move those two static inlines into the !__ASSEMBLY__ section so that they
    don't confuse the asm build pass.
    
    Fixes: 42e4089c7890 ("x86/speculation/l1tf: Disallow non privileged high MMIO PROT_NONE mappings")
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d8360e9279ce81b723a12c72f3d9c82e9a64d859
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 16:23:26 2018 +0200

    Documentation: Add section about CPU vulnerabilities
    
    commit 3ec8ce5d866ec6a08a9cfab82b62acf4a830b35f upstream.
    
    Add documentation for the L1TF vulnerability and the mitigation mechanisms:
    
      - Explain the problem and risks
      - Document the mitigation mechanisms
      - Document the command line controls
      - Document the sysfs files
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Link: https://lkml.kernel.org/r/20180713142323.287429944@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 82abbe0ea7a2990207ba33a716d519b5cc39a415
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Jul 13 16:23:25 2018 +0200

    x86/bugs, kvm: Introduce boot-time control of L1TF mitigations
    
    commit d90a7a0ec83fb86622cd7dae23255d3c50a99ec8 upstream.
    
    Introduce the 'l1tf=' kernel command line option to allow for boot-time
    switching of mitigation that is used on processors affected by L1TF.
    
    The possible values are:
    
      full
            Provides all available mitigations for the L1TF vulnerability. Disables
            SMT and enables all mitigations in the hypervisors. SMT control via
            /sys/devices/system/cpu/smt/control is still possible after boot.
            Hypervisors will issue a warning when the first VM is started in
            a potentially insecure configuration, i.e. SMT enabled or L1D flush
            disabled.
    
      full,force
            Same as 'full', but disables SMT control. Implies the 'nosmt=force'
            command line option. sysfs control of SMT and the hypervisor flush
            control is disabled.
    
      flush
            Leaves SMT enabled and enables the conditional hypervisor mitigation.
            Hypervisors will issue a warning when the first VM is started in a
            potentially insecure configuration, i.e. SMT enabled or L1D flush
            disabled.
    
      flush,nosmt
            Disables SMT and enables the conditional hypervisor mitigation. SMT
            control via /sys/devices/system/cpu/smt/control is still possible
            after boot. If SMT is reenabled or flushing disabled at runtime
            hypervisors will issue a warning.
    
      flush,nowarn
            Same as 'flush', but hypervisors will not warn when
            a VM is started in a potentially insecure configuration.
    
      off
            Disables hypervisor mitigations and doesn't emit any warnings.
    
    Default is 'flush'.
    
    Let KVM adhere to these semantics, which means:
    
      - 'lt1f=full,force'   : Performe L1D flushes. No runtime control
                              possible.
    
      - 'l1tf=full'
      - 'l1tf-flush'
      - 'l1tf=flush,nosmt'  : Perform L1D flushes and warn on VM start if
                              SMT has been runtime enabled or L1D flushing
                              has been run-time enabled
    
      - 'l1tf=flush,nowarn' : Perform L1D flushes and no warnings are emitted.
    
      - 'l1tf=off'          : L1D flushes are not performed and no warnings
                              are emitted.
    
    KVM can always override the L1D flushing behavior using its 'vmentry_l1d_flush'
    module parameter except when lt1f=full,force is set.
    
    This makes KVM's private 'nosmt' option redundant, and as it is a bit
    non-systematic anyway (this is something to control globally, not on
    hypervisor level), remove that option.
    
    Add the missing Documentation entry for the l1tf vulnerability sysfs file
    while at it.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142323.202758176@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 347ff08ab796dfca6bdb820ff8111e2f61852056
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 16:23:24 2018 +0200

    cpu/hotplug: Set CPU_SMT_NOT_SUPPORTED early
    
    commit fee0aede6f4739c87179eca76136f83210953b86 upstream.
    
    The CPU_SMT_NOT_SUPPORTED state is set (if the processor does not support
    SMT) when the sysfs SMT control file is initialized.
    
    That was fine so far as this was only required to make the output of the
    control file correct and to prevent writes in that case.
    
    With the upcoming l1tf command line parameter, this needs to be set up
    before the L1TF mitigation selection and command line parsing happens.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142323.121795971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 758b51878d9e6221e2ee04d00425cddbbb5efb6f
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Jul 13 16:23:23 2018 +0200

    cpu/hotplug: Expose SMT control init function
    
    commit 8e1b706b6e819bed215c0db16345568864660393 upstream.
    
    The L1TF mitigation will gain a commend line parameter which allows to set
    a combination of hypervisor mitigation and SMT control.
    
    Expose cpu_smt_disable() so the command line parser can tweak SMT settings.
    
    [ tglx: Split out of larger patch and made it preserve an already existing
            force off state ]
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142323.039715135@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fe30a30f5906c1bea13ee224fbe34f994cb42d5d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 16:23:22 2018 +0200

    x86/kvm: Allow runtime control of L1D flush
    
    commit 895ae47f9918833c3a880fbccd41e0692b37e7d9 upstream.
    
    All mitigation modes can be switched at run time with a static key now:
    
     - Use sysfs_streq() instead of strcmp() to handle the trailing new line
       from sysfs writes correctly.
     - Make the static key management handle multiple invocations properly.
     - Set the module parameter file to RW
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142322.954525119@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8b2f15b4f2a824d57e4a77fe6dcf06b8dbca3fde
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 16:23:21 2018 +0200

    x86/kvm: Serialize L1D flush parameter setter
    
    commit dd4bfa739a72508b75760b393d129ed7b431daab upstream.
    
    Writes to the parameter files are not serialized at the sysfs core
    level, so local serialization is required.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142322.873642605@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 651f562081cc6386fbb181f863f6d95890714f7b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 16:23:20 2018 +0200

    x86/kvm: Add static key for flush always
    
    commit 4c6523ec59fe895ea352a650218a6be0653910b1 upstream.
    
    Avoid the conditional in the L1D flush control path.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142322.790914912@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cc1e6659990b3e7b33cc7d9439582bd9bfb7bb34
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 16:23:19 2018 +0200

    x86/kvm: Move l1tf setup function
    
    commit 7db92e165ac814487264632ab2624e832f20ae38 upstream.
    
    In preparation of allowing run time control for L1D flushing, move the
    setup code to the module parameter handler.
    
    In case of pre module init parsing, just store the value and let vmx_init()
    do the actual setup after running kvm_init() so that enable_ept is having
    the correct state.
    
    During run-time invoke it directly from the parameter setter to prepare for
    run-time control.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142322.694063239@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3c68ad96f2b8bef4e07e65a888ad82e0c70f9626
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 16:23:18 2018 +0200

    x86/l1tf: Handle EPT disabled state proper
    
    commit a7b9020b06ec6d7c3f3b0d4ef1a9eba12654f4f7 upstream.
    
    If Extended Page Tables (EPT) are disabled or not supported, no L1D
    flushing is required. The setup function can just avoid setting up the L1D
    flush for the EPT=n case.
    
    Invoke it after the hardware setup has be done and enable_ept has the
    correct state and expose the EPT disabled state in the mitigation status as
    well.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142322.612160168@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dc622f564b67df4fd567d4345dc7a627c515ffb1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 16:23:17 2018 +0200

    x86/kvm: Drop L1TF MSR list approach
    
    commit 2f055947ae5e2741fb2dc5bba1033c417ccf4faa upstream.
    
    The VMX module parameter to control the L1D flush should become
    writeable.
    
    The MSR list is set up at VM init per guest VCPU, but the run time
    switching is based on a static key which is global. Toggling the MSR list
    at run time might be feasible, but for now drop this optimization and use
    the regular MSR write to make run-time switching possible.
    
    The default mitigation is the conditional flush anyway, so for extra
    paranoid setups this will add some small overhead, but the extra code
    executed is in the noise compared to the flush itself.
    
    Aside of that the EPT disabled case is not handled correctly at the moment
    and the MSR list magic is in the way for fixing that as well.
    
    If it's really providing a significant advantage, then this needs to be
    revisited after the code is correct and the control is writable.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142322.516940445@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8fc95fe3fe601e48f719d10ff63e32142e86db05
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 16:23:16 2018 +0200

    x86/litf: Introduce vmx status variable
    
    commit 72c6d2db64fa18c996ece8f06e499509e6c9a37e upstream.
    
    Store the effective mitigation of VMX in a status variable and use it to
    report the VMX state in the l1tf sysfs file.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Link: https://lkml.kernel.org/r/20180713142322.433098358@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8e5e7a09889ada21077936c51ca3b2b17cec9e34
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 7 11:40:18 2018 +0200

    cpu/hotplug: Online siblings when SMT control is turned on
    
    commit 215af5499d9e2b55f111d2431ea20218115f29b3 upstream.
    
    Writing 'off' to /sys/devices/system/cpu/smt/control offlines all SMT
    siblings. Writing 'on' merily enables the abilify to online them, but does
    not online them automatically.
    
    Make 'on' more useful by onlining all offline siblings.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f11565bed15a886bc4cf4845014d36996ae750a4
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Jun 28 17:10:36 2018 -0400

    x86/KVM/VMX: Use MSR save list for IA32_FLUSH_CMD if required
    
    commit 390d975e0c4e60ce70d4157e0dd91ede37824603 upstream.
    
    If the L1D flush module parameter is set to 'always' and the IA32_FLUSH_CMD
    MSR is available, optimize the VMENTER code with the MSR save list.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cd1fb4bb18e52d685bc5e061dc817d725dd347e7
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Jun 20 22:01:22 2018 -0400

    x86/KVM/VMX: Extend add_atomic_switch_msr() to allow VMENTER only MSRs
    
    commit 989e3992d2eca32c3f1404f2bc91acda3aa122d8 upstream.
    
    The IA32_FLUSH_CMD MSR needs only to be written on VMENTER. Extend
    add_atomic_switch_msr() with an entry_only parameter to allow storing the
    MSR only in the guest (ENTRY) MSR array.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d86126ab742d5d70564fbe5aca7964197b34779e
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Jun 20 22:00:47 2018 -0400

    x86/KVM/VMX: Separate the VMX AUTOLOAD guest/host number accounting
    
    commit 3190709335dd31fe1aeeebfe4ffb6c7624ef971f upstream.
    
    This allows to load a different number of MSRs depending on the context:
    VMEXIT or VMENTER.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 452695e55b38f04dff86e292b1140aa12ad811db
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Jun 20 20:11:39 2018 -0400

    x86/KVM/VMX: Add find_msr() helper function
    
    commit ca83b4a7f2d068da79a029d323024aa45decb250 upstream.
    
    .. to help find the MSR on either the guest or host MSR list.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6cfd9bd0167a598b0d5cda1d47c06171c58e78b5
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Jun 20 13:58:37 2018 -0400

    x86/KVM/VMX: Split the VMX MSR LOAD structures to have an host/guest numbers
    
    commit 33966dd6b2d2c352fae55412db2ea8cfff5df13a upstream.
    
    There is no semantic change but this change allows an unbalanced amount of
    MSRs to be loaded on VMEXIT and VMENTER, i.e. the number of MSRs to save or
    restore on VMEXIT or VMENTER may be different.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1f2bbb423bbb7f1ecfd2915011aca29f8583e527
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Mon Jul 2 13:07:14 2018 +0200

    x86/KVM/VMX: Add L1D flush logic
    
    commit c595ceee45707f00f64f61c54fb64ef0cc0b4e85 upstream.
    
    Add the logic for flushing L1D on VMENTER. The flush depends on the static
    key being enabled and the new l1tf_flush_l1d flag being set.
    
    The flags is set:
     - Always, if the flush module parameter is 'always'
    
     - Conditionally at:
       - Entry to vcpu_run(), i.e. after executing user space
    
       - From the sched_in notifier, i.e. when switching to a vCPU thread.
    
       - From vmexit handlers which are considered unsafe, i.e. where
         sensitive data can be brought into L1D:
    
         - The emulator, which could be a good target for other speculative
           execution-based threats,
    
         - The MMU, which can bring host page tables in the L1 cache.
    
         - External interrupts
    
         - Nested operations that require the MMU (see above). That is
           vmptrld, vmptrst, vmclear,vmwrite,vmread.
    
         - When handling invept,invvpid
    
    [ tglx: Split out from combo patch and reduced to a single flag ]
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 43cb51f8ef3776065fe983454f0c6449d75d1995
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Mon Jul 2 13:03:48 2018 +0200

    x86/KVM/VMX: Add L1D MSR based flush
    
    commit 3fa045be4c720146b18a19cea7a767dc6ad5df94 upstream.
    
    336996-Speculative-Execution-Side-Channel-Mitigations.pdf defines a new MSR
    (IA32_FLUSH_CMD aka 0x10B) which has similar write-only semantics to other
    MSRs defined in the document.
    
    The semantics of this MSR is to allow "finer granularity invalidation of
    caching structures than existing mechanisms like WBINVD. It will writeback
    and invalidate the L1 data cache, including all cachelines brought in by
    preceding instructions, without invalidating all caches (eg. L2 or
    LLC). Some processors may also invalidate the first level level instruction
    cache on a L1D_FLUSH command. The L1 data and instruction caches may be
    shared across the logical processors of a core."
    
    Use it instead of the loop based L1 flush algorithm.
    
    A copy of this document is available at
       https://bugzilla.kernel.org/show_bug.cgi?id=199511
    
    [ tglx: Avoid allocating pages when the MSR is available ]
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f1b4a0b93e9f9a5bfadd257edc53935920595d3f
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Mon Jul 2 12:47:38 2018 +0200

    x86/KVM/VMX: Add L1D flush algorithm
    
    commit a47dd5f06714c844b33f3b5f517b6f3e81ce57b5 upstream.
    
    To mitigate the L1 Terminal Fault vulnerability it's required to flush L1D
    on VMENTER to prevent rogue guests from snooping host memory.
    
    CPUs will have a new control MSR via a microcode update to flush L1D with a
    single MSR write, but in the absence of microcode a fallback to a software
    based flush algorithm is required.
    
    Add a software flush loop which is based on code from Intel.
    
    [ tglx: Split out from combo patch ]
    [ bpetkov: Polish the asm code ]
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a1a4f40bee8616a6d875d2bd7bf62dc206d8a4fc
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Jul 2 12:29:30 2018 +0200

    x86/KVM/VMX: Add module argument for L1TF mitigation
    
    commit a399477e52c17e148746d3ce9a483f681c2aa9a0 upstream.
    
    Add a mitigation mode parameter "vmentry_l1d_flush" for CVE-2018-3620, aka
    L1 terminal fault. The valid arguments are:
    
     - "always"     L1D cache flush on every VMENTER.
     - "cond"       Conditional L1D cache flush, explained below
     - "never"      Disable the L1D cache flush mitigation
    
    "cond" is trying to avoid L1D cache flushes on VMENTER if the code executed
    between VMEXIT and VMENTER is considered safe, i.e. is not bringing any
    interesting information into L1D which might exploited.
    
    [ tglx: Split out from a larger patch ]
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3d2db4f84f09564ad22e742fe145d790c409db7a
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Jun 20 11:29:53 2018 -0400

    x86/KVM: Warn user if KVM is loaded SMT and L1TF CPU bug being present
    
    commit 26acfb666a473d960f0fd971fe68f3e3ad16c70b upstream.
    
    If the L1TF CPU bug is present we allow the KVM module to be loaded as the
    major of users that use Linux and KVM have trusted guests and do not want a
    broken setup.
    
    Cloud vendors are the ones that are uncomfortable with CVE 2018-3620 and as
    such they are the ones that should set nosmt to one.
    
    Setting 'nosmt' means that the system administrator also needs to disable
    SMT (Hyper-threading) in the BIOS, or via the 'nosmt' command line
    parameter, or via the /sys/devices/system/cpu/smt/control. See commit
    05736e4ac13c ("cpu/hotplug: Provide knobs to control SMT").
    
    Other mitigations are to use task affinity, cpu sets, interrupt binding,
    etc - anything to make sure that _only_ the same guests vCPUs are running
    on sibling threads.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7774cb314cd10beb6e1e289c4d1c685aebb63e92
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jun 29 16:05:48 2018 +0200

    cpu/hotplug: Boot HT siblings at least once
    
    commit 0cc3cd21657be04cb0559fe8063f2130493f92cf upstream.
    
    Due to the way Machine Check Exceptions work on X86 hyperthreads it's
    required to boot up _all_ logical cores at least once in order to set the
    CR4.MCE bit.
    
    So instead of ignoring the sibling threads right away, let them boot up
    once so they can configure themselves. After they came out of the initial
    boot stage check whether its a "secondary" sibling and cancel the operation
    which puts the CPU back into offline state.
    
    Reported-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fbe359706d55a55960b8790eceab9f08cc197c32
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jun 29 16:05:47 2018 +0200

    Revert "x86/apic: Ignore secondary threads if nosmt=force"
    
    commit 506a66f374891ff08e064a058c446b336c5ac760 upstream.
    
    Dave Hansen reported, that it's outright dangerous to keep SMT siblings
    disabled completely so they are stuck in the BIOS and wait for SIPI.
    
    The reason is that Machine Check Exceptions are broadcasted to siblings and
    the soft disabled sibling has CR4.MCE = 0. If a MCE is delivered to a
    logical core with CR4.MCE = 0, it asserts IERR#, which shuts down or
    reboots the machine. The MCE chapter in the SDM contains the following
    blurb:
    
        Because the logical processors within a physical package are tightly
        coupled with respect to shared hardware resources, both logical
        processors are notified of machine check errors that occur within a
        given physical processor. If machine-check exceptions are enabled when
        a fatal error is reported, all the logical processors within a physical
        package are dispatched to the machine-check exception handler. If
        machine-check exceptions are disabled, the logical processors enter the
        shutdown state and assert the IERR# signal. When enabling machine-check
        exceptions, the MCE flag in control register CR4 should be set for each
        logical processor.
    
    Reverting the commit which ignores siblings at enumeration time solves only
    half of the problem. The core cpuhotplug logic needs to be adjusted as
    well.
    
    This thoughtful engineered mechanism also turns the boot process on all
    Intel HT enabled systems into a MCE lottery. MCE is enabled on the boot CPU
    before the secondary CPUs are brought up. Depending on the number of
    physical cores the window in which this situation can happen is smaller or
    larger. On a HSW-EX it's about 750ms:
    
    MCE is enabled on the boot CPU:
    
    [    0.244017] mce: CPU supports 22 MCE banks
    
    The corresponding sibling #72 boots:
    
    [    1.008005] .... node  #0, CPUs:    #72
    
    That means if an MCE hits on physical core 0 (logical CPUs 0 and 72)
    between these two points the machine is going to shutdown. At least it's a
    known safe state.
    
    It's obvious that the early boot can be hit by an MCE as well and then runs
    into the same situation because MCEs are not yet enabled on the boot CPU.
    But after enabling them on the boot CPU, it does not make any sense to
    prevent the kernel from recovering.
    
    Adjust the nosmt kernel parameter documentation as well.
    
    Reverts: 2207def700f9 ("x86/apic: Ignore secondary threads if nosmt=force")
    Reported-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0122cebdc4608d00ecd447c6eedd6fc8ba6beb9e
Author: Michal Hocko <mhocko@suse.cz>
Date:   Wed Jun 27 17:46:50 2018 +0200

    x86/speculation/l1tf: Fix up pte->pfn conversion for PAE
    
    commit e14d7dfb41f5807a0c1c26a13f2b8ef16af24935 upstream.
    
    Jan has noticed that pte_pfn and co. resp. pfn_pte are incorrect for
    CONFIG_PAE because phys_addr_t is wider than unsigned long and so the
    pte_val reps. shift left would get truncated. Fix this up by using proper
    types.
    
    Fixes: 6b28baca9b1f ("x86/speculation/l1tf: Protect PROT_NONE PTEs against speculation")
    Reported-by: Jan Beulich <JBeulich@suse.com>
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ae3b9410d7ea4ed6188b3bb9efafd3880891211f
Author: Vlastimil Babka <vbabka@suse.cz>
Date:   Fri Jun 22 17:39:33 2018 +0200

    x86/speculation/l1tf: Protect PAE swap entries against L1TF
    
    commit 0d0f6249058834ffe1ceaad0bb31464af66f6e7a upstream.
    
    The PAE 3-level paging code currently doesn't mitigate L1TF by flipping the
    offset bits, and uses the high PTE word, thus bits 32-36 for type, 37-63 for
    offset. The lower word is zeroed, thus systems with less than 4GB memory are
    safe. With 4GB to 128GB the swap type selects the memory locations vulnerable
    to L1TF; with even more memory, also the swap offfset influences the address.
    This might be a problem with 32bit PAE guests running on large 64bit hosts.
    
    By continuing to keep the whole swap entry in either high or low 32bit word of
    PTE we would limit the swap size too much. Thus this patch uses the whole PAE
    PTE with the same layout as the 64bit version does. The macros just become a
    bit tricky since they assume the arch-dependent swp_entry_t to be 32bit.
    
    Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ccd135cdd9c1839a42b3a07421023aade9dcce12
Author: Borislav Petkov <bp@suse.de>
Date:   Fri Jun 22 11:34:11 2018 +0200

    x86/CPU/AMD: Move TOPOEXT reenablement before reading smp_num_siblings
    
    commit 7ce2f0393ea2396142b7faf6ee9b1f3676d08a5f upstream.
    
    The TOPOEXT reenablement is a workaround for broken BIOSen which didn't
    enable the CPUID bit. amd_get_topology_early(), however, relies on
    that bit being set so that it can read out the CPUID leaf and set
    smp_num_siblings properly.
    
    Move the reenablement up to early_init_amd(). While at it, simplify
    amd_get_topology_early().
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eabc9764ebdcbc25b3688db9bc8eee59db34ebf7
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Jun 20 16:42:58 2018 -0400

    x86/cpufeatures: Add detection of L1D cache flush support.
    
    commit 11e34e64e4103955fc4568750914c75d65ea87ee upstream.
    
    336996-Speculative-Execution-Side-Channel-Mitigations.pdf defines a new MSR
    (IA32_FLUSH_CMD) which is detected by CPUID.7.EDX[28]=1 bit being set.
    
    This new MSR "gives software a way to invalidate structures with finer
    granularity than other architectual methods like WBINVD."
    
    A copy of this document is available at
      https://bugzilla.kernel.org/show_bug.cgi?id=199511
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f70abc9107e16ae881287889ad8980f74e902bb4
Author: Vlastimil Babka <vbabka@suse.cz>
Date:   Thu Jun 21 12:36:29 2018 +0200

    x86/speculation/l1tf: Extend 64bit swap file size limit
    
    commit 1a7ed1ba4bba6c075d5ad61bb75e3fbc870840d6 upstream.
    
    The previous patch has limited swap file size so that large offsets cannot
    clear bits above MAX_PA/2 in the pte and interfere with L1TF mitigation.
    
    It assumed that offsets are encoded starting with bit 12, same as pfn. But
    on x86_64, offsets are encoded starting with bit 9.
    
    Thus the limit can be raised by 3 bits. That means 16TB with 42bit MAX_PA
    and 256TB with 46bit MAX_PA.
    
    Fixes: 377eeaa8e11f ("x86/speculation/l1tf: Limit swap file size to MAX_PA/2")
    Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5b44df38ed667231be3cb7e161f184d987fd819d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 5 14:00:11 2018 +0200

    x86/apic: Ignore secondary threads if nosmt=force
    
    commit 2207def700f902f169fc237b717252c326f9e464 upstream.
    
    nosmt on the kernel command line merely prevents the onlining of the
    secondary SMT siblings.
    
    nosmt=force makes the APIC detection code ignore the secondary SMT siblings
    completely, so they even do not show up as possible CPUs. That reduces the
    amount of memory allocations for per cpu variables and saves other
    resources from being allocated too large.
    
    This is not fully equivalent to disabling SMT in the BIOS because the low
    level SMT enabling in the BIOS can result in partitioning of resources
    between the siblings, which is not undone by just ignoring them. Some CPUs
    can use the full resources when their sibling is not onlined, but this is
    depending on the CPU family and model and it's not well documented whether
    this applies to all partitioned resources. That means depending on the
    workload disabling SMT in the BIOS might result in better performance.
    
    Linus analysis of the Intel manual:
    
      The intel optimization manual is not very clear on what the partitioning
      rules are.
    
      I find:
    
        "In general, the buffers for staging instructions between major pipe
         stages  are partitioned. These buffers include µop queues after the
         execution trace cache, the queues after the register rename stage, the
         reorder buffer which stages instructions for retirement, and the load
         and store buffers.
    
         In the case of load and store buffers, partitioning also provided an
         easier implementation to maintain memory ordering for each logical
         processor and detect memory ordering violations"
    
      but some of that partitioning may be relaxed if the HT thread is "not
      active":
    
        "In Intel microarchitecture code name Sandy Bridge, the micro-op queue
         is statically partitioned to provide 28 entries for each logical
         processor,  irrespective of software executing in single thread or
         multiple threads. If one logical processor is not active in Intel
         microarchitecture code name Ivy Bridge, then a single thread executing
         on that processor  core can use the 56 entries in the micro-op queue"
    
      but I do not know what "not active" means, and how dynamic it is. Some of
      that partitioning may be entirely static and depend on the early BIOS
      disabling of HT, and even if we park the cores, the resources will just be
      wasted.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 20d82bac6228aa3256243b7b49ca251ed90bd489
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 6 00:57:38 2018 +0200

    x86/cpu/AMD: Evaluate smp_num_siblings early
    
    commit 1e1d7e25fd759eddf96d8ab39d0a90a1979b2d8c upstream.
    
    To support force disabling of SMT it's required to know the number of
    thread siblings early. amd_get_topology() cannot be called before the APIC
    driver is selected, so split out the part which initializes
    smp_num_siblings and invoke it from amd_early_init().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f2444b280db88d2098193600eb37328786cc6d32
Author: Borislav Petkov <bp@suse.de>
Date:   Fri Jun 15 20:48:39 2018 +0200

    x86/CPU/AMD: Do not check CPUID max ext level before parsing SMP info
    
    commit 119bff8a9c9bb00116a844ec68be7bc4b1c768f5 upstream.
    
    Old code used to check whether CPUID ext max level is >= 0x80000008 because
    that last leaf contains the number of cores of the physical CPU.  The three
    functions called there now do not depend on that leaf anymore so the check
    can go.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dcf82399d6d1f2e3ee621cf4c87506574d348c39
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 6 01:00:55 2018 +0200

    x86/cpu/intel: Evaluate smp_num_siblings early
    
    commit 1910ad5624968f93be48e8e265513c54d66b897c upstream.
    
    Make use of the new early detection function to initialize smp_num_siblings
    on the boot cpu before the MP-Table or ACPI/MADT scan happens. That's
    required for force disabling SMT.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c3155990e210e1809cb14f87bc4b8d31ae7695a7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 6 00:55:39 2018 +0200

    x86/cpu/topology: Provide detect_extended_topology_early()
    
    commit 95f3d39ccf7aaea79d1ffdac1c887c2e100ec1b6 upstream.
    
    To support force disabling of SMT it's required to know the number of
    thread siblings early. detect_extended_topology() cannot be called before
    the APIC driver is selected, so split out the part which initializes
    smp_num_siblings.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b4be123b58ad452e04e1542d9d2a0c96d8e9df11
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 6 00:53:57 2018 +0200

    x86/cpu/common: Provide detect_ht_early()
    
    commit 545401f4448a807b963ff17b575e0a393e68b523 upstream.
    
    To support force disabling of SMT it's required to know the number of
    thread siblings early. detect_ht() cannot be called before the APIC driver
    is selected, so split out the part which initializes smp_num_siblings.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6886c1b815b81817d00c8d8af0a12cfa2b700e13
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 6 00:47:10 2018 +0200

    x86/cpu/AMD: Remove the pointless detect_ht() call
    
    commit 44ca36de56d1bf196dca2eb67cd753a46961ffe6 upstream.
    
    Real 32bit AMD CPUs do not have SMT and the only value of the call was to
    reach the magic printout which got removed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 49e0975a05f889cc2caa045168d24d658f801041
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 6 00:36:15 2018 +0200

    x86/cpu: Remove the pointless CPU printout
    
    commit 55e6d279abd92cfd7576bba031e7589be8475edb upstream.
    
    The value of this printout is dubious at best and there is no point in
    having it in two different places along with convoluted ways to reach it.
    
    Remove it completely.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 24d9fd272ec02eea118bf8cc36a0276087e4a23c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 29 17:48:27 2018 +0200

    cpu/hotplug: Provide knobs to control SMT
    
    commit 05736e4ac13c08a4a9b1ef2de26dd31a32cbee57 upstream.
    
    Provide a command line and a sysfs knob to control SMT.
    
    The command line options are:
    
     'nosmt':       Enumerate secondary threads, but do not online them
    
     'nosmt=force': Ignore secondary threads completely during enumeration
                    via MP table and ACPI/MADT.
    
    The sysfs control file has the following states (read/write):
    
     'on':           SMT is enabled. Secondary threads can be freely onlined
     'off':          SMT is disabled. Secondary threads, even if enumerated
                     cannot be onlined
     'forceoff':     SMT is permanentely disabled. Writes to the control
                     file are rejected.
     'notsupported': SMT is not supported by the CPU
    
    The command line option 'nosmt' sets the sysfs control to 'off'. This
    can be changed to 'on' to reenable SMT during runtime.
    
    The command line option 'nosmt=force' sets the sysfs control to
    'forceoff'. This cannot be changed during runtime.
    
    When SMT is 'on' and the control file is changed to 'off' then all online
    secondary threads are offlined and attempts to online a secondary thread
    later on are rejected.
    
    When SMT is 'off' and the control file is changed to 'on' then secondary
    threads can be onlined again. The 'off' -> 'on' transition does not
    automatically online the secondary threads.
    
    When the control file is set to 'forceoff', the behaviour is the same as
    setting it to 'off', but the operation is irreversible and later writes to
    the control file are rejected.
    
    When the control status is 'notsupported' then writes to the control file
    are rejected.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 74f1c7a26b6064f278a9f2ae0c30d4c23955e835
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 29 17:49:05 2018 +0200

    cpu/hotplug: Split do_cpu_down()
    
    commit cc1fe215e1efa406b03aa4389e6269b61342dec5 upstream.
    
    Split out the inner workings of do_cpu_down() to allow reuse of that
    function for the upcoming SMT disabling mechanism.
    
    No functional change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6249d3232f222d454a4da3e6ac7efd01137f8400
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 29 19:05:25 2018 +0200

    cpu/hotplug: Make bringup/teardown of smp threads symmetric
    
    commit c4de65696d865c225fda3b9913b31284ea65ea96 upstream.
    
    The asymmetry caused a warning to trigger if the bootup was stopped in state
    CPUHP_AP_ONLINE_IDLE. The warning no longer triggers as kthread_park() can
    now be invoked on already or still parked threads. But there is still no
    reason to have this be asymmetric.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2883a1f89b50caa8dc1a6cc73d35c8b4642eae20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 21 10:37:20 2018 +0200

    x86/topology: Provide topology_smt_supported()
    
    commit f048c399e0f7490ab7296bc2c255d37eb14a9675 upstream.
    
    Provide information whether SMT is supoorted by the CPUs. Preparatory patch
    for SMT control mechanism.
    
    Suggested-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit aa5de56185a07b1d32f90e1d23a6d4b56fb04a24
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 29 17:50:22 2018 +0200

    x86/smp: Provide topology_is_primary_thread()
    
    commit 6a4d2657e048f096c7ffcad254010bd94891c8c0 upstream.
    
    If the CPU is supporting SMT then the primary thread can be found by
    checking the lower APIC ID bits for zero. smp_num_siblings is used to build
    the mask for the APIC ID bits which need to be taken into account.
    
    This uses the MPTABLE or ACPI/MADT supplied APIC ID, which can be different
    than the initial APIC ID in CPUID. But according to AMD the lower bits have
    to be consistent. Intel gave a tentative confirmation as well.
    
    Preparatory patch to support disabling SMT at boot/runtime.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 71ef4580dc21eebd43a8b22a372fce2e28235728
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue May 29 16:43:46 2018 +0200

    sched/smt: Update sched_smt_present at runtime
    
    commit ba2591a5993eabcc8e874e30f361d8ffbb10d6d4 upstream.
    
    The static key sched_smt_present is only updated at boot time when SMT
    siblings have been detected. Booting with maxcpus=1 and bringing the
    siblings online after boot rebuilds the scheduling domains correctly but
    does not update the static key, so the SMT code is not enabled.
    
    Let the key be updated in the scheduler CPU hotplug code to fix this.
    
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 89d8157a3920663bac6e29e6f8086916c3796be5
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Jun 20 16:42:57 2018 -0400

    x86/bugs: Move the l1tf function and define pr_fmt properly
    
    commit 56563f53d3066afa9e63d6c997bf67e76a8b05c0 upstream.
    
    The pr_warn in l1tf_select_mitigation would have used the prior pr_fmt
    which was defined as "Spectre V2 : ".
    
    Move the function to be past SSBD and also define the pr_fmt.
    
    Fixes: 17dbca119312 ("x86/speculation/l1tf: Add sysfs reporting for l1tf")
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1655bd148c1b0ee24d1810b8a0121d3680d3065e
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Jun 13 15:48:28 2018 -0700

    x86/speculation/l1tf: Limit swap file size to MAX_PA/2
    
    commit 377eeaa8e11fe815b1d07c81c4a0e2843a8c15eb upstream.
    
    For the L1TF workaround its necessary to limit the swap file size to below
    MAX_PA/2, so that the higher bits of the swap offset inverted never point
    to valid memory.
    
    Add a mechanism for the architecture to override the swap file size check
    in swapfile.c and add a x86 specific max swapfile check function that
    enforces that limit.
    
    The check is only enabled if the CPU is vulnerable to L1TF.
    
    In VMs with 42bit MAX_PA the typical limit is 2TB now, on a native system
    with 46bit PA it is 32TB. The limit is only per individual swap file, so
    it's always possible to exceed these limits with multiple swap files or
    partitions.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9870e755711b6ce8db667aacd15cefa5d62437f9
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Jun 13 15:48:27 2018 -0700

    x86/speculation/l1tf: Disallow non privileged high MMIO PROT_NONE mappings
    
    commit 42e4089c7890725fcd329999252dc489b72f2921 upstream.
    
    For L1TF PROT_NONE mappings are protected by inverting the PFN in the page
    table entry. This sets the high bits in the CPU's address space, thus
    making sure to point to not point an unmapped entry to valid cached memory.
    
    Some server system BIOSes put the MMIO mappings high up in the physical
    address space. If such an high mapping was mapped to unprivileged users
    they could attack low memory by setting such a mapping to PROT_NONE. This
    could happen through a special device driver which is not access
    protected. Normal /dev/mem is of course access protected.
    
    To avoid this forbid PROT_NONE mappings or mprotect for high MMIO mappings.
    
    Valid page mappings are allowed because the system is then unsafe anyways.
    
    It's not expected that users commonly use PROT_NONE on MMIO. But to
    minimize any impact this is only enforced if the mapping actually refers to
    a high MMIO address (defined as the MAX_PA-1 bit being set), and also skip
    the check for root.
    
    For mmaps this is straight forward and can be handled in vm_insert_pfn and
    in remap_pfn_range().
    
    For mprotect it's a bit trickier. At the point where the actual PTEs are
    accessed a lot of state has been changed and it would be difficult to undo
    on an error. Since this is a uncommon case use a separate early page talk
    walk pass for MMIO PROT_NONE mappings that checks for this condition
    early. For non MMIO and non PROT_NONE there are no changes.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dcd1b1099b59cef17fdd5f90ee564e7b304619c2
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Jun 13 15:48:26 2018 -0700

    x86/speculation/l1tf: Add sysfs reporting for l1tf
    
    commit 17dbca119312b4e8173d4e25ff64262119fcef38 upstream.
    
    L1TF core kernel workarounds are cheap and normally always enabled, However
    they still should be reported in sysfs if the system is vulnerable or
    mitigated. Add the necessary CPU feature/bug bits.
    
    - Extend the existing checks for Meltdowns to determine if the system is
      vulnerable. All CPUs which are not vulnerable to Meltdown are also not
      vulnerable to L1TF
    
    - Check for 32bit non PAE and emit a warning as there is no practical way
      for mitigation due to the limited physical address bits
    
    - If the system has more than MAX_PA/2 physical memory the invert page
      workarounds don't protect the system against the L1TF attack anymore,
      because an inverted physical address will also point to valid
      memory. Print a warning in this case and report that the system is
      vulnerable.
    
    Add a function which returns the PFN limit for the L1TF mitigation, which
    will be used in follow up patches for sanity and range checks.
    
    [ tglx: Renamed the CPU feature bit to L1TF_PTEINV ]
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit adb3336455817311300e3414367c6f18eb8a5d95
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Jun 13 15:48:25 2018 -0700

    x86/speculation/l1tf: Make sure the first page is always reserved
    
    commit 10a70416e1f067f6c4efda6ffd8ea96002ac4223 upstream.
    
    The L1TF workaround doesn't make any attempt to mitigate speculate accesses
    to the first physical page for zeroed PTEs. Normally it only contains some
    data from the early real mode BIOS.
    
    It's not entirely clear that the first page is reserved in all
    configurations, so add an extra reservation call to make sure it is really
    reserved. In most configurations (e.g.  with the standard reservations)
    it's likely a nop.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0c5e6259358e9a5eb07b53f9ee21f93ab85fe44f
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Jun 13 15:48:24 2018 -0700

    x86/speculation/l1tf: Protect PROT_NONE PTEs against speculation
    
    commit 6b28baca9b1f0d4a42b865da7a05b1c81424bd5c upstream.
    
    When PTEs are set to PROT_NONE the kernel just clears the Present bit and
    preserves the PFN, which creates attack surface for L1TF speculation
    speculation attacks.
    
    This is important inside guests, because L1TF speculation bypasses physical
    page remapping. While the host has its own migitations preventing leaking
    data from other VMs into the guest, this would still risk leaking the wrong
    page inside the current guest.
    
    This uses the same technique as Linus' swap entry patch: while an entry is
    is in PROTNONE state invert the complete PFN part part of it. This ensures
    that the the highest bit will point to non existing memory.
    
    The invert is done by pte/pmd_modify and pfn/pmd/pud_pte for PROTNONE and
    pte/pmd/pud_pfn undo it.
    
    This assume that no code path touches the PFN part of a PTE directly
    without using these primitives.
    
    This doesn't handle the case that MMIO is on the top of the CPU physical
    memory. If such an MMIO region was exposed by an unpriviledged driver for
    mmap it would be possible to attack some real memory.  However this
    situation is all rather unlikely.
    
    For 32bit non PAE the inversion is not done because there are really not
    enough bits to protect anything.
    
    Q: Why does the guest need to be protected when the HyperVisor already has
       L1TF mitigations?
    
    A: Here's an example:
    
       Physical pages 1 2 get mapped into a guest as
       GPA 1 -> PA 2
       GPA 2 -> PA 1
       through EPT.
    
       The L1TF speculation ignores the EPT remapping.
    
       Now the guest kernel maps GPA 1 to process A and GPA 2 to process B, and
       they belong to different users and should be isolated.
    
       A sets the GPA 1 PA 2 PTE to PROT_NONE to bypass the EPT remapping and
       gets read access to the underlying physical page. Which in this case
       points to PA 2, so it can read process B's data, if it happened to be in
       L1, so isolation inside the guest is broken.
    
       There's nothing the hypervisor can do about this. This mitigation has to
       be done in the guest itself.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Acked-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 056dc0fa4c114901b036eee50ac209943e0efa7b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 13 15:48:23 2018 -0700

    x86/speculation/l1tf: Protect swap entries against L1TF
    
    commit 2f22b4cd45b67b3496f4aa4c7180a1271c6452f6 upstream.
    
    With L1 terminal fault the CPU speculates into unmapped PTEs, and resulting
    side effects allow to read the memory the PTE is pointing too, if its
    values are still in the L1 cache.
    
    For swapped out pages Linux uses unmapped PTEs and stores a swap entry into
    them.
    
    To protect against L1TF it must be ensured that the swap entry is not
    pointing to valid memory, which requires setting higher bits (between bit
    36 and bit 45) that are inside the CPUs physical address space, but outside
    any real memory.
    
    To do this invert the offset to make sure the higher bits are always set,
    as long as the swap file is not too big.
    
    Note there is no workaround for 32bit !PAE, or on systems which have more
    than MAX_PA/2 worth of memory. The later case is very unlikely to happen on
    real systems.
    
    [AK: updated description and minor tweaks by. Split out from the original
         patch ]
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Andi Kleen <ak@linux.intel.com>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Acked-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit db279f71938540f01cc6dea834ac67a0e7c02e7b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 13 15:48:22 2018 -0700

    x86/speculation/l1tf: Change order of offset/type in swap entry
    
    commit bcd11afa7adad8d720e7ba5ef58bdcd9775cf45f upstream.
    
    If pages are swapped out, the swap entry is stored in the corresponding
    PTE, which has the Present bit cleared. CPUs vulnerable to L1TF speculate
    on PTE entries which have the present bit set and would treat the swap
    entry as phsyical address (PFN). To mitigate that the upper bits of the PTE
    must be set so the PTE points to non existent memory.
    
    The swap entry stores the type and the offset of a swapped out page in the
    PTE. type is stored in bit 9-13 and offset in bit 14-63. The hardware
    ignores the bits beyond the phsyical address space limit, so to make the
    mitigation effective its required to start 'offset' at the lowest possible
    bit so that even large swap offsets do not reach into the physical address
    space limit bits.
    
    Move offset to bit 9-58 and type to bit 59-63 which are the bits that
    hardware generally doesn't care about.
    
    That, in turn, means that if you on desktop chip with only 40 bits of
    physical addressing, now that the offset starts at bit 9, there needs to be
    30 bits of offset actually *in use* until bit 39 ends up being set, which
    means when inverted it will again point into existing memory.
    
    So that's 4 terabyte of swap space (because the offset is counted in pages,
    so 30 bits of offset is 42 bits of actual coverage). With bigger physical
    addressing, that obviously grows further, until the limit of the offset is
    hit (at 50 bits of offset - 62 bits of actual swap file coverage).
    
    This is a preparatory change for the actual swap entry inversion to protect
    against L1TF.
    
    [ AK: Updated description and minor tweaks. Split into two parts ]
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Andi Kleen <ak@linux.intel.com>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Acked-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1e56c506b35b5d3ac16f58953390b67edd302734
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Jun 13 15:48:21 2018 -0700

    x86/speculation/l1tf: Increase 32bit PAE __PHYSICAL_PAGE_SHIFT
    
    commit 50896e180c6aa3a9c61a26ced99e15d602666a4c upstream.
    
    L1 Terminal Fault (L1TF) is a speculation related vulnerability. The CPU
    speculates on PTE entries which do not have the PRESENT bit set, if the
    content of the resulting physical address is available in the L1D cache.
    
    The OS side mitigation makes sure that a !PRESENT PTE entry points to a
    physical address outside the actually existing and cachable memory
    space. This is achieved by inverting the upper bits of the PTE. Due to the
    address space limitations this only works for 64bit and 32bit PAE kernels,
    but not for 32bit non PAE.
    
    This mitigation applies to both host and guest kernels, but in case of a
    64bit host (hypervisor) and a 32bit PAE guest, inverting the upper bits of
    the PAE address space (44bit) is not enough if the host has more than 43
    bits of populated memory address space, because the speculation treats the
    PTE content as a physical host address bypassing EPT.
    
    The host (hypervisor) protects itself against the guest by flushing L1D as
    needed, but pages inside the guest are not protected against attacks from
    other processes inside the same guest.
    
    For the guest the inverted PTE mask has to match the host to provide the
    full protection for all pages the host could possibly map into the
    guest. The hosts populated address space is not known to the guest, so the
    mask must cover the possible maximal host address space, i.e. 52 bit.
    
    On 32bit PAE the maximum PTE mask is currently set to 44 bit because that
    is the limit imposed by 32bit unsigned long PFNs in the VMs. This limits
    the mask to be below what the host could possible use for physical pages.
    
    The L1TF PROT_NONE protection code uses the PTE masks to determine which
    bits to invert to make sure the higher bits are set for unmapped entries to
    prevent L1TF speculation attacks against EPT inside guests.
    
    In order to invert all bits that could be used by the host, increase
    __PHYSICAL_PAGE_SHIFT to 52 to match 64bit.
    
    The real limit for a 32bit PAE kernel is still 44 bits because all Linux
    PTEs are created from unsigned long PFNs, so they cannot be higher than 44
    bits on a 32bit kernel. So these extra PFN bits should be never set. The
    only users of this macro are using it to look at PTEs, so it's safe.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Dave Hansen <dave.hansen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 45db516a6a1bbf8bfa8dd4cef5ac572c97f9fa32
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Fri Aug 3 10:05:50 2018 -0700

    x86/irqflags: Provide a declaration for native_save_fl
    
    commit 208cbb32558907f68b3b2a081ca2337ac3744794 upstream.
    
    It was reported that the commit d0a8d9378d16 is causing users of gcc < 4.9
    to observe -Werror=missing-prototypes errors.
    
    Indeed, it seems that:
    extern inline unsigned long native_save_fl(void) { return 0; }
    
    compiled with -Werror=missing-prototypes produces this warning in gcc <
    4.9, but not gcc >= 4.9.
    
    Fixes: d0a8d9378d16 ("x86/paravirt: Make native_save_fl() extern inline").
    Reported-by: David Laight <david.laight@aculab.com>
    Reported-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: hpa@zytor.com
    Cc: jgross@suse.com
    Cc: kstewart@linuxfoundation.org
    Cc: gregkh@linuxfoundation.org
    Cc: boris.ostrovsky@oracle.com
    Cc: astrachan@google.com
    Cc: mka@chromium.org
    Cc: arnd@arndb.de
    Cc: tstellar@redhat.com
    Cc: sedat.dilek@gmail.com
    Cc: David.Laight@aculab.com
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20180803170550.164688-1-ndesaulniers@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 16fe09de5432a10e0473b8f3055669cf14fe3fbc
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Sat Apr 28 21:37:03 2018 +0900

    kprobes/x86: Fix %p uses in error messages
    
    commit 0ea063306eecf300fcf06d2f5917474b580f666f upstream.
    
    Remove all %p uses in error messages in kprobes/x86.
    
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: David Howells <dhowells@redhat.com>
    Cc: David S . Miller <davem@davemloft.net>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Jon Medhurst <tixy@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thomas Richter <tmricht@linux.ibm.com>
    Cc: Tobin C . Harding <me@tobin.cc>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: acme@kernel.org
    Cc: akpm@linux-foundation.org
    Cc: brueckner@linux.vnet.ibm.com
    Cc: linux-arch@vger.kernel.org
    Cc: rostedt@goodmis.org
    Cc: schwidefsky@de.ibm.com
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/lkml/152491902310.9916.13355297638917767319.stgit@devbox
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f8a0aeefc2f6e1bfd6653fcc30453ce7e582fac8
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Jul 26 13:14:55 2018 +0200

    x86/speculation: Protect against userspace-userspace spectreRSB
    
    commit fdf82a7856b32d905c39afc85e34364491e46346 upstream.
    
    The article "Spectre Returns! Speculation Attacks using the Return Stack
    Buffer" [1] describes two new (sub-)variants of spectrev2-like attacks,
    making use solely of the RSB contents even on CPUs that don't fallback to
    BTB on RSB underflow (Skylake+).
    
    Mitigate userspace-userspace attacks by always unconditionally filling RSB on
    context switch when the generic spectrev2 mitigation has been enabled.
    
    [1] https://arxiv.org/pdf/1807.07940.pdf
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Tim Chen <tim.c.chen@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Woodhouse <dwmw@amazon.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/nycvar.YFH.7.76.1807261308190.997@cbobk.fhfr.pm
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b13b271933eea6161e741825487d6e73e800bedf
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Aug 3 16:41:39 2018 +0200

    x86/paravirt: Fix spectre-v2 mitigations for paravirt guests
    
    commit 5800dc5c19f34e6e03b5adab1282535cb102fafd upstream.
    
    Nadav reported that on guests we're failing to rewrite the indirect
    calls to CALLEE_SAVE paravirt functions. In particular the
    pv_queued_spin_unlock() call is left unpatched and that is all over the
    place. This obviously wrecks Spectre-v2 mitigation (for paravirt
    guests) which relies on not actually having indirect calls around.
    
    The reason is an incorrect clobber test in paravirt_patch_call(); this
    function rewrites an indirect call with a direct call to the _SAME_
    function, there is no possible way the clobbers can be different
    because of this.
    
    Therefore remove this clobber check. Also put WARNs on the other patch
    failure case (not enough room for the instruction) which I've not seen
    trigger in my (limited) testing.
    
    Three live kernel image disassemblies for lock_sock_nested (as a small
    function that illustrates the problem nicely). PRE is the current
    situation for guests, POST is with this patch applied and NATIVE is with
    or without the patch for !guests.
    
    PRE:
    
    (gdb) disassemble lock_sock_nested
    Dump of assembler code for function lock_sock_nested:
       0xffffffff817be970 <+0>:     push   %rbp
       0xffffffff817be971 <+1>:     mov    %rdi,%rbp
       0xffffffff817be974 <+4>:     push   %rbx
       0xffffffff817be975 <+5>:     lea    0x88(%rbp),%rbx
       0xffffffff817be97c <+12>:    callq  0xffffffff819f7160 <_cond_resched>
       0xffffffff817be981 <+17>:    mov    %rbx,%rdi
       0xffffffff817be984 <+20>:    callq  0xffffffff819fbb00 <_raw_spin_lock_bh>
       0xffffffff817be989 <+25>:    mov    0x8c(%rbp),%eax
       0xffffffff817be98f <+31>:    test   %eax,%eax
       0xffffffff817be991 <+33>:    jne    0xffffffff817be9ba <lock_sock_nested+74>
       0xffffffff817be993 <+35>:    movl   $0x1,0x8c(%rbp)
       0xffffffff817be99d <+45>:    mov    %rbx,%rdi
       0xffffffff817be9a0 <+48>:    callq  *0xffffffff822299e8
       0xffffffff817be9a7 <+55>:    pop    %rbx
       0xffffffff817be9a8 <+56>:    pop    %rbp
       0xffffffff817be9a9 <+57>:    mov    $0x200,%esi
       0xffffffff817be9ae <+62>:    mov    $0xffffffff817be993,%rdi
       0xffffffff817be9b5 <+69>:    jmpq   0xffffffff81063ae0 <__local_bh_enable_ip>
       0xffffffff817be9ba <+74>:    mov    %rbp,%rdi
       0xffffffff817be9bd <+77>:    callq  0xffffffff817be8c0 <__lock_sock>
       0xffffffff817be9c2 <+82>:    jmp    0xffffffff817be993 <lock_sock_nested+35>
    End of assembler dump.
    
    POST:
    
    (gdb) disassemble lock_sock_nested
    Dump of assembler code for function lock_sock_nested:
       0xffffffff817be970 <+0>:     push   %rbp
       0xffffffff817be971 <+1>:     mov    %rdi,%rbp
       0xffffffff817be974 <+4>:     push   %rbx
       0xffffffff817be975 <+5>:     lea    0x88(%rbp),%rbx
       0xffffffff817be97c <+12>:    callq  0xffffffff819f7160 <_cond_resched>
       0xffffffff817be981 <+17>:    mov    %rbx,%rdi
       0xffffffff817be984 <+20>:    callq  0xffffffff819fbb00 <_raw_spin_lock_bh>
       0xffffffff817be989 <+25>:    mov    0x8c(%rbp),%eax
       0xffffffff817be98f <+31>:    test   %eax,%eax
       0xffffffff817be991 <+33>:    jne    0xffffffff817be9ba <lock_sock_nested+74>
       0xffffffff817be993 <+35>:    movl   $0x1,0x8c(%rbp)
       0xffffffff817be99d <+45>:    mov    %rbx,%rdi
       0xffffffff817be9a0 <+48>:    callq  0xffffffff810a0c20 <__raw_callee_save___pv_queued_spin_unlock>
       0xffffffff817be9a5 <+53>:    xchg   %ax,%ax
       0xffffffff817be9a7 <+55>:    pop    %rbx
       0xffffffff817be9a8 <+56>:    pop    %rbp
       0xffffffff817be9a9 <+57>:    mov    $0x200,%esi
       0xffffffff817be9ae <+62>:    mov    $0xffffffff817be993,%rdi
       0xffffffff817be9b5 <+69>:    jmpq   0xffffffff81063aa0 <__local_bh_enable_ip>
       0xffffffff817be9ba <+74>:    mov    %rbp,%rdi
       0xffffffff817be9bd <+77>:    callq  0xffffffff817be8c0 <__lock_sock>
       0xffffffff817be9c2 <+82>:    jmp    0xffffffff817be993 <lock_sock_nested+35>
    End of assembler dump.
    
    NATIVE:
    
    (gdb) disassemble lock_sock_nested
    Dump of assembler code for function lock_sock_nested:
       0xffffffff817be970 <+0>:     push   %rbp
       0xffffffff817be971 <+1>:     mov    %rdi,%rbp
       0xffffffff817be974 <+4>:     push   %rbx
       0xffffffff817be975 <+5>:     lea    0x88(%rbp),%rbx
       0xffffffff817be97c <+12>:    callq  0xffffffff819f7160 <_cond_resched>
       0xffffffff817be981 <+17>:    mov    %rbx,%rdi
       0xffffffff817be984 <+20>:    callq  0xffffffff819fbb00 <_raw_spin_lock_bh>
       0xffffffff817be989 <+25>:    mov    0x8c(%rbp),%eax
       0xffffffff817be98f <+31>:    test   %eax,%eax
       0xffffffff817be991 <+33>:    jne    0xffffffff817be9ba <lock_sock_nested+74>
       0xffffffff817be993 <+35>:    movl   $0x1,0x8c(%rbp)
       0xffffffff817be99d <+45>:    mov    %rbx,%rdi
       0xffffffff817be9a0 <+48>:    movb   $0x0,(%rdi)
       0xffffffff817be9a3 <+51>:    nopl   0x0(%rax)
       0xffffffff817be9a7 <+55>:    pop    %rbx
       0xffffffff817be9a8 <+56>:    pop    %rbp
       0xffffffff817be9a9 <+57>:    mov    $0x200,%esi
       0xffffffff817be9ae <+62>:    mov    $0xffffffff817be993,%rdi
       0xffffffff817be9b5 <+69>:    jmpq   0xffffffff81063ae0 <__local_bh_enable_ip>
       0xffffffff817be9ba <+74>:    mov    %rbp,%rdi
       0xffffffff817be9bd <+77>:    callq  0xffffffff817be8c0 <__lock_sock>
       0xffffffff817be9c2 <+82>:    jmp    0xffffffff817be993 <lock_sock_nested+35>
    End of assembler dump.
    
    
    Fixes: 63f70270ccd9 ("[PATCH] i386: PARAVIRT: add common patching machinery")
    Fixes: 3010a0663fd9 ("x86/paravirt, objtool: Annotate indirect calls")
    Reported-by: Nadav Amit <namit@vmware.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
