commit 449959917f0c01953562a04afef5ed4ea2ca641e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Mar 19 13:10:58 2019 +0100

    Linux 5.0.3

commit 847c02bcb48a17a09b620bfc36b57195ae047cbf
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Jan 7 12:41:46 2019 -0500

    drm: Block fb changes for async plane updates
    
    commit 25dc194b34dd5919dd07b8873ee338182e15df9d upstream.
    
    The prepare_fb call always happens on new_plane_state.
    
    The drm_atomic_helper_cleanup_planes checks to see if
    plane state pointer has changed when deciding to call cleanup_fb on
    either the new_plane_state or the old_plane_state.
    
    For a non-async atomic commit the state pointer is swapped, so this
    helper calls prepare_fb on the new_plane_state and cleanup_fb on the
    old_plane_state. This makes sense, since we want to prepare the
    framebuffer we are going to use and cleanup the the framebuffer we are
    no longer using.
    
    For the async atomic update helpers this differs. The async atomic
    update helpers perform in-place updates on the existing state. They call
    drm_atomic_helper_cleanup_planes but the state pointer is not swapped.
    This means that prepare_fb is called on the new_plane_state and
    cleanup_fb is called on the new_plane_state (not the old).
    
    In the case where old_plane_state->fb == new_plane_state->fb then
    there should be no behavioral difference between an async update
    and a non-async commit. But there are issues that arise when
    old_plane_state->fb != new_plane_state->fb.
    
    The first is that the new_plane_state->fb is immediately cleaned up
    after it has been prepared, so we're using a fb that we shouldn't
    be.
    
    The second occurs during a sequence of async atomic updates and
    non-async regular atomic commits. Suppose there are two framebuffers
    being interleaved in a double-buffering scenario, fb1 and fb2:
    
    - Async update, oldfb = NULL, newfb = fb1, prepare fb1, cleanup fb1
    - Async update, oldfb = fb1, newfb = fb2, prepare fb2, cleanup fb2
    - Non-async commit, oldfb = fb2, newfb = fb1, prepare fb1, cleanup fb2
    
    We call cleanup_fb on fb2 twice in this example scenario, and any
    further use will result in use-after-free.
    
    The simple fix to this problem is to block framebuffer changes
    in the drm_atomic_helper_async_check function for now.
    
    v2: Move check by itself, add a FIXME (Daniel)
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Harry Wentland <harry.wentland@amd.com>
    Cc: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Cc: <stable@vger.kernel.org> # v4.14+
    Fixes: fef9df8b5945 ("drm/atomic: initial support for asynchronous plane update")
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Acked-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Link: https://patchwork.freedesktop.org/patch/275364/
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a516031202041d880579fd26935e47a105bdeb89
Author: Xiao Ni <xni@redhat.com>
Date:   Fri Mar 8 23:52:05 2019 +0800

    It's wrong to add len to sector_nr in raid10 reshape twice
    
    commit b761dcf1217760a42f7897c31dcb649f59b2333e upstream.
    
    In reshape_request it already adds len to sector_nr already. It's wrong to add len to
    sector_nr again after adding pages to bio. If there is bad block it can't copy one chunk
    at a time, it needs to goto read_more. Now the sector_nr is wrong. It can cause data
    corruption.
    
    Cc: stable@vger.kernel.org # v3.16+
    Signed-off-by: Xiao Ni <xni@redhat.com>
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0912fa3dfceab294ebad311fbde7ac71dec56e15
Author: kbuild test robot <lkp@intel.com>
Date:   Thu Mar 14 02:42:43 2019 +0800

    perf/x86/intel: Make dev_attr_allow_tsx_force_abort static
    
    commit c634dc6bdedeb0b2c750fc611612618a85639ab2 upstream.
    
    Fixes: 400816f60c54 ("perf/x86/intel: Implement support for TSX Force Abort")
    Signed-off-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "Peter Zijlstra (Intel)" <peterz@infradead.org>
    Cc: kbuild-all@01.org
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Kan Liang <kan.liang@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190313184243.GA10820@lkp-sb-ep06
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c075798c05d913d20d53ca0eabd36f53f9c7328d
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 14 14:01:14 2019 +0100

    perf/x86/intel: Fix memory corruption
    
    commit ede271b059463731cbd6dffe55ffd70d7dbe8392 upstream.
    
    Through:
    
      validate_event()
        x86_pmu.get_event_constraints(.idx=-1)
          tfa_get_event_constraints()
            dyn_constraint()
    
    cpuc->constraint_list[-1] is used, which is an obvious out-of-bound access.
    
    In this case, simply skip the TFA constraint code, there is no event
    constraint with just PMC3, therefore the code will never result in the
    empty set.
    
    Fixes: 400816f60c54 ("perf/x86/intel: Implement support for TSX Force Abort")
    Reported-by: Tony Jones <tonyj@suse.com>
    Reported-by: "DSouza, Nelson" <nelson.dsouza@intel.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Tony Jones <tonyj@suse.com>
    Tested-by: "DSouza, Nelson" <nelson.dsouza@intel.com>
    Cc: eranian@google.com
    Cc: jolsa@redhat.com
    Cc: stable@kernel.org
    Link: https://lkml.kernel.org/r/20190314130705.441549378@infradead.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 291ad91aad03edf5483350a1997a468ce17010da
Author: Jian-Hong Pan <jian-hong@endlessm.com>
Date:   Wed Mar 13 17:33:24 2019 +0800

    ALSA: hda/realtek: Enable headset MIC of Acer TravelMate X514-51T with ALC255
    
    commit cbc05fd6708c1744ee6a61cb4c461ff956d30524 upstream.
    
    The Acer TravelMate X514-51T with ALC255 cannot detect the headset MIC
    until ALC255_FIXUP_ACER_HEADSET_MIC quirk applied.  Although, the
    internal DMIC uses another module - snd_soc_skl as the driver.  We still
    need the NID 0x1a in the quirk to enable the headset MIC.
    
    Signed-off-by: Jian-Hong Pan <jian-hong@endlessm.com>
    Signed-off-by: Kailang Yang <kailang@realtek.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 843a9a5b5675e72814a4e18cbce2ed7c2a077032
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 20 16:15:45 2019 +0100

    ALSA: hda/realtek - Reduce click noise on Dell Precision 5820 headphone
    
    commit c0ca5eced22215c1e03e3ad479f8fab0bbb30772 upstream.
    
    Dell Precision 5820 with ALC3234 codec (which is equivalent with
    ALC255) shows click noises at (runtime) PM resume on the headphone.
    The biggest source of the noise comes from the cleared headphone pin
    control at resume, which is done via the standard shutup procedure.
    
    Although we have an override of the standard shutup callback to
    replace with NOP, this would skip other needed stuff (e.g. the pull
    down of headset power).  So, instead, this "fixes" the behavior of
    alc_fixup_no_shutup() by introducing spec->no_shutup_pins flag.
    When this flag is set, Realtek codec won't call the standard
    snd_hda_shutup_pins() & co.  Now alc_fixup_no_shutup() just sets this
    flag instead of overriding spec->shutup callback itself.  This allows
    us to apply the similar fix for other entries easily if needed in
    future.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6f63adaf88816b72f74b22aaa40d55fab993c572
Author: Jian-Hong Pan <jian-hong@endlessm.com>
Date:   Thu Feb 21 17:00:18 2019 +0800

    ALSA: hda/realtek: Enable audio jacks of ASUS UX362FA with ALC294
    
    commit 8bb37a2a4d7c02affef554f5dc05f6d2e39c31f9 upstream.
    
    The ASUS UX362FA with ALC294 cannot detect the headset MIC and outputs
    through the internal speaker and the headphone.  This issue can be fixed
    by the quirk in the commit 4e0511067 ALSA: hda/realtek: Enable audio
    jacks of ASUS UX533FD with ALC294.
    
    Besides, ASUS UX362FA and UX533FD have the same audio initial pin config
    values.  So, this patch replaces SND_PCI_QUIRK of UX533FD with a new
    SND_HDA_PIN_QUIRK which benefits both UX362FA and UX533FD.
    
    Fixes: 4e051106730d ("ALSA: hda/realtek: Enable audio jacks of ASUS UX533FD with ALC294")
    Signed-off-by: Jian-Hong Pan <jian-hong@endlessm.com>
    Signed-off-by: Ming Shuo Chiu <chiu@endlessm.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 19fcfe5ad57c99f218c1fb515747f05e5976e2e6
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Mar 13 13:40:15 2019 +0100

    ALSA: hda - add more quirks for HP Z2 G4 and HP Z240
    
    commit 167897f4b32c2bc18b3b6183029a33fb420a114e upstream.
    
    Apply the HP_MIC_NO_PRESENCE fixups for the more HP Z2 G4 and
    HP Z240 models.
    
    Reported-by: Jeff Burrell <jeff.burrell@hp.com>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f36b6691acdd6687a0027d8c821a9a5be9160824
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 25 16:49:27 2019 +0100

    ALSA: hda: Extend i915 component bind timeout
    
    commit cfc35f9c128cea8fce6a5513b1de50d36f3b209f upstream.
    
    I set 10 seconds for the timeout of the i915 audio component binding
    with a hope that recent machines are fast enough to handle all probe
    tasks in that period, but I was too optimistic.  The binding may take
    longer than that, and this caused a problem on the machine with both
    audio and graphics driver modules loaded in parallel, as Paul Menzel
    experienced.  This problem haven't hit so often just because the KMS
    driver is loaded in initrd on most machines.
    
    As a simple workaround, extend the timeout to 60 seconds.
    
    Fixes: f9b54e1961c7 ("ALSA: hda/i915: Allow delayed i915 audio component binding")
    Reported-by: Paul Menzel <pmenzel+alsa-devel@molgen.mpg.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 69bf155eec9e19d3f724281c2349be8e54665460
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Feb 26 13:38:37 2019 +0900

    ALSA: firewire-motu: fix construction of PCM frame for capture direction
    
    commit f97a0944a72b26a2bece72516294e112a890f98a upstream.
    
    In data blocks of common isochronous packet for MOTU devices, PCM
    frames are multiplexed in a shape of '24 bit * 4 Audio Pack', described
    in IEC 61883-6. The frames are not aligned to quadlet.
    
    For capture PCM substream, ALSA firewire-motu driver constructs PCM
    frames by reading data blocks byte-by-byte. However this operation
    includes bug for lower byte of the PCM sample. This brings invalid
    content of the PCM samples.
    
    This commit fixes the bug.
    
    Reported-by: Peter Sjöberg <autopeter@gmail.com>
    Cc: <stable@vger.kernel.org> # v4.12+
    Fixes: 4641c9394010 ("ALSA: firewire-motu: add MOTU specific protocol layer")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b072cb42f01eae65d2fafa33e0c9902b3d1d9fed
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Feb 26 13:38:16 2019 +0900

    ALSA: bebob: use more identical mod_alias for Saffire Pro 10 I/O against Liquid Saffire 56
    
    commit 7dc661bd8d3261053b69e4e2d0050cd1ee540fc1 upstream.
    
    ALSA bebob driver has an entry for Focusrite Saffire Pro 10 I/O. The
    entry matches vendor_id in root directory and model_id in unit
    directory of configuration ROM for IEEE 1394 bus.
    
    On the other hand, configuration ROM of Focusrite Liquid Saffire 56
    has the same vendor_id and model_id. This device is an application of
    TCAT Dice (TCD2220 a.k.a Dice Jr.) however ALSA bebob driver can be
    bound to it randomly instead of ALSA dice driver. At present, drivers
    in ALSA firewire stack can not handle this situation appropriately.
    
    This commit uses more identical mod_alias for Focusrite Saffire Pro 10
    I/O in ALSA bebob driver.
    
    $ python2 crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  042a829d  bus_info_length 4, crc_length 42, crc 33437
    404  31333934  bus_name "1394"
    408  f0649222  irmc 1, cmc 1, isc 1, bmc 1, pmc 0, cyc_clk_acc 100,
                   max_rec 9 (1024), max_rom 2, gen 2, spd 2 (S400)
    40c  00130e01  company_id 00130e     |
    410  000606e0  device_id 01000606e0  | EUI-64 00130e01000606e0
    
                   root directory
                   -----------------------------------------------------------------
    414  0009d31c  directory_length 9, crc 54044
    418  04000014  hardware version
    41c  0c0083c0  node capabilities per IEEE 1394
    420  0300130e  vendor
    424  81000012  --> descriptor leaf at 46c
    428  17000006  model
    42c  81000016  --> descriptor leaf at 484
    430  130120c2  version
    434  d1000002  --> unit directory at 43c
    438  d4000006  --> dependent info directory at 450
    
                   unit directory at 43c
                   -----------------------------------------------------------------
    43c  0004707c  directory_length 4, crc 28796
    440  1200a02d  specifier id: 1394 TA
    444  13010001  version: AV/C
    448  17000006  model
    44c  81000013  --> descriptor leaf at 498
    
                   dependent info directory at 450
                   -----------------------------------------------------------------
    450  000637c7  directory_length 6, crc 14279
    454  120007f5  specifier id
    458  13000001  version
    45c  3affffc7  (immediate value)
    460  3b100000  (immediate value)
    464  3cffffc7  (immediate value)
    468  3d600000  (immediate value)
    
                   descriptor leaf at 46c
                   -----------------------------------------------------------------
    46c  00056f3b  leaf_length 5, crc 28475
    470  00000000  textual descriptor
    474  00000000  minimal ASCII
    478  466f6375  "Focu"
    47c  73726974  "srit"
    480  65000000  "e"
    
                   descriptor leaf at 484
                   -----------------------------------------------------------------
    484  0004a165  leaf_length 4, crc 41317
    488  00000000  textual descriptor
    48c  00000000  minimal ASCII
    490  50726f31  "Pro1"
    494  30494f00  "0IO"
    
                   descriptor leaf at 498
                   -----------------------------------------------------------------
    498  0004a165  leaf_length 4, crc 41317
    49c  00000000  textual descriptor
    4a0  00000000  minimal ASCII
    4a4  50726f31  "Pro1"
    4a8  30494f00  "0IO"
    
    $ python2 crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  040442e4  bus_info_length 4, crc_length 4, crc 17124
    404  31333934  bus_name "1394"
    408  e0ff8112  irmc 1, cmc 1, isc 1, bmc 0, pmc 0, cyc_clk_acc 255,
                   max_rec 8 (512), max_rom 1, gen 1, spd 2 (S400)
    40c  00130e04  company_id 00130e     |
    410  018001e9  device_id 04018001e9  | EUI-64 00130e04018001e9
    
                   root directory
                   -----------------------------------------------------------------
    414  00065612  directory_length 6, crc 22034
    418  0300130e  vendor
    41c  8100000a  --> descriptor leaf at 444
    420  17000006  model
    424  8100000e  --> descriptor leaf at 45c
    428  0c0087c0  node capabilities per IEEE 1394
    42c  d1000001  --> unit directory at 430
    
                   unit directory at 430
                   -----------------------------------------------------------------
    430  000418a0  directory_length 4, crc 6304
    434  1200130e  specifier id
    438  13000001  version
    43c  17000006  model
    440  8100000f  --> descriptor leaf at 47c
    
                   descriptor leaf at 444
                   -----------------------------------------------------------------
    444  00056f3b  leaf_length 5, crc 28475
    448  00000000  textual descriptor
    44c  00000000  minimal ASCII
    450  466f6375  "Focu"
    454  73726974  "srit"
    458  65000000  "e"
    
                   descriptor leaf at 45c
                   -----------------------------------------------------------------
    45c  000762c6  leaf_length 7, crc 25286
    460  00000000  textual descriptor
    464  00000000  minimal ASCII
    468  4c495155  "LIQU"
    46c  49445f53  "ID_S"
    470  41464649  "AFFI"
    474  52455f35  "RE_5"
    478  36000000  "6"
    
                   descriptor leaf at 47c
                   -----------------------------------------------------------------
    47c  000762c6  leaf_length 7, crc 25286
    480  00000000  textual descriptor
    484  00000000  minimal ASCII
    488  4c495155  "LIQU"
    48c  49445f53  "ID_S"
    490  41464649  "AFFI"
    494  52455f35  "RE_5"
    498  36000000  "6"
    
    Cc: <stable@vger.kernel.org> # v3.16+
    Fixes: 25784ec2d034 ("ALSA: bebob: Add support for Focusrite Saffire/SaffirePro series")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9826a60a2acadf3b2de5f452c179a29a43c3f28a
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Mar 15 09:14:10 2019 +0100

    perf/x86: Fixup typo in stub functions
    
    commit f764c58b7faa26f5714e6907f892abc2bc0de4f8 upstream.
    
    Guenter reported a build warning for CONFIG_CPU_SUP_INTEL=n:
    
      > With allmodconfig-CONFIG_CPU_SUP_INTEL, this patch results in:
      >
      > In file included from arch/x86/events/amd/core.c:8:0:
      > arch/x86/events/amd/../perf_event.h:1036:45: warning: ‘struct cpu_hw_event’ declared inside parameter list will not be visible outside of this definition or declaration
      >  static inline int intel_cpuc_prepare(struct cpu_hw_event *cpuc, int cpu)
    
    While harmless (an unsed pointer is an unused pointer, no matter the type)
    it needs fixing.
    
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Fixes: d01b1f96a82e ("perf/x86/intel: Make cpuc allocations consistent")
    Link: http://lkml.kernel.org/r/20190315081410.GR5996@hirez.programming.kicks-ass.net
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 94f93c5900e3c98d11a3353cd93bee0a0daf2bdc
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Fri Dec 28 11:00:38 2018 -0800

    f2fs: wait on atomic writes to count F2FS_CP_WB_DATA
    
    commit 31867b23d7d1ee3535136c6a410a6cf56f666bfc upstream.
    
    Otherwise, we can get wrong counts incurring checkpoint hang.
    
    IO_W (CP:  -24, Data:   24, Flush: (   0    0    1), Discard: (   0    0))
    
    Thread A                        Thread B
    - f2fs_write_data_pages
     -  __write_data_page
      - f2fs_submit_page_write
       - inc_page_count(F2FS_WB_DATA)
         type is F2FS_WB_DATA due to file is non-atomic one
    - f2fs_ioc_start_atomic_write
     - set_inode_flag(FI_ATOMIC_FILE)
                                    - f2fs_write_end_io
                                     - dec_page_count(F2FS_WB_CP_DATA)
                                       type is F2FS_WB_DATA due to file becomes
                                       atomic one
    
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 15c5945f83c1b167d3f10ca42b27c0f54039f760
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Wed Mar 6 16:22:12 2019 +0200

    net: sched: flower: insert new filter to idr after setting its mask
    
    [ Upstream commit ecb3dea400d3beaf611ce76ac7a51d4230492cf2 ]
    
    When adding new filter to flower classifier, fl_change() inserts it to
    handle_idr before initializing filter extensions and assigning it a mask.
    Normally this ordering doesn't matter because all flower classifier ops
    callbacks assume rtnl lock protection. However, when filter has an action
    that doesn't have its kernel module loaded, rtnl lock is released before
    call to request_module(). During this time the filter can be accessed bu
    concurrent task before its initialization is completed, which can lead to a
    crash.
    
    Example case of NULL pointer dereference in concurrent dump:
    
    Task 1                           Task 2
    
    tc_new_tfilter()
     fl_change()
      idr_alloc_u32(fnew)
      fl_set_parms()
       tcf_exts_validate()
        tcf_action_init()
         tcf_action_init_1()
          rtnl_unlock()
          request_module()
          ...                        rtnl_lock()
                                     tc_dump_tfilter()
                                      tcf_chain_dump()
                                       fl_walk()
                                        idr_get_next_ul()
                                        tcf_node_dump()
                                         tcf_fill_node()
                                          fl_dump()
                                           mask = &f->mask->key; <- NULL ptr
          rtnl_lock()
    
    Extension initialization and mask assignment don't depend on fnew->handle
    that is allocated by idr_alloc_u32(). Move idr allocation code after action
    creation and mask assignment in fl_change() to prevent concurrent access
    to not fully initialized filter when rtnl lock is released to load action
    module.
    
    Fixes: 01683a146999 ("net: sched: refactor flower walk to iterate over idr")
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 882e7866ad283b135d0434905551aba1ea93e7d7
Author: Adalbert Lazăr <alazar@bitdefender.com>
Date:   Wed Mar 6 12:13:53 2019 +0200

    vsock/virtio: fix kernel panic from virtio_transport_reset_no_sock
    
    [ Upstream commit 4c404ce23358d5d8fbdeb7a6021a9b33d3c3c167 ]
    
    Previous to commit 22b5c0b63f32 ("vsock/virtio: fix kernel panic
    after device hot-unplug"), vsock_core_init() was called from
    virtio_vsock_probe(). Now, virtio_transport_reset_no_sock() can be called
    before vsock_core_init() has the chance to run.
    
    [Wed Feb 27 14:17:09 2019] BUG: unable to handle kernel NULL pointer dereference at 0000000000000110
    [Wed Feb 27 14:17:09 2019] #PF error: [normal kernel read fault]
    [Wed Feb 27 14:17:09 2019] PGD 0 P4D 0
    [Wed Feb 27 14:17:09 2019] Oops: 0000 [#1] SMP PTI
    [Wed Feb 27 14:17:09 2019] CPU: 3 PID: 59 Comm: kworker/3:1 Not tainted 5.0.0-rc7-390-generic-hvi #390
    [Wed Feb 27 14:17:09 2019] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
    [Wed Feb 27 14:17:09 2019] Workqueue: virtio_vsock virtio_transport_rx_work [vmw_vsock_virtio_transport]
    [Wed Feb 27 14:17:09 2019] RIP: 0010:virtio_transport_reset_no_sock+0x8c/0xc0 [vmw_vsock_virtio_transport_common]
    [Wed Feb 27 14:17:09 2019] Code: 35 8b 4f 14 48 8b 57 08 31 f6 44 8b 4f 10 44 8b 07 48 8d 7d c8 e8 84 f8 ff ff 48 85 c0 48 89 c3 74 2a e8 f7 31 03 00 48 89 df <48> 8b 80 10 01 00 00 e8 68 fb 69 ed 48 8b 75 f0 65 48 33 34 25 28
    [Wed Feb 27 14:17:09 2019] RSP: 0018:ffffb42701ab7d40 EFLAGS: 00010282
    [Wed Feb 27 14:17:09 2019] RAX: 0000000000000000 RBX: ffff9d79637ee080 RCX: 0000000000000003
    [Wed Feb 27 14:17:09 2019] RDX: 0000000000000001 RSI: 0000000000000002 RDI: ffff9d79637ee080
    [Wed Feb 27 14:17:09 2019] RBP: ffffb42701ab7d78 R08: ffff9d796fae70e0 R09: ffff9d796f403500
    [Wed Feb 27 14:17:09 2019] R10: ffffb42701ab7d90 R11: 0000000000000000 R12: ffff9d7969d09240
    [Wed Feb 27 14:17:09 2019] R13: ffff9d79624e6840 R14: ffff9d7969d09318 R15: ffff9d796d48ff80
    [Wed Feb 27 14:17:09 2019] FS:  0000000000000000(0000) GS:ffff9d796fac0000(0000) knlGS:0000000000000000
    [Wed Feb 27 14:17:09 2019] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [Wed Feb 27 14:17:09 2019] CR2: 0000000000000110 CR3: 0000000427f22000 CR4: 00000000000006e0
    [Wed Feb 27 14:17:09 2019] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [Wed Feb 27 14:17:09 2019] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [Wed Feb 27 14:17:09 2019] Call Trace:
    [Wed Feb 27 14:17:09 2019]  virtio_transport_recv_pkt+0x63/0x820 [vmw_vsock_virtio_transport_common]
    [Wed Feb 27 14:17:09 2019]  ? kfree+0x17e/0x190
    [Wed Feb 27 14:17:09 2019]  ? detach_buf_split+0x145/0x160
    [Wed Feb 27 14:17:09 2019]  ? __switch_to_asm+0x40/0x70
    [Wed Feb 27 14:17:09 2019]  virtio_transport_rx_work+0xa0/0x106 [vmw_vsock_virtio_transport]
    [Wed Feb 27 14:17:09 2019] NET: Registered protocol family 40
    [Wed Feb 27 14:17:09 2019]  process_one_work+0x167/0x410
    [Wed Feb 27 14:17:09 2019]  worker_thread+0x4d/0x460
    [Wed Feb 27 14:17:09 2019]  kthread+0x105/0x140
    [Wed Feb 27 14:17:09 2019]  ? rescuer_thread+0x360/0x360
    [Wed Feb 27 14:17:09 2019]  ? kthread_destroy_worker+0x50/0x50
    [Wed Feb 27 14:17:09 2019]  ret_from_fork+0x35/0x40
    [Wed Feb 27 14:17:09 2019] Modules linked in: vmw_vsock_virtio_transport vmw_vsock_virtio_transport_common input_leds vsock serio_raw i2c_piix4 mac_hid qemu_fw_cfg autofs4 cirrus ttm drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops virtio_net psmouse drm net_failover pata_acpi virtio_blk failover floppy
    
    Fixes: 22b5c0b63f32 ("vsock/virtio: fix kernel panic after device hot-unplug")
    Reported-by: Alexandru Herghelegiu <aherghelegiu@bitdefender.com>
    Signed-off-by: Adalbert Lazăr <alazar@bitdefender.com>
    Co-developed-by: Stefan Hajnoczi <stefanha@redhat.com>
    Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
    Reviewed-by: Stefano Garzarella <sgarzare@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c7bc9d62033a5e5df2ac0c69145332ca4d5653e0
Author: Shiju Jose <shiju.jose@huawei.com>
Date:   Sun Mar 10 14:47:51 2019 +0800

    net: hns3: fix to stop multiple HNS reset due to the AER changes
    
    [ Upstream commit 69b51bbb03f73e04c486f79d1556b2d9becf4dbc ]
    
    The commit bfcb79fca19d
    ("PCI/ERR: Run error recovery callbacks for all affected devices")
    affected the non-fatal error recovery logic for the HNS and RDMA devices.
    This is because each HNS PF under PCIe bus receive callbacks
    from the AER driver when an error is reported for one of the PF.
    This causes unwanted PF resets because
    the HNS decides which PF to reset based on the reset type set.
    The HNS error handling code sets the reset type based on the hw error
    type detected.
    
    This patch provides fix for the above issue for the recovery of
    the hw errors in the HNS and RDMA devices.
    
    This patch needs backporting to the kernel v5.0+
    
    Fixes: 332fbf576579 ("net: hns3: add handling of hw ras errors using new set of commands")
    Reported-by: Xiaofei Tan <tanxiaofei@huawei.com>
    Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
    Signed-off-by: Huazhong Tan <tanhuazhong@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b31539bd3595837a2618c286c56de818c28972bf
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Fri Mar 8 01:21:27 2019 +0100

    net: dsa: mv88e6xxx: Set correct interface mode for CPU/DSA ports
    
    [ Upstream commit 7cbbee050c959f41b512599bafd99685f419ce26 ]
    
    By default, the switch driver is expected to configure CPU and DSA
    ports to their maximum speed. For the 6341 and 6390 families, the
    ports interface mode has to be configured as well. The 6390X range
    support 10G ports using XAUI, while the 6341 and 6390 supports
    2500BaseX, as their maximum speed.
    
    Fixes: 787799a9d555 ("net: dsa: mv88e6xxx: Default ports 9/10 6390X CMODE to 1000BaseX")
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7e30fd0627dbc8c3a5417706ad0bfcbd1e2d2d32
Author: Jack Morgenstein <jackm@dev.mellanox.co.il>
Date:   Tue Mar 12 17:05:49 2019 +0200

    net/mlx4_core: Fix qp mtt size calculation
    
    [ Upstream commit 8511a653e9250ef36b95803c375a7be0e2edb628 ]
    
    Calculation of qp mtt size (in function mlx4_RST2INIT_wrapper)
    ultimately depends on function roundup_pow_of_two.
    
    If the amount of memory required by the QP is less than one page,
    roundup_pow_of_two is called with argument zero.  In this case, the
    roundup_pow_of_two result is undefined.
    
    Calling roundup_pow_of_two with a zero argument resulted in the
    following stack trace:
    
    UBSAN: Undefined behaviour in ./include/linux/log2.h:61:13
    shift exponent 64 is too large for 64-bit type 'long unsigned int'
    CPU: 4 PID: 26939 Comm: rping Tainted: G OE 4.19.0-rc1
    Hardware name: Supermicro X9DR3-F/X9DR3-F, BIOS 3.2a 07/09/2015
    Call Trace:
    dump_stack+0x9a/0xeb
    ubsan_epilogue+0x9/0x7c
    __ubsan_handle_shift_out_of_bounds+0x254/0x29d
    ? __ubsan_handle_load_invalid_value+0x180/0x180
    ? debug_show_all_locks+0x310/0x310
    ? sched_clock+0x5/0x10
    ? sched_clock+0x5/0x10
    ? sched_clock_cpu+0x18/0x260
    ? find_held_lock+0x35/0x1e0
    ? mlx4_RST2INIT_QP_wrapper+0xfb1/0x1440 [mlx4_core]
    mlx4_RST2INIT_QP_wrapper+0xfb1/0x1440 [mlx4_core]
    
    Fix this by explicitly testing for zero, and returning one if the
    argument is zero (assuming that the next higher power of 2 in this case
    should be one).
    
    Fixes: c82e9aa0a8bc ("mlx4_core: resource tracking for HCA resources used by guests")
    Signed-off-by: Jack Morgenstein <jackm@dev.mellanox.co.il>
    Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 979785bea346a9895576fe0ef1655d72c41c7305
Author: Jack Morgenstein <jackm@dev.mellanox.co.il>
Date:   Tue Mar 12 17:05:48 2019 +0200

    net/mlx4_core: Fix locking in SRIOV mode when switching between events and polling
    
    [ Upstream commit c07d27927f2f2e96fcd27bb9fb330c9ea65612d0 ]
    
    In procedures mlx4_cmd_use_events() and mlx4_cmd_use_polling(), we need to
    guarantee that there are no FW commands in progress on the comm channel
    (for VFs) or wrapped FW commands (on the PF) when SRIOV is active.
    
    We do this by also taking the slave_cmd_mutex when SRIOV is active.
    
    This is especially important when switching from event to polling, since we
    free the command-context array during the switch.  If there are FW commands
    in progress (e.g., waiting for a completion event), the completion event
    handler will access freed memory.
    
    Since the decision to use comm_wait or comm_poll is taken before grabbing
    the event_sem/poll_sem in mlx4_comm_cmd_wait/poll, we must take the
    slave_cmd_mutex as well (to guarantee that the decision to use events or
    polling and the call to the appropriate cmd function are atomic).
    
    Fixes: a7e1f04905e5 ("net/mlx4_core: Fix deadlock when switching between polling and event fw commands")
    Signed-off-by: Jack Morgenstein <jackm@dev.mellanox.co.il>
    Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f1ac81bb23a4ca59c25ed37668664d287885d0ac
Author: Jack Morgenstein <jackm@dev.mellanox.co.il>
Date:   Tue Mar 12 17:05:47 2019 +0200

    net/mlx4_core: Fix reset flow when in command polling mode
    
    [ Upstream commit e15ce4b8d11227007577e6dc1364d288b8874fbe ]
    
    As part of unloading a device, the driver switches from
    FW command event mode to FW command polling mode.
    
    Part of switching over to polling mode is freeing the command context array
    memory (unfortunately, currently, without NULLing the command context array
    pointer).
    
    The reset flow calls "complete" to complete all outstanding fw commands
    (if we are in event mode). The check for event vs. polling mode here
    is to test if the command context array pointer is NULL.
    
    If the reset flow is activated after the switch to polling mode, it will
    attempt (incorrectly) to complete all the commands in the context array --
    because the pointer was not NULLed when the driver switched over to polling
    mode.
    
    As a result, we have a use-after-free situation, which results in a
    kernel crash.
    
    For example:
    BUG: unable to handle kernel NULL pointer dereference at           (null)
    IP: [<ffffffff876c4a8e>] __wake_up_common+0x2e/0x90
    PGD 0
    Oops: 0000 [#1] SMP
    Modules linked in: netconsole nfsv3 nfs_acl nfs lockd grace ...
    CPU: 2 PID: 940 Comm: kworker/2:3 Kdump: loaded Not tainted 3.10.0-862.el7.x86_64 #1
    Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS 090006  04/28/2016
    Workqueue: events hv_eject_device_work [pci_hyperv]
    task: ffff8d1734ca0fd0 ti: ffff8d17354bc000 task.ti: ffff8d17354bc000
    RIP: 0010:[<ffffffff876c4a8e>]  [<ffffffff876c4a8e>] __wake_up_common+0x2e/0x90
    RSP: 0018:ffff8d17354bfa38  EFLAGS: 00010082
    RAX: 0000000000000000 RBX: ffff8d17362d42c8 RCX: 0000000000000000
    RDX: 0000000000000001 RSI: 0000000000000003 RDI: ffff8d17362d42c8
    RBP: ffff8d17354bfa70 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000298 R11: ffff8d173610e000 R12: ffff8d17362d42d0
    R13: 0000000000000246 R14: 0000000000000000 R15: 0000000000000003
    FS:  0000000000000000(0000) GS:ffff8d1802680000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000000000000000 CR3: 00000000f16d8000 CR4: 00000000001406e0
    Call Trace:
     [<ffffffff876c7adc>] complete+0x3c/0x50
     [<ffffffffc04242f0>] mlx4_cmd_wake_completions+0x70/0x90 [mlx4_core]
     [<ffffffffc041e7b1>] mlx4_enter_error_state+0xe1/0x380 [mlx4_core]
     [<ffffffffc041fa4b>] mlx4_comm_cmd+0x29b/0x360 [mlx4_core]
     [<ffffffffc041ff51>] __mlx4_cmd+0x441/0x920 [mlx4_core]
     [<ffffffff877f62b1>] ? __slab_free+0x81/0x2f0
     [<ffffffff87951384>] ? __radix_tree_lookup+0x84/0xf0
     [<ffffffffc043a8eb>] mlx4_free_mtt_range+0x5b/0xb0 [mlx4_core]
     [<ffffffffc043a957>] mlx4_mtt_cleanup+0x17/0x20 [mlx4_core]
     [<ffffffffc04272c7>] mlx4_free_eq+0xa7/0x1c0 [mlx4_core]
     [<ffffffffc042803e>] mlx4_cleanup_eq_table+0xde/0x130 [mlx4_core]
     [<ffffffffc0433e08>] mlx4_unload_one+0x118/0x300 [mlx4_core]
     [<ffffffffc0434191>] mlx4_remove_one+0x91/0x1f0 [mlx4_core]
    
    The fix is to set the command context array pointer to NULL after freeing
    the array.
    
    Fixes: f5aef5aa3506 ("net/mlx4_core: Activate reset flow upon fatal command cases")
    Signed-off-by: Jack Morgenstein <jackm@dev.mellanox.co.il>
    Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 11e457c165d0e695384e96d12965bce198e6c617
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Mar 10 10:36:40 2019 -0700

    vxlan: test dev->flags & IFF_UP before calling gro_cells_receive()
    
    [ Upstream commit 59cbf56fcd98ba2a715b6e97c4e43f773f956393 ]
    
    Same reasons than the ones explained in commit 4179cb5a4c92
    ("vxlan: test dev->flags & IFF_UP before calling netif_rx()")
    
    netif_rx() or gro_cells_receive() must be called under a strict contract.
    
    At device dismantle phase, core networking clears IFF_UP
    and flush_all_backlogs() is called after rcu grace period
    to make sure no incoming packet might be in a cpu backlog
    and still referencing the device.
    
    A similar protocol is used for gro_cells infrastructure, as
    gro_cells_destroy() will be called only after a full rcu
    grace period is observed after IFF_UP has been cleared.
    
    Most drivers call netif_rx() from their interrupt handler,
    and since the interrupts are disabled at device dismantle,
    netif_rx() does not have to check dev->flags & IFF_UP
    
    Virtual drivers do not have this guarantee, and must
    therefore make the check themselves.
    
    Otherwise we risk use-after-free and/or crashes.
    
    Fixes: d342894c5d2f ("vxlan: virtual extensible lan")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 854b83c7493cb92cdce6d78368b97f4290962e39
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Fri Mar 8 16:40:57 2019 +0100

    vxlan: Fix GRO cells race condition between receive and link delete
    
    [ Upstream commit ad6c9986bcb627c7c22b8f9e9a934becc27df87c ]
    
    If we receive a packet while deleting a VXLAN device, there's a chance
    vxlan_rcv() is called at the same time as vxlan_dellink(). This is fine,
    except that vxlan_dellink() should never ever touch stuff that's still in
    use, such as the GRO cells list.
    
    Otherwise, vxlan_rcv() crashes while queueing packets via
    gro_cells_receive().
    
    Move the gro_cells_destroy() to vxlan_uninit(), which runs after the RCU
    grace period is elapsed and nothing needs the gro_cells anymore.
    
    This is now done in the same way as commit 8e816df87997 ("geneve: Use GRO
    cells infrastructure.") originally implemented for GENEVE.
    
    Reported-by: Jianlin Shi <jishi@redhat.com>
    Fixes: 58ce31cca1ff ("vxlan: GRO support at tunnel layer")
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3460bb198560a0dd809544b638114f5418ae3dee
Author: Guillaume Nault <gnault@redhat.com>
Date:   Fri Mar 8 22:09:47 2019 +0100

    tcp: handle inet_csk_reqsk_queue_add() failures
    
    [  Upstream commit 9d3e1368bb45893a75a5dfb7cd21fdebfa6b47af ]
    
    Commit 7716682cc58e ("tcp/dccp: fix another race at listener
    dismantle") let inet_csk_reqsk_queue_add() fail, and adjusted
    {tcp,dccp}_check_req() accordingly. However, TFO and syncookies
    weren't modified, thus leaking allocated resources on error.
    
    Contrary to tcp_check_req(), in both syncookies and TFO cases,
    we need to drop the request socket. Also, since the child socket is
    created with inet_csk_clone_lock(), we have to unlock it and drop an
    extra reference (->sk_refcount is initially set to 2 and
    inet_csk_reqsk_queue_add() drops only one ref).
    
    For TFO, we also need to revert the work done by tcp_try_fastopen()
    (with reqsk_fastopen_remove()).
    
    Fixes: 7716682cc58e ("tcp/dccp: fix another race at listener dismantle")
    Signed-off-by: Guillaume Nault <gnault@redhat.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dfcf44d29a7f4d0a3c177dffa4be0a05205ad1fa
Author: Christoph Paasch <cpaasch@apple.com>
Date:   Mon Mar 11 11:41:05 2019 -0700

    tcp: Don't access TCP_SKB_CB before initializing it
    
    [ Upstream commit f2feaefdabb0a6253aa020f65e7388f07a9ed47c ]
    
    Since commit eeea10b83a13 ("tcp: add
    tcp_v4_fill_cb()/tcp_v4_restore_cb()"), tcp_vX_fill_cb is only called
    after tcp_filter(). That means, TCP_SKB_CB(skb)->end_seq still points to
    the IP-part of the cb.
    
    We thus should not mock with it, as this can trigger bugs (thanks
    syzkaller):
    [   12.349396] ==================================================================
    [   12.350188] BUG: KASAN: slab-out-of-bounds in ip6_datagram_recv_specific_ctl+0x19b3/0x1a20
    [   12.351035] Read of size 1 at addr ffff88006adbc208 by task test_ip6_datagr/1799
    
    Setting end_seq is actually no more necessary in tcp_filter as it gets
    initialized later on in tcp_vX_fill_cb.
    
    Cc: Eric Dumazet <edumazet@google.com>
    Fixes: eeea10b83a13 ("tcp: add tcp_v4_fill_cb()/tcp_v4_restore_cb()")
    Signed-off-by: Christoph Paasch <cpaasch@apple.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 75c9b039f9bdf59f4fd74b1cf3db7321497653fa
Author: Soheil Hassas Yeganeh <soheil@google.com>
Date:   Wed Mar 6 13:01:36 2019 -0500

    tcp: do not report TCP_CM_INQ of 0 for closed connections
    
    [ Upstream commit 6466e715651f9f358e60c5ea4880e4731325827f ]
    
    Returning 0 as inq to userspace indicates there is no more data to
    read, and the application needs to wait for EPOLLIN. For a connection
    that has received FIN from the remote peer, however, the application
    must continue reading until getting EOF (return value of 0
    from tcp_recvmsg) or an error, if edge-triggered epoll (EPOLLET) is
    being used. Otherwise, the application will never receive a new
    EPOLLIN, since there is no epoll edge after the FIN.
    
    Return 1 when there is no data left on the queue but the
    connection has received FIN, so that the applications continue
    reading.
    
    Fixes: b75eba76d3d72 (tcp: send in-queue bytes in cmsg upon read)
    Signed-off-by: Soheil Hassas Yeganeh <soheil@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 05ad31a85e96bba6c2725f41f91f910d6a4ec21e
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Mar 8 15:49:16 2019 +0800

    sctp: remove sched init from sctp_stream_init
    
    [ Upstream commit 2e990dfd13974d9eae493006f42ffb48707970ef ]
    
    syzbot reported a NULL-ptr deref caused by that sched->init() in
    sctp_stream_init() set stream->rr_next = NULL.
    
      kasan: GPF could be caused by NULL-ptr deref or user memory access
      RIP: 0010:sctp_sched_rr_dequeue+0xd3/0x170 net/sctp/stream_sched_rr.c:141
      Call Trace:
        sctp_outq_dequeue_data net/sctp/outqueue.c:90 [inline]
        sctp_outq_flush_data net/sctp/outqueue.c:1079 [inline]
        sctp_outq_flush+0xba2/0x2790 net/sctp/outqueue.c:1205
    
    All sched info is saved in sout->ext now, in sctp_stream_init()
    sctp_stream_alloc_out() will not change it, there's no need to
    call sched->init() again, since sctp_outq_init() has already
    done it.
    
    Fixes: 5bbbbe32a431 ("sctp: introduce stream scheduler foundations")
    Reported-by: syzbot+4c9934f20522c0efd657@syzkaller.appspotmail.com
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3aca89318497007525ca44f10d0ffe20a438e153
Author: David Howells <dhowells@redhat.com>
Date:   Sat Mar 9 00:29:58 2019 +0000

    rxrpc: Fix client call queueing, waiting for channel
    
    [ Upstream commit 69ffaebb90369ce08657b5aea4896777b9d6e8fc ]
    
    rxrpc_get_client_conn() adds a new call to the front of the waiting_calls
    queue if the connection it's going to use already exists.  This is bad as
    it allows calls to get starved out.
    
    Fix this by adding to the tail instead.
    
    Also change the other enqueue point in the same function to put it on the
    front (ie. when we have a new connection).  This makes the point that in
    the case of a new connection the new call goes at the front (though it
    doesn't actually matter since the queue should be unoccupied).
    
    Fixes: 45025bceef17 ("rxrpc: Improve management and caching of client connection objects")
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Marc Dionne <marc.dionne@auristor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ed98b01c052356e0b6cd3f49d039babab8dfd3ff
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Mar 8 14:50:54 2019 +0800

    route: set the deleted fnhe fnhe_daddr to 0 in ip_del_fnhe to fix a race
    
    [ Upstream commit ee60ad219f5c7c4fb2f047f88037770063ef785f ]
    
    The race occurs in __mkroute_output() when 2 threads lookup a dst:
    
      CPU A                 CPU B
      find_exception()
                            find_exception() [fnhe expires]
                            ip_del_fnhe() [fnhe is deleted]
      rt_bind_exception()
    
    In rt_bind_exception() it will bind a deleted fnhe with the new dst, and
    this dst will get no chance to be freed. It causes a dev defcnt leak and
    consecutive dmesg warnings:
    
      unregister_netdevice: waiting for ethX to become free. Usage count = 1
    
    Especially thanks Jon to identify the issue.
    
    This patch fixes it by setting fnhe_daddr to 0 in ip_del_fnhe() to stop
    binding the deleted fnhe with a new dst when checking fnhe's fnhe_daddr
    and daddr in rt_bind_exception().
    
    It works as both ip_del_fnhe() and rt_bind_exception() are protected by
    fnhe_lock and the fhne is freed by kfree_rcu().
    
    Fixes: deed49df7390 ("route: check and remove route cache when we get route")
    Signed-off-by: Jon Maxwell <jmaxwell37@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cfa5b557d9d04fe5273f9d3e0559be9851f2d87b
Author: Masaru Nagai <masaru.nagai.vx@renesas.com>
Date:   Thu Mar 7 11:24:47 2019 +0100

    ravb: Decrease TxFIFO depth of Q3 and Q2 to one
    
    [ Upstream commit ae9819e339b451da7a86ab6fe38ecfcb6814e78a ]
    
    Hardware has the CBS (Credit Based Shaper) which affects only Q3
    and Q2. When updating the CBS settings, even if the driver does so
    after waiting for Tx DMA finished, there is a possibility that frame
    data still remains in TxFIFO.
    
    To avoid this, decrease TxFIFO depth of Q3 and Q2 to one.
    
    This patch has been exercised this using netperf TCP_MAERTS, TCP_STREAM
    and UDP_STREAM tests run on an Ebisu board. No performance change was
    detected, outside of noise in the tests, both in terms of throughput and
    CPU utilisation.
    
    Fixes: c156633f1353 ("Renesas Ethernet AVB driver proper")
    Signed-off-by: Masaru Nagai <masaru.nagai.vx@renesas.com>
    Signed-off-by: Kazuya Mizuguchi <kazuya.mizuguchi.ks@renesas.com>
    [simon: updated changelog]
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 41b802e6f2a8ce02cedf6264041c6509a2ec509a
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Mar 13 17:00:48 2019 +0800

    pptp: dst_release sk_dst_cache in pptp_sock_destruct
    
    [ Upstream commit 9417d81f4f8adfe20a12dd1fadf73a618cbd945d ]
    
    sk_setup_caps() is called to set sk->sk_dst_cache in pptp_connect,
    so we have to dst_release(sk->sk_dst_cache) in pptp_sock_destruct,
    otherwise, the dst refcnt will leak.
    
    It can be reproduced by this syz log:
    
      r1 = socket$pptp(0x18, 0x1, 0x2)
      bind$pptp(r1, &(0x7f0000000100)={0x18, 0x2, {0x0, @local}}, 0x1e)
      connect$pptp(r1, &(0x7f0000000000)={0x18, 0x2, {0x3, @remote}}, 0x1e)
    
    Consecutive dmesg warnings will occur:
    
      unregister_netdevice: waiting for lo to become free. Usage count = 1
    
    v1->v2:
      - use rcu_dereference_protected() instead of rcu_dereference_check(),
        as suggested by Eric.
    
    Fixes: 00959ade36ac ("PPTP: PPP over IPv4 (Point-to-Point Tunneling Protocol)")
    Reported-by: Xiumei Mu <xmu@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a6e37802e050cebc721dcacbffd1194b692a5340
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Mar 11 13:48:44 2019 -0700

    net/x25: reset state in x25_connect()
    
    [ Upstream commit ee74d0bd4325efb41e38affe5955f920ed973f23 ]
    
    In case x25_connect() fails and frees the socket neighbour,
    we also need to undo the change done to x25->state.
    
    Before my last bug fix, we had use-after-free so this
    patch fixes a latent bug.
    
    syzbot report :
    
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] PREEMPT SMP KASAN
    CPU: 1 PID: 16137 Comm: syz-executor.1 Not tainted 5.0.0+ #117
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    RIP: 0010:x25_write_internal+0x1e8/0xdf0 net/x25/x25_subr.c:173
    Code: 00 40 88 b5 e0 fe ff ff 0f 85 01 0b 00 00 48 8b 8b 80 04 00 00 48 ba 00 00 00 00 00 fc ff df 48 8d 79 1c 48 89 fe 48 c1 ee 03 <0f> b6 34 16 48 89 fa 83 e2 07 83 c2 03 40 38 f2 7c 09 40 84 f6 0f
    RSP: 0018:ffff888076717a08 EFLAGS: 00010207
    RAX: ffff88805f2f2292 RBX: ffff8880a0ae6000 RCX: 0000000000000000
    kobject: 'loop5' (0000000018d0d0ee): kobject_uevent_env
    RDX: dffffc0000000000 RSI: 0000000000000003 RDI: 000000000000001c
    RBP: ffff888076717b40 R08: ffff8880950e0580 R09: ffffed100be5e46d
    R10: ffffed100be5e46c R11: ffff88805f2f2363 R12: ffff888065579840
    kobject: 'loop5' (0000000018d0d0ee): fill_kobj_path: path = '/devices/virtual/block/loop5'
    R13: 1ffff1100ece2f47 R14: 0000000000000013 R15: 0000000000000013
    FS:  00007fb88cf43700(0000) GS:ffff8880ae900000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007f9a42a41028 CR3: 0000000087a67000 CR4: 00000000001406e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     x25_release+0xd0/0x340 net/x25/af_x25.c:658
     __sock_release+0xd3/0x2b0 net/socket.c:579
     sock_close+0x1b/0x30 net/socket.c:1162
     __fput+0x2df/0x8d0 fs/file_table.c:278
     ____fput+0x16/0x20 fs/file_table.c:309
     task_work_run+0x14a/0x1c0 kernel/task_work.c:113
     get_signal+0x1961/0x1d50 kernel/signal.c:2388
     do_signal+0x87/0x1940 arch/x86/kernel/signal.c:816
     exit_to_usermode_loop+0x244/0x2c0 arch/x86/entry/common.c:162
     prepare_exit_to_usermode arch/x86/entry/common.c:197 [inline]
     syscall_return_slowpath arch/x86/entry/common.c:268 [inline]
     do_syscall_64+0x52d/0x610 arch/x86/entry/common.c:293
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x457f29
    Code: ad b8 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 7b b8 fb ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007fb88cf42c78 EFLAGS: 00000246 ORIG_RAX: 000000000000002a
    RAX: fffffffffffffe00 RBX: 0000000000000003 RCX: 0000000000457f29
    RDX: 0000000000000012 RSI: 0000000020000080 RDI: 0000000000000004
    RBP: 000000000073bf00 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00007fb88cf436d4
    R13: 00000000004be462 R14: 00000000004cec98 R15: 00000000ffffffff
    Modules linked in:
    
    Fixes: 95d6ebd53c79 ("net/x25: fix use-after-free in x25_device_event()")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: andrew hendry <andrew.hendry@gmail.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 391c4c5228d8cfc64556c47fdeda5a78759da632
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Mar 10 09:07:14 2019 -0700

    net/x25: fix use-after-free in x25_device_event()
    
    [ Upstream commit 95d6ebd53c79522bf9502dbc7e89e0d63f94dae4 ]
    
    In case of failure x25_connect() does a x25_neigh_put(x25->neighbour)
    but forgets to clear x25->neighbour pointer, thus triggering use-after-free.
    
    Since the socket is visible in x25_list, we need to hold x25_list_lock
    to protect the operation.
    
    syzbot report :
    
    BUG: KASAN: use-after-free in x25_kill_by_device net/x25/af_x25.c:217 [inline]
    BUG: KASAN: use-after-free in x25_device_event+0x296/0x2b0 net/x25/af_x25.c:252
    Read of size 8 at addr ffff8880a030edd0 by task syz-executor003/7854
    
    CPU: 0 PID: 7854 Comm: syz-executor003 Not tainted 5.0.0+ #97
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x172/0x1f0 lib/dump_stack.c:113
     print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187
     kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317
     __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:135
     x25_kill_by_device net/x25/af_x25.c:217 [inline]
     x25_device_event+0x296/0x2b0 net/x25/af_x25.c:252
     notifier_call_chain+0xc7/0x240 kernel/notifier.c:93
     __raw_notifier_call_chain kernel/notifier.c:394 [inline]
     raw_notifier_call_chain+0x2e/0x40 kernel/notifier.c:401
     call_netdevice_notifiers_info+0x3f/0x90 net/core/dev.c:1739
     call_netdevice_notifiers_extack net/core/dev.c:1751 [inline]
     call_netdevice_notifiers net/core/dev.c:1765 [inline]
     __dev_notify_flags+0x1e9/0x2c0 net/core/dev.c:7607
     dev_change_flags+0x10d/0x170 net/core/dev.c:7643
     dev_ifsioc+0x2b0/0x940 net/core/dev_ioctl.c:237
     dev_ioctl+0x1b8/0xc70 net/core/dev_ioctl.c:488
     sock_do_ioctl+0x1bd/0x300 net/socket.c:995
     sock_ioctl+0x32b/0x610 net/socket.c:1096
     vfs_ioctl fs/ioctl.c:46 [inline]
     file_ioctl fs/ioctl.c:509 [inline]
     do_vfs_ioctl+0xd6e/0x1390 fs/ioctl.c:696
     ksys_ioctl+0xab/0xd0 fs/ioctl.c:713
     __do_sys_ioctl fs/ioctl.c:720 [inline]
     __se_sys_ioctl fs/ioctl.c:718 [inline]
     __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:718
     do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x4467c9
    Code: e8 0c e8 ff ff 48 83 c4 18 c3 0f 1f 80 00 00 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 5b 07 fc ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007fdbea222d98 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
    RAX: ffffffffffffffda RBX: 00000000006dbc58 RCX: 00000000004467c9
    RDX: 0000000020000340 RSI: 0000000000008914 RDI: 0000000000000003
    RBP: 00000000006dbc50 R08: 00007fdbea223700 R09: 0000000000000000
    R10: 00007fdbea223700 R11: 0000000000000246 R12: 00000000006dbc5c
    R13: 6000030030626669 R14: 0000000000000000 R15: 0000000030626669
    
    Allocated by task 7843:
     save_stack+0x45/0xd0 mm/kasan/common.c:73
     set_track mm/kasan/common.c:85 [inline]
     __kasan_kmalloc mm/kasan/common.c:495 [inline]
     __kasan_kmalloc.constprop.0+0xcf/0xe0 mm/kasan/common.c:468
     kasan_kmalloc+0x9/0x10 mm/kasan/common.c:509
     kmem_cache_alloc_trace+0x151/0x760 mm/slab.c:3615
     kmalloc include/linux/slab.h:545 [inline]
     x25_link_device_up+0x46/0x3f0 net/x25/x25_link.c:249
     x25_device_event+0x116/0x2b0 net/x25/af_x25.c:242
     notifier_call_chain+0xc7/0x240 kernel/notifier.c:93
     __raw_notifier_call_chain kernel/notifier.c:394 [inline]
     raw_notifier_call_chain+0x2e/0x40 kernel/notifier.c:401
     call_netdevice_notifiers_info+0x3f/0x90 net/core/dev.c:1739
     call_netdevice_notifiers_extack net/core/dev.c:1751 [inline]
     call_netdevice_notifiers net/core/dev.c:1765 [inline]
     __dev_notify_flags+0x121/0x2c0 net/core/dev.c:7605
     dev_change_flags+0x10d/0x170 net/core/dev.c:7643
     dev_ifsioc+0x2b0/0x940 net/core/dev_ioctl.c:237
     dev_ioctl+0x1b8/0xc70 net/core/dev_ioctl.c:488
     sock_do_ioctl+0x1bd/0x300 net/socket.c:995
     sock_ioctl+0x32b/0x610 net/socket.c:1096
     vfs_ioctl fs/ioctl.c:46 [inline]
     file_ioctl fs/ioctl.c:509 [inline]
     do_vfs_ioctl+0xd6e/0x1390 fs/ioctl.c:696
     ksys_ioctl+0xab/0xd0 fs/ioctl.c:713
     __do_sys_ioctl fs/ioctl.c:720 [inline]
     __se_sys_ioctl fs/ioctl.c:718 [inline]
     __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:718
     do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Freed by task 7865:
     save_stack+0x45/0xd0 mm/kasan/common.c:73
     set_track mm/kasan/common.c:85 [inline]
     __kasan_slab_free+0x102/0x150 mm/kasan/common.c:457
     kasan_slab_free+0xe/0x10 mm/kasan/common.c:465
     __cache_free mm/slab.c:3494 [inline]
     kfree+0xcf/0x230 mm/slab.c:3811
     x25_neigh_put include/net/x25.h:253 [inline]
     x25_connect+0x8d8/0xde0 net/x25/af_x25.c:824
     __sys_connect+0x266/0x330 net/socket.c:1685
     __do_sys_connect net/socket.c:1696 [inline]
     __se_sys_connect net/socket.c:1693 [inline]
     __x64_sys_connect+0x73/0xb0 net/socket.c:1693
     do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    The buggy address belongs to the object at ffff8880a030edc0
     which belongs to the cache kmalloc-256 of size 256
    The buggy address is located 16 bytes inside of
     256-byte region [ffff8880a030edc0, ffff8880a030eec0)
    The buggy address belongs to the page:
    page:ffffea000280c380 count:1 mapcount:0 mapping:ffff88812c3f07c0 index:0x0
    flags: 0x1fffc0000000200(slab)
    raw: 01fffc0000000200 ffffea0002806788 ffffea00027f0188 ffff88812c3f07c0
    raw: 0000000000000000 ffff8880a030e000 000000010000000c 0000000000000000
    page dumped because: kasan: bad access detected
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot+04babcefcd396fabec37@syzkaller.appspotmail.com
    Cc: andrew hendry <andrew.hendry@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0f27e8de567872cd684267e36c2f2eb9f7b29265
Author: Miaohe Lin <linmiaohe@huawei.com>
Date:   Mon Mar 11 16:29:32 2019 +0800

    net: sit: fix UBSAN Undefined behaviour in check_6rd
    
    [ Upstream commit a843dc4ebaecd15fca1f4d35a97210f72ea1473b ]
    
    In func check_6rd,tunnel->ip6rd.relay_prefixlen may equal to
    32,so UBSAN complain about it.
    
    UBSAN: Undefined behaviour in net/ipv6/sit.c:781:47
    shift exponent 32 is too large for 32-bit type 'unsigned int'
    CPU: 6 PID: 20036 Comm: syz-executor.0 Not tainted 4.19.27 #2
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1
    04/01/2014
    Call Trace:
    __dump_stack lib/dump_stack.c:77 [inline]
    dump_stack+0xca/0x13e lib/dump_stack.c:113
    ubsan_epilogue+0xe/0x81 lib/ubsan.c:159
    __ubsan_handle_shift_out_of_bounds+0x293/0x2e8 lib/ubsan.c:425
    check_6rd.constprop.9+0x433/0x4e0 net/ipv6/sit.c:781
    try_6rd net/ipv6/sit.c:806 [inline]
    ipip6_tunnel_xmit net/ipv6/sit.c:866 [inline]
    sit_tunnel_xmit+0x141c/0x2720 net/ipv6/sit.c:1033
    __netdev_start_xmit include/linux/netdevice.h:4300 [inline]
    netdev_start_xmit include/linux/netdevice.h:4309 [inline]
    xmit_one net/core/dev.c:3243 [inline]
    dev_hard_start_xmit+0x17c/0x780 net/core/dev.c:3259
    __dev_queue_xmit+0x1656/0x2500 net/core/dev.c:3829
    neigh_output include/net/neighbour.h:501 [inline]
    ip6_finish_output2+0xa36/0x2290 net/ipv6/ip6_output.c:120
    ip6_finish_output+0x3e7/0xa20 net/ipv6/ip6_output.c:154
    NF_HOOK_COND include/linux/netfilter.h:278 [inline]
    ip6_output+0x1e2/0x720 net/ipv6/ip6_output.c:171
    dst_output include/net/dst.h:444 [inline]
    ip6_local_out+0x99/0x170 net/ipv6/output_core.c:176
    ip6_send_skb+0x9d/0x2f0 net/ipv6/ip6_output.c:1697
    ip6_push_pending_frames+0xc0/0x100 net/ipv6/ip6_output.c:1717
    rawv6_push_pending_frames net/ipv6/raw.c:616 [inline]
    rawv6_sendmsg+0x2435/0x3530 net/ipv6/raw.c:946
    inet_sendmsg+0xf8/0x5c0 net/ipv4/af_inet.c:798
    sock_sendmsg_nosec net/socket.c:621 [inline]
    sock_sendmsg+0xc8/0x110 net/socket.c:631
    ___sys_sendmsg+0x6cf/0x890 net/socket.c:2114
    __sys_sendmsg+0xf0/0x1b0 net/socket.c:2152
    do_syscall_64+0xc8/0x580 arch/x86/entry/common.c:290
    entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Signed-off-by: linmiaohe <linmiaohe@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bfca8925f758fc2366139e8412ecd9bebfa44b3e
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Mar 7 09:36:33 2019 -0800

    net/hsr: fix possible crash in add_timer()
    
    [ Upstream commit 1e027960edfaa6a43f9ca31081729b716598112b ]
    
    syzbot found another add_timer() issue, this time in net/hsr [1]
    
    Let's use mod_timer() which is safe.
    
    [1]
    kernel BUG at kernel/time/timer.c:1136!
    invalid opcode: 0000 [#1] PREEMPT SMP KASAN
    CPU: 0 PID: 15909 Comm: syz-executor.3 Not tainted 5.0.0+ #97
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    kobject: 'loop2' (00000000f5629718): kobject_uevent_env
    RIP: 0010:add_timer kernel/time/timer.c:1136 [inline]
    RIP: 0010:add_timer+0x654/0xbe0 kernel/time/timer.c:1134
    Code: 0f 94 c5 31 ff 44 89 ee e8 09 61 0f 00 45 84 ed 0f 84 77 fd ff ff e8 bb 5f 0f 00 e8 07 10 a0 ff e9 68 fd ff ff e8 ac 5f 0f 00 <0f> 0b e8 a5 5f 0f 00 0f 0b e8 9e 5f 0f 00 4c 89 b5 58 ff ff ff e9
    RSP: 0018:ffff8880656eeca0 EFLAGS: 00010246
    kobject: 'loop2' (00000000f5629718): fill_kobj_path: path = '/devices/virtual/block/loop2'
    RAX: 0000000000040000 RBX: 1ffff1100caddd9a RCX: ffffc9000c436000
    RDX: 0000000000040000 RSI: ffffffff816056c4 RDI: ffff88806a2f6cc8
    RBP: ffff8880656eed58 R08: ffff888067f4a300 R09: ffff888067f4abc8
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff88806a2f6cc0
    R13: dffffc0000000000 R14: 0000000000000001 R15: ffff8880656eed30
    FS:  00007fc2019bf700(0000) GS:ffff8880ae800000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000000000738000 CR3: 0000000067e8e000 CR4: 00000000001406f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     hsr_check_announce net/hsr/hsr_device.c:99 [inline]
     hsr_check_carrier_and_operstate+0x567/0x6f0 net/hsr/hsr_device.c:120
     hsr_netdev_notify+0x297/0xa00 net/hsr/hsr_main.c:51
     notifier_call_chain+0xc7/0x240 kernel/notifier.c:93
     __raw_notifier_call_chain kernel/notifier.c:394 [inline]
     raw_notifier_call_chain+0x2e/0x40 kernel/notifier.c:401
     call_netdevice_notifiers_info+0x3f/0x90 net/core/dev.c:1739
     call_netdevice_notifiers_extack net/core/dev.c:1751 [inline]
     call_netdevice_notifiers net/core/dev.c:1765 [inline]
     dev_open net/core/dev.c:1436 [inline]
     dev_open+0x143/0x160 net/core/dev.c:1424
     team_port_add drivers/net/team/team.c:1203 [inline]
     team_add_slave+0xa07/0x15d0 drivers/net/team/team.c:1933
     do_set_master net/core/rtnetlink.c:2358 [inline]
     do_set_master+0x1d4/0x230 net/core/rtnetlink.c:2332
     do_setlink+0x966/0x3510 net/core/rtnetlink.c:2493
     rtnl_setlink+0x271/0x3b0 net/core/rtnetlink.c:2747
     rtnetlink_rcv_msg+0x465/0xb00 net/core/rtnetlink.c:5192
     netlink_rcv_skb+0x17a/0x460 net/netlink/af_netlink.c:2485
     rtnetlink_rcv+0x1d/0x30 net/core/rtnetlink.c:5210
     netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]
     netlink_unicast+0x536/0x720 net/netlink/af_netlink.c:1336
     netlink_sendmsg+0x8ae/0xd70 net/netlink/af_netlink.c:1925
     sock_sendmsg_nosec net/socket.c:622 [inline]
     sock_sendmsg+0xdd/0x130 net/socket.c:632
     sock_write_iter+0x27c/0x3e0 net/socket.c:923
     call_write_iter include/linux/fs.h:1869 [inline]
     do_iter_readv_writev+0x5e0/0x8e0 fs/read_write.c:680
     do_iter_write fs/read_write.c:956 [inline]
     do_iter_write+0x184/0x610 fs/read_write.c:937
     vfs_writev+0x1b3/0x2f0 fs/read_write.c:1001
     do_writev+0xf6/0x290 fs/read_write.c:1036
     __do_sys_writev fs/read_write.c:1109 [inline]
     __se_sys_writev fs/read_write.c:1106 [inline]
     __x64_sys_writev+0x75/0xb0 fs/read_write.c:1106
     do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x457f29
    Code: ad b8 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 7b b8 fb ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007fc2019bec78 EFLAGS: 00000246 ORIG_RAX: 0000000000000014
    RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 0000000000457f29
    RDX: 0000000000000001 RSI: 00000000200000c0 RDI: 0000000000000003
    RBP: 000000000073bf00 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00007fc2019bf6d4
    R13: 00000000004c4a60 R14: 00000000004dd218 R15: 00000000ffffffff
    
    Fixes: f421436a591d ("net/hsr: Add support for the High-availability Seamless Redundancy protocol (HSRv0)")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 251eb21781bf4431719c01be5502a4c534647c87
Author: Mao Wenan <maowenan@huawei.com>
Date:   Wed Mar 6 22:45:01 2019 +0800

    net: hsr: fix memory leak in hsr_dev_finalize()
    
    [ Upstream commit 6caabe7f197d3466d238f70915d65301f1716626 ]
    
    If hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER) failed to
    add port, it directly returns res and forgets to free the node
    that allocated in hsr_create_self_node(), and forgets to delete
    the node->mac_list linked in hsr->self_node_db.
    
    BUG: memory leak
    unreferenced object 0xffff8881cfa0c780 (size 64):
      comm "syz-executor.0", pid 2077, jiffies 4294717969 (age 2415.377s)
      hex dump (first 32 bytes):
        e0 c7 a0 cf 81 88 ff ff 00 02 00 00 00 00 ad de  ................
        00 e6 49 cd 81 88 ff ff c0 9b 87 d0 81 88 ff ff  ..I.............
      backtrace:
        [<00000000e2ff5070>] hsr_dev_finalize+0x736/0x960 [hsr]
        [<000000003ed2e597>] hsr_newlink+0x2b2/0x3e0 [hsr]
        [<000000003fa8c6b6>] __rtnl_newlink+0xf1f/0x1600 net/core/rtnetlink.c:3182
        [<000000001247a7ad>] rtnl_newlink+0x66/0x90 net/core/rtnetlink.c:3240
        [<00000000e7d1b61d>] rtnetlink_rcv_msg+0x54e/0xb90 net/core/rtnetlink.c:5130
        [<000000005556bd3a>] netlink_rcv_skb+0x129/0x340 net/netlink/af_netlink.c:2477
        [<00000000741d5ee6>] netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]
        [<00000000741d5ee6>] netlink_unicast+0x49a/0x650 net/netlink/af_netlink.c:1336
        [<000000009d56f9b7>] netlink_sendmsg+0x88b/0xdf0 net/netlink/af_netlink.c:1917
        [<0000000046b35c59>] sock_sendmsg_nosec net/socket.c:621 [inline]
        [<0000000046b35c59>] sock_sendmsg+0xc3/0x100 net/socket.c:631
        [<00000000d208adc9>] __sys_sendto+0x33e/0x560 net/socket.c:1786
        [<00000000b582837a>] __do_sys_sendto net/socket.c:1798 [inline]
        [<00000000b582837a>] __se_sys_sendto net/socket.c:1794 [inline]
        [<00000000b582837a>] __x64_sys_sendto+0xdd/0x1b0 net/socket.c:1794
        [<00000000c866801d>] do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
        [<00000000fea382d9>] entry_SYSCALL_64_after_hwframe+0x49/0xbe
        [<00000000e01dacb3>] 0xffffffffffffffff
    
    Fixes: c5a759117210 ("net/hsr: Use list_head (and rcu) instead of array for slave devices.")
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Mao Wenan <maowenan@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4b77303758551eea82c33969c3da6b110ac9fdec
Author: Jian Shen <shenjian15@huawei.com>
Date:   Wed Mar 6 11:26:37 2019 +0800

    net: hns3: add dma_rmb() for rx description
    
    [ Upstream commit d394d33bee22421b39a0bcdc51ca6d68ba308625 ]
    
    HW can not guarantee complete write desc->rx.size, even though
    HNS3_RXD_VLD_B has been set. Driver needs to add dma_rmb()
    instruction to make sure desc->rx.size is always valid.
    
    Fixes: e55970950556 ("net: hns3: Add handling of GRO Pkts not fully RX'ed in NAPI poll")
    Signed-off-by: Jian Shen <shenjian15@huawei.com>
    Signed-off-by: Huazhong Tan <tanhuazhong@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 93a96dc0a6109beed7790434fca93393b1700b28
Author: Bryan Whitehead <Bryan.Whitehead@microchip.com>
Date:   Wed Mar 13 15:55:48 2019 -0400

    lan743x: Fix TX Stall Issue
    
    [ Upstream commit deb6bfabdbb634e91f36a4e9cb00a7137d72d886 ]
    
    It has been observed that tx queue may stall while downloading
    from certain web sites (example www.speedtest.net)
    
    The cause has been tracked down to a corner case where
    the tx interrupt vector was disabled automatically, but
    was not re enabled later.
    
    The lan743x has two mechanisms to enable/disable individual
    interrupts. Interrupts can be enabled/disabled by individual
    source, and they can also be enabled/disabled by individual
    vector which has been mapped to the source. Both must be
    enabled for interrupts to work properly.
    
    The TX code path, primarily uses the interrupt enable/disable of
    the TX source bit, while leaving the vector enabled all the time.
    
    However, while investigating this issue it was noticed that
    the driver requested the use of the vector auto clear feature.
    
    The test above revealed a case where the vector enable was
    cleared unintentionally.
    
    This patch fixes the issue by deleting the lines that request
    the vector auto clear feature to be used.
    
    Fixes: 23f0703c125b ("lan743x: Add main source files for new lan743x driver")
    Signed-off-by: Bryan Whitehead <Bryan.Whitehead@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8c223fee4ad43a85efd9fa6a66a765ff2fd8db16
Author: Bryan Whitehead <Bryan.Whitehead@microchip.com>
Date:   Mon Mar 11 13:39:39 2019 -0400

    lan743x: Fix RX Kernel Panic
    
    [ Upstream commit dd9d9f5907bb475f8b1796c47d4ecc7fb9b72136 ]
    
    It has been noticed that running the speed test at
    www.speedtest.net occasionally causes a kernel panic.
    
    Investigation revealed that under this test RX buffer allocation
    sometimes fails and returns NULL. But the lan743x driver did
    not handle this case.
    
    This patch fixes this issue by attempting to allocate a buffer
    before sending the new rx packet to the OS. If the allocation
    fails then the new rx packet is dropped and the existing buffer
    is reused in the DMA ring.
    
    Updates for v2:
        Additional 2 locations where allocation was not checked,
            has been changed to reuse existing buffer.
    
    Fixes: 23f0703c125b ("lan743x: Add main source files for new lan743x driver")
    Signed-off-by: Bryan Whitehead <Bryan.Whitehead@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a53dc7db54c72fae9106b03d4bd8be7b9daec913
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Mar 12 06:50:11 2019 -0700

    l2tp: fix infoleak in l2tp_ip6_recvmsg()
    
    [ Upstream commit 163d1c3d6f17556ed3c340d3789ea93be95d6c28 ]
    
    Back in 2013 Hannes took care of most of such leaks in commit
    bceaa90240b6 ("inet: prevent leakage of uninitialized memory to user in recv syscalls")
    
    But the bug in l2tp_ip6_recvmsg() has not been fixed.
    
    syzbot report :
    
    BUG: KMSAN: kernel-infoleak in _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32
    CPU: 1 PID: 10996 Comm: syz-executor362 Not tainted 5.0.0+ #11
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x173/0x1d0 lib/dump_stack.c:113
     kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:600
     kmsan_internal_check_memory+0x9f4/0xb10 mm/kmsan/kmsan.c:694
     kmsan_copy_to_user+0xab/0xc0 mm/kmsan/kmsan_hooks.c:601
     _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32
     copy_to_user include/linux/uaccess.h:174 [inline]
     move_addr_to_user+0x311/0x570 net/socket.c:227
     ___sys_recvmsg+0xb65/0x1310 net/socket.c:2283
     do_recvmmsg+0x646/0x10c0 net/socket.c:2390
     __sys_recvmmsg net/socket.c:2469 [inline]
     __do_sys_recvmmsg net/socket.c:2492 [inline]
     __se_sys_recvmmsg+0x1d1/0x350 net/socket.c:2485
     __x64_sys_recvmmsg+0x62/0x80 net/socket.c:2485
     do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291
     entry_SYSCALL_64_after_hwframe+0x63/0xe7
    RIP: 0033:0x445819
    Code: e8 6c b6 02 00 48 83 c4 18 c3 0f 1f 80 00 00 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 2b 12 fc ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007f64453eddb8 EFLAGS: 00000246 ORIG_RAX: 000000000000012b
    RAX: ffffffffffffffda RBX: 00000000006dac28 RCX: 0000000000445819
    RDX: 0000000000000005 RSI: 0000000020002f80 RDI: 0000000000000003
    RBP: 00000000006dac20 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00000000006dac2c
    R13: 00007ffeba8f87af R14: 00007f64453ee9c0 R15: 20c49ba5e353f7cf
    
    Local variable description: ----addr@___sys_recvmsg
    Variable was created at:
     ___sys_recvmsg+0xf6/0x1310 net/socket.c:2244
     do_recvmmsg+0x646/0x10c0 net/socket.c:2390
    
    Bytes 0-31 of 32 are uninitialized
    Memory access of size 32 starts at ffff8880ae62fbb0
    Data copied to user address 0000000020000000
    
    Fixes: a32e0eec7042 ("l2tp: introduce L2TPv3 IP encapsulation support for IPv6")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b41988c24100cf1f0be52a8b6f5573c23f84a11a
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Wed Mar 6 10:42:53 2019 +0100

    ipv4/route: fail early when inet dev is missing
    
    [ Upstream commit 22c74764aa2943ecdf9f07c900d8a9c8ba6c9265 ]
    
    If a non local multicast packet reaches ip_route_input_rcu() while
    the ingress device IPv4 private data (in_dev) is NULL, we end up
    doing a NULL pointer dereference in IN_DEV_MFORWARD().
    
    Since the later call to ip_route_input_mc() is going to fail if
    !in_dev, we can fail early in such scenario and avoid the dangerous
    code path.
    
    v1 -> v2:
     - clarified the commit message, no code changes
    
    Reported-by: Tianhao Zhao <tizhao@redhat.com>
    Fixes: e58e41596811 ("net: Enable support for VRF with ipv4 multicast")
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ab62510ac2ea672d08c7a35ecb7ccfc6656a3eba
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Mar 10 10:39:37 2019 -0700

    gro_cells: make sure device is up in gro_cells_receive()
    
    [ Upstream commit 2a5ff07a0eb945f291e361aa6f6becca8340ba46 ]
    
    We keep receiving syzbot reports [1] that show that tunnels do not play
    the rcu/IFF_UP rules properly.
    
    At device dismantle phase, gro_cells_destroy() will be called
    only after a full rcu grace period is observed after IFF_UP
    has been cleared.
    
    This means that IFF_UP needs to be tested before queueing packets
    into netif_rx() or gro_cells.
    
    This patch implements the test in gro_cells_receive() because
    too many callers do not seem to bother enough.
    
    [1]
    BUG: unable to handle kernel paging request at fffff4ca0b9ffffe
    PGD 0 P4D 0
    Oops: 0000 [#1] PREEMPT SMP KASAN
    CPU: 0 PID: 21 Comm: kworker/u4:1 Not tainted 5.0.0+ #97
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: netns cleanup_net
    RIP: 0010:__skb_unlink include/linux/skbuff.h:1929 [inline]
    RIP: 0010:__skb_dequeue include/linux/skbuff.h:1945 [inline]
    RIP: 0010:__skb_queue_purge include/linux/skbuff.h:2656 [inline]
    RIP: 0010:gro_cells_destroy net/core/gro_cells.c:89 [inline]
    RIP: 0010:gro_cells_destroy+0x19d/0x360 net/core/gro_cells.c:78
    Code: 03 42 80 3c 20 00 0f 85 53 01 00 00 48 8d 7a 08 49 8b 47 08 49 c7 07 00 00 00 00 48 89 f9 49 c7 47 08 00 00 00 00 48 c1 e9 03 <42> 80 3c 21 00 0f 85 10 01 00 00 48 89 c1 48 89 42 08 48 c1 e9 03
    RSP: 0018:ffff8880aa3f79a8 EFLAGS: 00010a02
    RAX: 00ffffffffffffe8 RBX: ffffe8ffffc64b70 RCX: 1ffff8ca0b9ffffe
    RDX: ffffc6505cffffe8 RSI: ffffffff858410ca RDI: ffffc6505cfffff0
    RBP: ffff8880aa3f7a08 R08: ffff8880aa3e8580 R09: fffffbfff1263645
    R10: fffffbfff1263644 R11: ffffffff8931b223 R12: dffffc0000000000
    R13: 0000000000000000 R14: ffffe8ffffc64b80 R15: ffffe8ffffc64b75
    kobject: 'loop2' (000000004bd7d84a): kobject_uevent_env
    FS:  0000000000000000(0000) GS:ffff8880ae800000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: fffff4ca0b9ffffe CR3: 0000000094941000 CR4: 00000000001406f0
    Call Trace:
    kobject: 'loop2' (000000004bd7d84a): fill_kobj_path: path = '/devices/virtual/block/loop2'
     ip_tunnel_dev_free+0x19/0x60 net/ipv4/ip_tunnel.c:1010
     netdev_run_todo+0x51c/0x7d0 net/core/dev.c:8970
     rtnl_unlock+0xe/0x10 net/core/rtnetlink.c:116
     ip_tunnel_delete_nets+0x423/0x5f0 net/ipv4/ip_tunnel.c:1124
     vti_exit_batch_net+0x23/0x30 net/ipv4/ip_vti.c:495
     ops_exit_list.isra.0+0x105/0x160 net/core/net_namespace.c:156
     cleanup_net+0x3fb/0x960 net/core/net_namespace.c:551
     process_one_work+0x98e/0x1790 kernel/workqueue.c:2173
     worker_thread+0x98/0xe40 kernel/workqueue.c:2319
     kthread+0x357/0x430 kernel/kthread.c:246
     ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:352
    Modules linked in:
    CR2: fffff4ca0b9ffffe
       [ end trace 513fc9c1338d1cb3 ]
    RIP: 0010:__skb_unlink include/linux/skbuff.h:1929 [inline]
    RIP: 0010:__skb_dequeue include/linux/skbuff.h:1945 [inline]
    RIP: 0010:__skb_queue_purge include/linux/skbuff.h:2656 [inline]
    RIP: 0010:gro_cells_destroy net/core/gro_cells.c:89 [inline]
    RIP: 0010:gro_cells_destroy+0x19d/0x360 net/core/gro_cells.c:78
    Code: 03 42 80 3c 20 00 0f 85 53 01 00 00 48 8d 7a 08 49 8b 47 08 49 c7 07 00 00 00 00 48 89 f9 49 c7 47 08 00 00 00 00 48 c1 e9 03 <42> 80 3c 21 00 0f 85 10 01 00 00 48 89 c1 48 89 42 08 48 c1 e9 03
    RSP: 0018:ffff8880aa3f79a8 EFLAGS: 00010a02
    RAX: 00ffffffffffffe8 RBX: ffffe8ffffc64b70 RCX: 1ffff8ca0b9ffffe
    RDX: ffffc6505cffffe8 RSI: ffffffff858410ca RDI: ffffc6505cfffff0
    RBP: ffff8880aa3f7a08 R08: ffff8880aa3e8580 R09: fffffbfff1263645
    R10: fffffbfff1263644 R11: ffffffff8931b223 R12: dffffc0000000000
    kobject: 'loop3' (00000000e4ee57a6): kobject_uevent_env
    R13: 0000000000000000 R14: ffffe8ffffc64b80 R15: ffffe8ffffc64b75
    FS:  0000000000000000(0000) GS:ffff8880ae800000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: fffff4ca0b9ffffe CR3: 0000000094941000 CR4: 00000000001406f0
    
    Fixes: c9e6bc644e55 ("net: add gro_cells infrastructure")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a9b0ebbf75c3f08e8ac36870d4835497734121ae
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Mar 6 10:41:00 2019 -0800

    fou, fou6: avoid uninit-value in gue_err() and gue6_err()
    
    [ Upstream commit 5355ed6388e23b69a00d48398a68d022135e6486 ]
    
    My prior commit missed the fact that these functions
    were using udp_hdr() (aka skb_transport_header())
    to get access to GUE header.
    
    Since pskb_transport_may_pull() does not exist yet, we have to add
    transport_offset to our pskb_may_pull() calls.
    
    BUG: KMSAN: uninit-value in gue_err+0x514/0xfa0 net/ipv4/fou.c:1032
    CPU: 1 PID: 10648 Comm: syz-executor.1 Not tainted 5.0.0+ #11
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x173/0x1d0 lib/dump_stack.c:113
     kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:600
     __msan_warning+0x82/0xf0 mm/kmsan/kmsan_instr.c:313
     gue_err+0x514/0xfa0 net/ipv4/fou.c:1032
     __udp4_lib_err_encap_no_sk net/ipv4/udp.c:571 [inline]
     __udp4_lib_err_encap net/ipv4/udp.c:626 [inline]
     __udp4_lib_err+0x12e6/0x1d40 net/ipv4/udp.c:665
     udp_err+0x74/0x90 net/ipv4/udp.c:737
     icmp_socket_deliver net/ipv4/icmp.c:767 [inline]
     icmp_unreach+0xb65/0x1070 net/ipv4/icmp.c:884
     icmp_rcv+0x11a1/0x1950 net/ipv4/icmp.c:1066
     ip_protocol_deliver_rcu+0x584/0xbb0 net/ipv4/ip_input.c:208
     ip_local_deliver_finish net/ipv4/ip_input.c:234 [inline]
     NF_HOOK include/linux/netfilter.h:289 [inline]
     ip_local_deliver+0x624/0x7b0 net/ipv4/ip_input.c:255
     dst_input include/net/dst.h:450 [inline]
     ip_rcv_finish net/ipv4/ip_input.c:414 [inline]
     NF_HOOK include/linux/netfilter.h:289 [inline]
     ip_rcv+0x6bd/0x740 net/ipv4/ip_input.c:524
     __netif_receive_skb_one_core net/core/dev.c:4973 [inline]
     __netif_receive_skb net/core/dev.c:5083 [inline]
     process_backlog+0x756/0x10e0 net/core/dev.c:5923
     napi_poll net/core/dev.c:6346 [inline]
     net_rx_action+0x78b/0x1a60 net/core/dev.c:6412
     __do_softirq+0x53f/0x93a kernel/softirq.c:293
     invoke_softirq kernel/softirq.c:375 [inline]
     irq_exit+0x214/0x250 kernel/softirq.c:416
     exiting_irq+0xe/0x10 arch/x86/include/asm/apic.h:536
     smp_apic_timer_interrupt+0x48/0x70 arch/x86/kernel/apic/apic.c:1064
     apic_timer_interrupt+0x2e/0x40 arch/x86/entry/entry_64.S:814
     </IRQ>
    RIP: 0010:finish_lock_switch+0x2b/0x40 kernel/sched/core.c:2597
    Code: 48 89 e5 53 48 89 fb e8 63 e7 95 00 8b b8 88 0c 00 00 48 8b 00 48 85 c0 75 12 48 89 df e8 dd db 95 00 c6 00 00 c6 03 00 fb 5b <5d> c3 e8 4e e6 95 00 eb e7 66 90 66 2e 0f 1f 84 00 00 00 00 00 55
    RSP: 0018:ffff888081a0fc80 EFLAGS: 00000296 ORIG_RAX: ffffffffffffff13
    RAX: ffff88821fd6bd80 RBX: ffff888027898000 RCX: ccccccccccccd000
    RDX: ffff88821fca8d80 RSI: ffff888000000000 RDI: 00000000000004a0
    RBP: ffff888081a0fc80 R08: 0000000000000002 R09: ffff888081a0fb08
    R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000001
    R13: ffff88811130e388 R14: ffff88811130da00 R15: ffff88812fdb7d80
     finish_task_switch+0xfc/0x2d0 kernel/sched/core.c:2698
     context_switch kernel/sched/core.c:2851 [inline]
     __schedule+0x6cc/0x800 kernel/sched/core.c:3491
     schedule+0x15b/0x240 kernel/sched/core.c:3535
     freezable_schedule include/linux/freezer.h:172 [inline]
     do_nanosleep+0x2ba/0x980 kernel/time/hrtimer.c:1679
     hrtimer_nanosleep kernel/time/hrtimer.c:1733 [inline]
     __do_sys_nanosleep kernel/time/hrtimer.c:1767 [inline]
     __se_sys_nanosleep+0x746/0x960 kernel/time/hrtimer.c:1754
     __x64_sys_nanosleep+0x3e/0x60 kernel/time/hrtimer.c:1754
     do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291
     entry_SYSCALL_64_after_hwframe+0x63/0xe7
    RIP: 0033:0x4855a0
    Code: 00 00 48 c7 c0 d4 ff ff ff 64 c7 00 16 00 00 00 31 c0 eb be 66 0f 1f 44 00 00 83 3d b1 11 5d 00 00 75 14 b8 23 00 00 00 0f 05 <48> 3d 01 f0 ff ff 0f 83 04 e2 f8 ff c3 48 83 ec 08 e8 3a 55 fd ff
    RSP: 002b:0000000000a4fd58 EFLAGS: 00000246 ORIG_RAX: 0000000000000023
    RAX: ffffffffffffffda RBX: 0000000000085780 RCX: 00000000004855a0
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000a4fd60
    RBP: 00000000000007ec R08: 0000000000000001 R09: 0000000000ceb940
    R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000008
    R13: 0000000000a4fdb0 R14: 0000000000085711 R15: 0000000000a4fdc0
    
    Uninit was created at:
     kmsan_save_stack_with_flags mm/kmsan/kmsan.c:205 [inline]
     kmsan_internal_poison_shadow+0x92/0x150 mm/kmsan/kmsan.c:159
     kmsan_kmalloc+0xa6/0x130 mm/kmsan/kmsan_hooks.c:176
     kmsan_slab_alloc+0xe/0x10 mm/kmsan/kmsan_hooks.c:185
     slab_post_alloc_hook mm/slab.h:445 [inline]
     slab_alloc_node mm/slub.c:2773 [inline]
     __kmalloc_node_track_caller+0xe9e/0xff0 mm/slub.c:4398
     __kmalloc_reserve net/core/skbuff.c:140 [inline]
     __alloc_skb+0x309/0xa20 net/core/skbuff.c:208
     alloc_skb include/linux/skbuff.h:1012 [inline]
     alloc_skb_with_frags+0x186/0xa60 net/core/skbuff.c:5287
     sock_alloc_send_pskb+0xafd/0x10a0 net/core/sock.c:2091
     sock_alloc_send_skb+0xca/0xe0 net/core/sock.c:2108
     __ip_append_data+0x34cd/0x5000 net/ipv4/ip_output.c:998
     ip_append_data+0x324/0x480 net/ipv4/ip_output.c:1220
     icmp_push_reply+0x23d/0x7e0 net/ipv4/icmp.c:375
     __icmp_send+0x2ea3/0x30f0 net/ipv4/icmp.c:737
     icmp_send include/net/icmp.h:47 [inline]
     ipv4_link_failure+0x6d/0x230 net/ipv4/route.c:1190
     dst_link_failure include/net/dst.h:427 [inline]
     arp_error_report+0x106/0x1a0 net/ipv4/arp.c:297
     neigh_invalidate+0x359/0x8e0 net/core/neighbour.c:992
     neigh_timer_handler+0xdf2/0x1280 net/core/neighbour.c:1078
     call_timer_fn+0x285/0x600 kernel/time/timer.c:1325
     expire_timers kernel/time/timer.c:1362 [inline]
     __run_timers+0xdb4/0x11d0 kernel/time/timer.c:1681
     run_timer_softirq+0x2e/0x50 kernel/time/timer.c:1694
     __do_softirq+0x53f/0x93a kernel/softirq.c:293
    
    Fixes: 26fc181e6cac ("fou, fou6: do not assume linear skbs")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Stefano Brivio <sbrivio@redhat.com>
    Cc: Sabrina Dubroca <sd@queasysnail.net>
    Acked-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c4b5717a016849b4eb437013e662f3546a0ed163
Author: Li RongQing <lirongqing@baidu.com>
Date:   Wed Mar 6 14:46:27 2019 +0800

    connector: fix unsafe usage of ->real_parent
    
    [ Upstream commit 6d2b0f02f5a07a4bf02e4cbc90d7eaa85cac2986 ]
    
    proc_exit_connector() uses ->real_parent lockless. This is not
    safe that its parent can go away at any moment, so use RCU to
    protect it, and ensure that this task is not released.
    
    [  747.624551] ==================================================================
    [  747.632946] BUG: KASAN: use-after-free in proc_exit_connector+0x1f7/0x310
    [  747.640686] Read of size 4 at addr ffff88a0276988e0 by task sshd/2882
    [  747.648032]
    [  747.649804] CPU: 11 PID: 2882 Comm: sshd Tainted: G            E     4.19.26-rc2 #11
    [  747.658629] Hardware name: IBM x3550M4 -[7914OFV]-/00AM544, BIOS -[D7E142BUS-1.71]- 07/31/2014
    [  747.668419] Call Trace:
    [  747.671269]  dump_stack+0xf0/0x19b
    [  747.675186]  ? show_regs_print_info+0x5/0x5
    [  747.679988]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  747.685302]  print_address_description+0x6a/0x270
    [  747.691162]  kasan_report+0x258/0x380
    [  747.695835]  ? proc_exit_connector+0x1f7/0x310
    [  747.701402]  proc_exit_connector+0x1f7/0x310
    [  747.706767]  ? proc_coredump_connector+0x2d0/0x2d0
    [  747.712715]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.718270]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.723820]  ? ___preempt_schedule+0x16/0x18
    [  747.729193]  ? ___preempt_schedule+0x16/0x18
    [  747.734574]  do_exit+0xa11/0x14f0
    [  747.738880]  ? mm_update_next_owner+0x590/0x590
    [  747.744525]  ? debug_show_all_locks+0x3c0/0x3c0
    [  747.761448]  ? ktime_get_coarse_real_ts64+0xeb/0x1c0
    [  747.767589]  ? lockdep_hardirqs_on+0x1a6/0x290
    [  747.773154]  ? check_chain_key+0x139/0x1f0
    [  747.778345]  ? check_flags.part.35+0x240/0x240
    [  747.783908]  ? __lock_acquire+0x2300/0x2300
    [  747.789171]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.795316]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.801457]  ? do_raw_spin_unlock+0x10f/0x1e0
    [  747.806914]  ? do_raw_spin_trylock+0x120/0x120
    [  747.812481]  ? preempt_count_sub+0x14/0xc0
    [  747.817645]  ? _raw_spin_unlock+0x2e/0x50
    [  747.822708]  ? __handle_mm_fault+0x12db/0x1fa0
    [  747.828367]  ? __pmd_alloc+0x2d0/0x2d0
    [  747.833143]  ? check_noncircular+0x50/0x50
    [  747.838309]  ? match_held_lock+0x7f/0x340
    [  747.843380]  ? check_noncircular+0x50/0x50
    [  747.848561]  ? handle_mm_fault+0x21a/0x5f0
    [  747.853730]  ? check_flags.part.35+0x240/0x240
    [  747.859290]  ? check_chain_key+0x139/0x1f0
    [  747.864474]  ? __do_page_fault+0x40f/0x760
    [  747.869655]  ? __audit_syscall_entry+0x4b/0x1f0
    [  747.875319]  ? syscall_trace_enter+0x1d5/0x7b0
    [  747.880877]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.887895]  ? trace_raw_output_sys_exit+0x80/0x80
    [  747.893860]  ? up_read+0x3b/0x90
    [  747.898142]  ? stop_critical_timings+0x260/0x260
    [  747.903909]  do_group_exit+0xe0/0x1c0
    [  747.908591]  ? __x64_sys_exit+0x30/0x30
    [  747.913460]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.920485]  ? tracer_hardirqs_on+0x270/0x270
    [  747.925956]  __x64_sys_exit_group+0x28/0x30
    [  747.931214]  do_syscall_64+0x117/0x400
    [  747.935988]  ? syscall_return_slowpath+0x2f0/0x2f0
    [  747.941931]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.947788]  ? trace_hardirqs_on_caller+0x1d0/0x1d0
    [  747.953838]  ? lockdep_sys_exit+0x16/0x8e
    [  747.958915]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.964784]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  747.971021] RIP: 0033:0x7f572f154c68
    [  747.975606] Code: Bad RIP value.
    [  747.979791] RSP: 002b:00007ffed2dfaa58 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    [  747.989324] RAX: ffffffffffffffda RBX: 00007f572f431840 RCX: 00007f572f154c68
    [  747.997910] RDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001
    [  748.006495] RBP: 0000000000000001 R08: 00000000000000e7 R09: fffffffffffffee0
    [  748.015079] R10: 00007f572f4387e8 R11: 0000000000000246 R12: 00007f572f431840
    [  748.023664] R13: 000055a7f90f2c50 R14: 000055a7f96e2310 R15: 000055a7f96e2310
    [  748.032287]
    [  748.034509] Allocated by task 2300:
    [  748.038982]  kasan_kmalloc+0xa0/0xd0
    [  748.043562]  kmem_cache_alloc_node+0xf5/0x2e0
    [  748.049018]  copy_process+0x1781/0x4790
    [  748.053884]  _do_fork+0x166/0x9a0
    [  748.058163]  do_syscall_64+0x117/0x400
    [  748.062943]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.069180]
    [  748.071405] Freed by task 15395:
    [  748.075591]  __kasan_slab_free+0x130/0x180
    [  748.080752]  kmem_cache_free+0xc2/0x310
    [  748.085619]  free_task+0xea/0x130
    [  748.089901]  __put_task_struct+0x177/0x230
    [  748.095063]  finish_task_switch+0x51b/0x5d0
    [  748.100315]  __schedule+0x506/0xfa0
    [  748.104791]  schedule+0xca/0x260
    [  748.108978]  futex_wait_queue_me+0x27e/0x420
    [  748.114333]  futex_wait+0x251/0x550
    [  748.118814]  do_futex+0x75b/0xf80
    [  748.123097]  __x64_sys_futex+0x231/0x2a0
    [  748.128065]  do_syscall_64+0x117/0x400
    [  748.132835]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.139066]
    [  748.141289] The buggy address belongs to the object at ffff88a027698000
    [  748.141289]  which belongs to the cache task_struct of size 12160
    [  748.156589] The buggy address is located 2272 bytes inside of
    [  748.156589]  12160-byte region [ffff88a027698000, ffff88a02769af80)
    [  748.171114] The buggy address belongs to the page:
    [  748.177055] page:ffffea00809da600 count:1 mapcount:0 mapping:ffff888107d01e00 index:0x0 compound_mapcount: 0
    [  748.189136] flags: 0x57ffffc0008100(slab|head)
    [  748.194688] raw: 0057ffffc0008100 ffffea00809a3200 0000000300000003 ffff888107d01e00
    [  748.204424] raw: 0000000000000000 0000000000020002 00000001ffffffff 0000000000000000
    [  748.214146] page dumped because: kasan: bad access detected
    [  748.220976]
    [  748.223197] Memory state around the buggy address:
    [  748.229128]  ffff88a027698780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.238271]  ffff88a027698800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.247414] >ffff88a027698880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.256564]                                                        ^
    [  748.264267]  ffff88a027698900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.273493]  ffff88a027698980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.282630] ==================================================================
    
    Fixes: b086ff87251b4a4 ("connector: add parent pid and tgid to coredump and exit events")
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
