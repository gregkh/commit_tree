commit 61b7ab3507b38377aade089bcc2ddd77d7115e72
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 26 10:27:10 2020 +0200

    Linux 4.4.234
    
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1dee8b843cba4cd7b4d5d454e24ad16d88046bed
Author: Will Deacon <will@kernel.org>
Date:   Mon Aug 24 12:28:54 2020 +0100

    KVM: arm/arm64: Don't reschedule in unmap_stage2_range()
    
    Upstream commits fdfe7cbd5880 ("KVM: Pass MMU notifier range flags to
    kvm_unmap_hva_range()") and b5331379bc62 ("KVM: arm64: Only reschedule
    if MMU_NOTIFIER_RANGE_BLOCKABLE is not set") fix a "sleeping from invalid
    context" BUG caused by unmap_stage2_range() attempting to reschedule when
    called on the OOM path.
    
    Unfortunately, these patches rely on the MMU notifier callback being
    passed knowledge about whether or not blocking is permitted, which was
    introduced in 4.19. Rather than backport this considerable amount of
    infrastructure just for KVM on arm, instead just remove the conditional
    reschedule.
    
    Cc: <stable@vger.kernel.org> # v4.4 only
    Cc: Marc Zyngier <maz@kernel.org>
    Cc: Suzuki K Poulose <suzuki.poulose@arm.com>
    Cc: James Morse <james.morse@arm.com>
    Signed-off-by: Will Deacon <will@kernel.org>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 61e37ca3378f39dffde30c0271cf1f87e8241ce5
Author: Adam Ford <aford173@gmail.com>
Date:   Thu Jul 9 07:12:32 2020 -0500

    omapfb: dss: Fix max fclk divider for omap36xx
    
    There appears to be a timing issue where using a divider of 32 breaks
    the DSS for OMAP36xx despite the TRM stating 32 is a valid
    number.  Through experimentation, it appears that 31 works.
    
    This same fix was issued for kernels 4.5+.  However, between
    kernels 4.4 and 4.5, the directory structure was changed when the
    dss directory was moved inside the omapfb directory. That broke the
    patch on kernels older than 4.5, because it didn't permit the patch
    to apply cleanly for 4.4 and older.
    
    A similar patch was applied to the 3.16 kernel already, but not to 4.4.
    Commit 4b911101a5cd ("drm/omap: fix max fclk divider for omap36xx") is
    on the 3.16 stable branch with notes from Ben about the path change.
    
    Since this was applied for 3.16 already, this patch is for kernels
    3.17 through 4.4 only.
    
    Fixes: f7018c213502 ("video: move fbdev to drivers/video/fbdev")
    Cc: <stable@vger.kernel.org> #3.17 - 4.4
    CC: <tomi.valkeinen@ti.com>
    Signed-off-by: Adam Ford <aford173@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 18037dda3974247e4d3c34ee29898d2436f12819
Author: Juergen Gross <jgross@suse.com>
Date:   Thu Aug 20 08:59:08 2020 +0200

    xen: don't reschedule in preemption off sections
    
    For support of long running hypercalls xen_maybe_preempt_hcall() is
    calling cond_resched() in case a hypercall marked as preemptible has
    been interrupted.
    
    Normally this is no problem, as only hypercalls done via some ioctl()s
    are marked to be preemptible. In rare cases when during such a
    preemptible hypercall an interrupt occurs and any softirq action is
    started from irq_exit(), a further hypercall issued by the softirq
    handler will be regarded to be preemptible, too. This might lead to
    rescheduling in spite of the softirq handler potentially having set
    preempt_disable(), leading to splats like:
    
    BUG: sleeping function called from invalid context at drivers/xen/preempt.c:37
    in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 20775, name: xl
    INFO: lockdep is turned off.
    CPU: 1 PID: 20775 Comm: xl Tainted: G D W 5.4.46-1_prgmr_debug.el7.x86_64 #1
    Call Trace:
    <IRQ>
    dump_stack+0x8f/0xd0
    ___might_sleep.cold.76+0xb2/0x103
    xen_maybe_preempt_hcall+0x48/0x70
    xen_do_hypervisor_callback+0x37/0x40
    RIP: e030:xen_hypercall_xen_version+0xa/0x20
    Code: ...
    RSP: e02b:ffffc900400dcc30 EFLAGS: 00000246
    RAX: 000000000004000d RBX: 0000000000000200 RCX: ffffffff8100122a
    RDX: ffff88812e788000 RSI: 0000000000000000 RDI: 0000000000000000
    RBP: ffffffff83ee3ad0 R08: 0000000000000001 R09: 0000000000000001
    R10: 0000000000000000 R11: 0000000000000246 R12: ffff8881824aa0b0
    R13: 0000000865496000 R14: 0000000865496000 R15: ffff88815d040000
    ? xen_hypercall_xen_version+0xa/0x20
    ? xen_force_evtchn_callback+0x9/0x10
    ? check_events+0x12/0x20
    ? xen_restore_fl_direct+0x1f/0x20
    ? _raw_spin_unlock_irqrestore+0x53/0x60
    ? debug_dma_sync_single_for_cpu+0x91/0xc0
    ? _raw_spin_unlock_irqrestore+0x53/0x60
    ? xen_swiotlb_sync_single_for_cpu+0x3d/0x140
    ? mlx4_en_process_rx_cq+0x6b6/0x1110 [mlx4_en]
    ? mlx4_en_poll_rx_cq+0x64/0x100 [mlx4_en]
    ? net_rx_action+0x151/0x4a0
    ? __do_softirq+0xed/0x55b
    ? irq_exit+0xea/0x100
    ? xen_evtchn_do_upcall+0x2c/0x40
    ? xen_do_hypervisor_callback+0x29/0x40
    </IRQ>
    ? xen_hypercall_domctl+0xa/0x20
    ? xen_hypercall_domctl+0x8/0x20
    ? privcmd_ioctl+0x221/0x990 [xen_privcmd]
    ? do_vfs_ioctl+0xa5/0x6f0
    ? ksys_ioctl+0x60/0x90
    ? trace_hardirqs_off_thunk+0x1a/0x20
    ? __x64_sys_ioctl+0x16/0x20
    ? do_syscall_64+0x62/0x250
    ? entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Fix that by testing preempt_count() before calling cond_resched().
    
    In kernel 5.8 this can't happen any more due to the entry code rework
    (more than 100 patches, so not a candidate for backporting).
    
    The issue was introduced in kernel 4.3, so this patch should go into
    all stable kernels in [4.3 ... 5.7].
    
    Reported-by: Sarah Newman <srn@prgmr.com>
    Fixes: 0fa2f5cb2b0ecd8 ("sched/preempt, xen: Use need_resched() instead of should_resched()")
    Cc: Sarah Newman <srn@prgmr.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Tested-by: Chris Brannon <cmb@prgmr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e37966441481d76da3600abf0542b238eae82fa3
Author: Peter Xu <peterx@redhat.com>
Date:   Thu Aug 6 23:26:11 2020 -0700

    mm/hugetlb: fix calculation of adjust_range_if_pmd_sharing_possible
    
    commit 75802ca66354a39ab8e35822747cd08b3384a99a upstream.
    
    This is found by code observation only.
    
    Firstly, the worst case scenario should assume the whole range was covered
    by pmd sharing.  The old algorithm might not work as expected for ranges
    like (1g-2m, 1g+2m), where the adjusted range should be (0, 1g+2m) but the
    expected range should be (0, 2g).
    
    Since at it, remove the loop since it should not be required.  With that,
    the new code should be faster too when the invalidating range is huge.
    
    Mike said:
    
    : With range (1g-2m, 1g+2m) within a vma (0, 2g) the existing code will only
    : adjust to (0, 1g+2m) which is incorrect.
    :
    : We should cc stable.  The original reason for adjusting the range was to
    : prevent data corruption (getting wrong page).  Since the range is not
    : always adjusted correctly, the potential for corruption still exists.
    :
    : However, I am fairly confident that adjust_range_if_pmd_sharing_possible
    : is only gong to be called in two cases:
    :
    : 1) for a single page
    : 2) for range == entire vma
    :
    : In those cases, the current code should produce the correct results.
    :
    : To be safe, let's just cc stable.
    
    Fixes: 017b1660df89 ("mm: migration: fix migration of huge PMD shared pages")
    Signed-off-by: Peter Xu <peterx@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Mike Kravetz <mike.kravetz@oracle.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20200730201636.74778-1-peterx@redhat.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Mike Kravetz <mike.kravetz@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d85e2b06662e7f46d0f174ecc603fc1c3554d5cf
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Aug 22 18:25:52 2020 -0400

    do_epoll_ctl(): clean the failure exits up a bit
    
    commit 52c479697c9b73f628140dcdfcd39ea302d05482 upstream.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 89077f38db728c980dd0cc776400dff5c645f627
Author: Marc Zyngier <maz@kernel.org>
Date:   Wed Aug 19 17:12:17 2020 +0100

    epoll: Keep a reference on files added to the check list
    
    commit a9ed4a6560b8562b7e2e2bed9527e88001f7b682 upstream.
    
    When adding a new fd to an epoll, and that this new fd is an
    epoll fd itself, we recursively scan the fds attached to it
    to detect cycles, and add non-epool files to a "check list"
    that gets subsequently parsed.
    
    However, this check list isn't completely safe when deletions
    can happen concurrently. To sidestep the issue, make sure that
    a struct file placed on the check list sees its f_count increased,
    ensuring that a concurrent deletion won't result in the file
    disapearing from under our feet.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fabab559053d5e3f762e52d913cf689a9f242037
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Fri Jul 24 19:25:25 2020 +1000

    powerpc: Allow 4224 bytes of stack expansion for the signal frame
    
    commit 63dee5df43a31f3844efabc58972f0a206ca4534 upstream.
    
    We have powerpc specific logic in our page fault handling to decide if
    an access to an unmapped address below the stack pointer should expand
    the stack VMA.
    
    The code was originally added in 2004 "ported from 2.4". The rough
    logic is that the stack is allowed to grow to 1MB with no extra
    checking. Over 1MB the access must be within 2048 bytes of the stack
    pointer, or be from a user instruction that updates the stack pointer.
    
    The 2048 byte allowance below the stack pointer is there to cover the
    288 byte "red zone" as well as the "about 1.5kB" needed by the signal
    delivery code.
    
    Unfortunately since then the signal frame has expanded, and is now
    4224 bytes on 64-bit kernels with transactional memory enabled. This
    means if a process has consumed more than 1MB of stack, and its stack
    pointer lies less than 4224 bytes from the next page boundary, signal
    delivery will fault when trying to expand the stack and the process
    will see a SEGV.
    
    The total size of the signal frame is the size of struct rt_sigframe
    (which includes the red zone) plus __SIGNAL_FRAMESIZE (128 bytes on
    64-bit).
    
    The 2048 byte allowance was correct until 2008 as the signal frame
    was:
    
    struct rt_sigframe {
            struct ucontext    uc;                           /*     0  1440 */
            /* --- cacheline 11 boundary (1408 bytes) was 32 bytes ago --- */
            long unsigned int          _unused[2];           /*  1440    16 */
            unsigned int               tramp[6];             /*  1456    24 */
            struct siginfo *           pinfo;                /*  1480     8 */
            void *                     puc;                  /*  1488     8 */
            struct siginfo     info;                         /*  1496   128 */
            /* --- cacheline 12 boundary (1536 bytes) was 88 bytes ago --- */
            char                       abigap[288];          /*  1624   288 */
    
            /* size: 1920, cachelines: 15, members: 7 */
            /* padding: 8 */
    };
    
    1920 + 128 = 2048
    
    Then in commit ce48b2100785 ("powerpc: Add VSX context save/restore,
    ptrace and signal support") (Jul 2008) the signal frame expanded to
    2304 bytes:
    
    struct rt_sigframe {
            struct ucontext    uc;                           /*     0  1696 */      <--
            /* --- cacheline 13 boundary (1664 bytes) was 32 bytes ago --- */
            long unsigned int          _unused[2];           /*  1696    16 */
            unsigned int               tramp[6];             /*  1712    24 */
            struct siginfo *           pinfo;                /*  1736     8 */
            void *                     puc;                  /*  1744     8 */
            struct siginfo     info;                         /*  1752   128 */
            /* --- cacheline 14 boundary (1792 bytes) was 88 bytes ago --- */
            char                       abigap[288];          /*  1880   288 */
    
            /* size: 2176, cachelines: 17, members: 7 */
            /* padding: 8 */
    };
    
    2176 + 128 = 2304
    
    At this point we should have been exposed to the bug, though as far as
    I know it was never reported. I no longer have a system old enough to
    easily test on.
    
    Then in 2010 commit 320b2b8de126 ("mm: keep a guard page below a
    grow-down stack segment") caused our stack expansion code to never
    trigger, as there was always a VMA found for a write up to PAGE_SIZE
    below r1.
    
    That meant the bug was hidden as we continued to expand the signal
    frame in commit 2b0a576d15e0 ("powerpc: Add new transactional memory
    state to the signal context") (Feb 2013):
    
    struct rt_sigframe {
            struct ucontext    uc;                           /*     0  1696 */
            /* --- cacheline 13 boundary (1664 bytes) was 32 bytes ago --- */
            struct ucontext    uc_transact;                  /*  1696  1696 */      <--
            /* --- cacheline 26 boundary (3328 bytes) was 64 bytes ago --- */
            long unsigned int          _unused[2];           /*  3392    16 */
            unsigned int               tramp[6];             /*  3408    24 */
            struct siginfo *           pinfo;                /*  3432     8 */
            void *                     puc;                  /*  3440     8 */
            struct siginfo     info;                         /*  3448   128 */
            /* --- cacheline 27 boundary (3456 bytes) was 120 bytes ago --- */
            char                       abigap[288];          /*  3576   288 */
    
            /* size: 3872, cachelines: 31, members: 8 */
            /* padding: 8 */
            /* last cacheline: 32 bytes */
    };
    
    3872 + 128 = 4000
    
    And commit 573ebfa6601f ("powerpc: Increase stack redzone for 64-bit
    userspace to 512 bytes") (Feb 2014):
    
    struct rt_sigframe {
            struct ucontext    uc;                           /*     0  1696 */
            /* --- cacheline 13 boundary (1664 bytes) was 32 bytes ago --- */
            struct ucontext    uc_transact;                  /*  1696  1696 */
            /* --- cacheline 26 boundary (3328 bytes) was 64 bytes ago --- */
            long unsigned int          _unused[2];           /*  3392    16 */
            unsigned int               tramp[6];             /*  3408    24 */
            struct siginfo *           pinfo;                /*  3432     8 */
            void *                     puc;                  /*  3440     8 */
            struct siginfo     info;                         /*  3448   128 */
            /* --- cacheline 27 boundary (3456 bytes) was 120 bytes ago --- */
            char                       abigap[512];          /*  3576   512 */      <--
    
            /* size: 4096, cachelines: 32, members: 8 */
            /* padding: 8 */
    };
    
    4096 + 128 = 4224
    
    Then finally in 2017, commit 1be7107fbe18 ("mm: larger stack guard
    gap, between vmas") exposed us to the existing bug, because it changed
    the stack VMA to be the correct/real size, meaning our stack expansion
    code is now triggered.
    
    Fix it by increasing the allowance to 4224 bytes.
    
    Hard-coding 4224 is obviously unsafe against future expansions of the
    signal frame in the same way as the existing code. We can't easily use
    sizeof() because the signal frame structure is not in a header. We
    will either fix that, or rip out all the custom stack expansion
    checking logic entirely.
    
    Fixes: ce48b2100785 ("powerpc: Add VSX context save/restore, ptrace and signal support")
    Cc: stable@vger.kernel.org # v2.6.27+
    Reported-by: Tom Lane <tgl@sss.pgh.pa.us>
    Tested-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200724092528.1578671-2-mpe@ellerman.id.au
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a65608b5f6710c83d46d235e4c0f7f96f51a26d1
Author: Dinghao Liu <dinghao.liu@zju.edu.cn>
Date:   Thu Aug 13 16:41:10 2020 +0800

    ASoC: intel: Fix memleak in sst_media_open
    
    [ Upstream commit 062fa09f44f4fb3776a23184d5d296b0c8872eb9 ]
    
    When power_up_sst() fails, stream needs to be freed
    just like when try_module_get() fails. However, current
    code is returning directly and ends up leaking memory.
    
    Fixes: 0121327c1a68b ("ASoC: Intel: mfld-pcm: add control for powering up/down dsp")
    Signed-off-by: Dinghao Liu <dinghao.liu@zju.edu.cn>
    Acked-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20200813084112.26205-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 059b1480105478c5f68cf664301545b8cad6a7cf
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Wed Jun 17 14:19:04 2020 -0500

    ext4: fix potential negative array index in do_split()
    
    [ Upstream commit 5872331b3d91820e14716632ebb56b1399b34fe1 ]
    
    If for any reason a directory passed to do_split() does not have enough
    active entries to exceed half the size of the block, we can end up
    iterating over all "count" entries without finding a split point.
    
    In this case, count == move, and split will be zero, and we will
    attempt a negative index into map[].
    
    Guard against this by detecting this case, and falling back to
    split-to-half-of-count instead; in this case we will still have
    plenty of space (> half blocksize) in each split block.
    
    Fixes: ef2b02d3e617 ("ext34: ensure do_split leaves enough free space in both blocks")
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Reviewed-by: Andreas Dilger <adilger@dilger.ca>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/f53e246b-647c-64bb-16ec-135383c70ad7@redhat.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d0f13ebd32e13f18675a28368c1345dd1d463296
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Aug 11 18:33:54 2020 -0700

    alpha: fix annotation of io{read,write}{16,32}be()
    
    [ Upstream commit bd72866b8da499e60633ff28f8a4f6e09ca78efe ]
    
    These accessors must be used to read/write a big-endian bus.  The value
    returned or written is native-endian.
    
    However, these accessors are defined using be{16,32}_to_cpu() or
    cpu_to_be{16,32}() to make the endian conversion but these expect a
    __be{16,32} when none is present.  Keeping them would need a force cast
    that would solve nothing at all.
    
    So, do the conversion using swab{16,32}, like done in asm-generic for
    similar situations.
    
    Reported-by: kernel test robot <lkp@intel.com>
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/20200622114232.80039-1-luc.vanoostenryck@gmail.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cc97b011468dc86dfa188b0b06b4af19fe36758e
Author: Eiichi Tsukata <devel@etsukata.com>
Date:   Thu Aug 6 15:18:48 2020 -0700

    xfs: Fix UBSAN null-ptr-deref in xfs_sysfs_init
    
    [ Upstream commit 96cf2a2c75567ff56195fe3126d497a2e7e4379f ]
    
    If xfs_sysfs_init is called with parent_kobj == NULL, UBSAN
    shows the following warning:
    
      UBSAN: null-ptr-deref in ./fs/xfs/xfs_sysfs.h:37:23
      member access within null pointer of type 'struct xfs_kobj'
      Call Trace:
       dump_stack+0x10e/0x195
       ubsan_type_mismatch_common+0x241/0x280
       __ubsan_handle_type_mismatch_v1+0x32/0x40
       init_xfs_fs+0x12b/0x28f
       do_one_initcall+0xdd/0x1d0
       do_initcall_level+0x151/0x1b6
       do_initcalls+0x50/0x8f
       do_basic_setup+0x29/0x2b
       kernel_init_freeable+0x19f/0x20b
       kernel_init+0x11/0x1e0
       ret_from_fork+0x22/0x30
    
    Fix it by checking parent_kobj before the code accesses its member.
    
    Signed-off-by: Eiichi Tsukata <devel@etsukata.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    [darrick: minor whitespace edits]
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 759717b5c6cfedfadd66c36cda74bde763a36d77
Author: Mao Wenan <wenan.mao@linux.alibaba.com>
Date:   Sun Aug 2 15:44:09 2020 +0800

    virtio_ring: Avoid loop when vq is broken in virtqueue_poll
    
    [ Upstream commit 481a0d7422db26fb63e2d64f0652667a5c6d0f3e ]
    
    The loop may exist if vq->broken is true,
    virtqueue_get_buf_ctx_packed or virtqueue_get_buf_ctx_split
    will return NULL, so virtnet_poll will reschedule napi to
    receive packet, it will lead cpu usage(si) to 100%.
    
    call trace as below:
    virtnet_poll
            virtnet_receive
                    virtqueue_get_buf_ctx
                            virtqueue_get_buf_ctx_packed
                            virtqueue_get_buf_ctx_split
            virtqueue_napi_complete
                    virtqueue_poll           //return true
                    virtqueue_napi_schedule //it will reschedule napi
    
    to fix this, return false if vq is broken in virtqueue_poll.
    
    Signed-off-by: Mao Wenan <wenan.mao@linux.alibaba.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Link: https://lore.kernel.org/r/1596354249-96204-1-git-send-email-wenan.mao@linux.alibaba.com
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 49aae8e6f90f33858d286d93795c29a7e49b3989
Author: Javed Hasan <jhasan@marvell.com>
Date:   Wed Jul 29 01:18:23 2020 -0700

    scsi: libfc: Free skb in fc_disc_gpn_id_resp() for valid cases
    
    [ Upstream commit ec007ef40abb6a164d148b0dc19789a7a2de2cc8 ]
    
    In fc_disc_gpn_id_resp(), skb is supposed to get freed in all cases except
    for PTR_ERR. However, in some cases it didn't.
    
    This fix is to call fc_frame_free(fp) before function returns.
    
    Link: https://lore.kernel.org/r/20200729081824.30996-2-jhasan@marvell.com
    Reviewed-by: Girish Basrur <gbasrur@marvell.com>
    Reviewed-by: Santosh Vernekar <svernekar@marvell.com>
    Reviewed-by: Saurav Kashyap <skashyap@marvell.com>
    Reviewed-by: Shyam Sundar <ssundar@marvell.com>
    Signed-off-by: Javed Hasan <jhasan@marvell.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6156e6259c3d707fbafbedb017f334f5e19bf214
Author: Zhe Li <lizhe67@huawei.com>
Date:   Fri Jun 19 17:06:35 2020 +0800

    jffs2: fix UAF problem
    
    [ Upstream commit 798b7347e4f29553db4b996393caf12f5b233daf ]
    
    The log of UAF problem is listed below.
    BUG: KASAN: use-after-free in jffs2_rmdir+0xa4/0x1cc [jffs2] at addr c1f165fc
    Read of size 4 by task rm/8283
    =============================================================================
    BUG kmalloc-32 (Tainted: P    B      O   ): kasan: bad access detected
    -----------------------------------------------------------------------------
    
    INFO: Allocated in 0xbbbbbbbb age=3054364 cpu=0 pid=0
            0xb0bba6ef
            jffs2_write_dirent+0x11c/0x9c8 [jffs2]
            __slab_alloc.isra.21.constprop.25+0x2c/0x44
            __kmalloc+0x1dc/0x370
            jffs2_write_dirent+0x11c/0x9c8 [jffs2]
            jffs2_do_unlink+0x328/0x5fc [jffs2]
            jffs2_rmdir+0x110/0x1cc [jffs2]
            vfs_rmdir+0x180/0x268
            do_rmdir+0x2cc/0x300
            ret_from_syscall+0x0/0x3c
    INFO: Freed in 0x205b age=3054364 cpu=0 pid=0
            0x2e9173
            jffs2_add_fd_to_list+0x138/0x1dc [jffs2]
            jffs2_add_fd_to_list+0x138/0x1dc [jffs2]
            jffs2_garbage_collect_dirent.isra.3+0x21c/0x288 [jffs2]
            jffs2_garbage_collect_live+0x16bc/0x1800 [jffs2]
            jffs2_garbage_collect_pass+0x678/0x11d4 [jffs2]
            jffs2_garbage_collect_thread+0x1e8/0x3b0 [jffs2]
            kthread+0x1a8/0x1b0
            ret_from_kernel_thread+0x5c/0x64
    Call Trace:
    [c17ddd20] [c02452d4] kasan_report.part.0+0x298/0x72c (unreliable)
    [c17ddda0] [d2509680] jffs2_rmdir+0xa4/0x1cc [jffs2]
    [c17dddd0] [c026da04] vfs_rmdir+0x180/0x268
    [c17dde00] [c026f4e4] do_rmdir+0x2cc/0x300
    [c17ddf40] [c001a658] ret_from_syscall+0x0/0x3c
    
    The root cause is that we don't get "jffs2_inode_info.sem" before
    we scan list "jffs2_inode_info.dents" in function jffs2_rmdir.
    This patch add codes to get "jffs2_inode_info.sem" before we scan
    "jffs2_inode_info.dents" to slove the UAF problem.
    
    Signed-off-by: Zhe Li <lizhe67@huawei.com>
    Reviewed-by: Hou Tao <houtao1@huawei.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 340778e7c7f05fe9e1af79b68f8783da4deeb5b9
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Jul 14 10:36:09 2020 -0700

    xfs: fix inode quota reservation checks
    
    [ Upstream commit f959b5d037e71a4d69b5bf71faffa065d9269b4a ]
    
    xfs_trans_dqresv is the function that we use to make reservations
    against resource quotas.  Each resource contains two counters: the
    q_core counter, which tracks resources allocated on disk; and the dquot
    reservation counter, which tracks how much of that resource has either
    been allocated or reserved by threads that are working on metadata
    updates.
    
    For disk blocks, we compare the proposed reservation counter against the
    hard and soft limits to decide if we're going to fail the operation.
    However, for inodes we inexplicably compare against the q_core counter,
    not the incore reservation count.
    
    Since the q_core counter is always lower than the reservation count and
    we unlock the dquot between reservation and transaction commit, this
    means that multiple threads can reserve the last inode count before we
    hit the hard limit, and when they commit, we'll be well over the hard
    limit.
    
    Fix this by checking against the incore inode reservation counter, since
    we would appear to maintain that correctly (and that's what we report in
    GETQUOTA).
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Allison Collins <allison.henderson@oracle.com>
    Reviewed-by: Chandan Babu R <chandanrlinux@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 650504dcda62b6878c87fcc47bad8702e39d009f
Author: Greg Ungerer <gerg@linux-m68k.org>
Date:   Sat Jun 13 17:17:52 2020 +1000

    m68knommu: fix overwriting of bits in ColdFire V3 cache control
    
    [ Upstream commit bdee0e793cea10c516ff48bf3ebb4ef1820a116b ]
    
    The Cache Control Register (CACR) of the ColdFire V3 has bits that
    control high level caching functions, and also enable/disable the use
    of the alternate stack pointer register (the EUSP bit) to provide
    separate supervisor and user stack pointer registers. The code as
    it is today will blindly clear the EUSP bit on cache actions like
    invalidation. So it is broken for this case - and that will result
    in failed booting (interrupt entry and exit processing will be
    completely hosed).
    
    This only affects ColdFire V3 parts that support the alternate stack
    register (like the 5329 for example) - generally speaking new parts do,
    older parts don't. It has no impact on ColdFire V3 parts with the single
    stack pointer, like the 5307 for example.
    
    Fix the cache bit defines used, so they maintain the EUSP bit when
    carrying out cache actions through the CACR register.
    
    Signed-off-by: Greg Ungerer <gerg@linux-m68k.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1d75cce5bddbfc1358046785637a3786659aacc9
Author: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Date:   Tue Jul 21 22:24:07 2020 -0700

    Input: psmouse - add a newline when printing 'proto' by sysfs
    
    [ Upstream commit 4aec14de3a15cf9789a0e19c847f164776f49473 ]
    
    When I cat parameter 'proto' by sysfs, it displays as follows. It's
    better to add a newline for easy reading.
    
    root@syzkaller:~# cat /sys/module/psmouse/parameters/proto
    autoroot@syzkaller:~#
    
    Signed-off-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Link: https://lore.kernel.org/r/20200720073846.120724-1-wangxiongfeng2@huawei.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 49abd862875fef2eba26a53aed0f617c550948bf
Author: Evgeny Novikov <novikov@ispras.ru>
Date:   Fri Jul 10 11:02:23 2020 +0200

    media: vpss: clean up resources in init
    
    [ Upstream commit 9c487b0b0ea7ff22127fe99a7f67657d8730ff94 ]
    
    If platform_driver_register() fails within vpss_init() resources are not
    cleaned up. The patch fixes this issue by introducing the corresponding
    error handling.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Evgeny Novikov <novikov@ispras.ru>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 407f42f84082d86b2971bd8272105c64fe8ba152
Author: Chuhong Yuan <hslester96@gmail.com>
Date:   Fri Jun 5 18:17:28 2020 +0200

    media: budget-core: Improve exception handling in budget_register()
    
    [ Upstream commit fc0456458df8b3421dba2a5508cd817fbc20ea71 ]
    
    budget_register() has no error handling after its failure.
    Add the missed undo functions for error handling to fix it.
    
    Signed-off-by: Chuhong Yuan <hslester96@gmail.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c6fda7312fa96721c802e0b118eb9c6174adead2
Author: Jan Kara <jack@suse.cz>
Date:   Fri Jul 31 18:21:35 2020 +0200

    ext4: fix checking of directory entry validity for inline directories
    
    [ Upstream commit 7303cb5bfe845f7d43cd9b2dbd37dbb266efda9b ]
    
    ext4_search_dir() and ext4_generic_delete_entry() can be called both for
    standard director blocks and for inline directories stored inside inode
    or inline xattr space. For the second case we didn't call
    ext4_check_dir_entry() with proper constraints that could result in
    accepting corrupted directory entry as well as false positive filesystem
    errors like:
    
    EXT4-fs error (device dm-0): ext4_search_dir:1395: inode #28320400:
    block 113246792: comm dockerd: bad entry in directory: directory entry too
    close to block end - offset=0, inode=28320403, rec_len=32, name_len=8,
    size=4096
    
    Fix the arguments passed to ext4_check_dir_entry().
    
    Fixes: 109ba779d6cc ("ext4: check for directory entries too close to block end")
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/20200731162135.8080-1-jack@suse.cz
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4cd702fe93848eeaf6c656e1ca7b4a394c0ebf10
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Apr 24 10:00:13 2017 -0700

    ext4: clean up ext4_match() and callers
    
    [ Upstream commit d9b9f8d5a88cb7881d9f1c2b7e9de9a3fe1dc9e2 ]
    
    When ext4 encryption was originally merged, we were encrypting the
    user-specified filename in ext4_match(), introducing a lot of additional
    complexity into ext4_match() and its callers.  This has since been
    changed to encrypt the filename earlier, so we can remove the gunk
    that's no longer needed.  This more or less reverts ext4_search_dir()
    and ext4_find_dest_de() to the way they were in the v4.0 kernel.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0c9ce43da97d6b9fd669a5762a607a583b9428f1
Author: Charan Teja Reddy <charante@codeaurora.org>
Date:   Thu Aug 20 17:42:27 2020 -0700

    mm, page_alloc: fix core hung in free_pcppages_bulk()
    
    commit 88e8ac11d2ea3acc003cf01bb5a38c8aa76c3cfd upstream.
    
    The following race is observed with the repeated online, offline and a
    delay between two successive online of memory blocks of movable zone.
    
    P1                                              P2
    
    Online the first memory block in
    the movable zone. The pcp struct
    values are initialized to default
    values,i.e., pcp->high = 0 &
    pcp->batch = 1.
    
                                            Allocate the pages from the
                                            movable zone.
    
    Try to Online the second memory
    block in the movable zone thus it
    entered the online_pages() but yet
    to call zone_pcp_update().
                                            This process is entered into
                                            the exit path thus it tries
                                            to release the order-0 pages
                                            to pcp lists through
                                            free_unref_page_commit().
                                            As pcp->high = 0, pcp->count = 1
                                            proceed to call the function
                                            free_pcppages_bulk().
    Update the pcp values thus the
    new pcp values are like, say,
    pcp->high = 378, pcp->batch = 63.
                                            Read the pcp's batch value using
                                            READ_ONCE() and pass the same to
                                            free_pcppages_bulk(), pcp values
                                            passed here are, batch = 63,
                                            count = 1.
    
                                            Since num of pages in the pcp
                                            lists are less than ->batch,
                                            then it will stuck in
                                            while(list_empty(list)) loop
                                            with interrupts disabled thus
                                            a core hung.
    
    Avoid this by ensuring free_pcppages_bulk() is called with proper count of
    pcp list pages.
    
    The mentioned race is some what easily reproducible without [1] because
    pcp's are not updated for the first memory block online and thus there is
    a enough race window for P2 between alloc+free and pcp struct values
    update through onlining of second memory block.
    
    With [1], the race still exists but it is very narrow as we update the pcp
    struct values for the first memory block online itself.
    
    This is not limited to the movable zone, it could also happen in cases
    with the normal zone (e.g., hotplug to a node that only has DMA memory, or
    no other memory yet).
    
    [1]: https://patchwork.kernel.org/patch/11696389/
    
    Fixes: 5f8dcc21211a ("page-allocator: split per-cpu list into one-list-per-migrate-type")
    Signed-off-by: Charan Teja Reddy <charante@codeaurora.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: David Hildenbrand <david@redhat.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Vinayak Menon <vinmenon@codeaurora.org>
    Cc: <stable@vger.kernel.org> [2.6+]
    Link: http://lkml.kernel.org/r/1597150703-19003-1-git-send-email-charante@codeaurora.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bd7f430181d9af1a7b29832ecf0da234674fc680
Author: Doug Berger <opendmb@gmail.com>
Date:   Thu Aug 20 17:42:24 2020 -0700

    mm: include CMA pages in lowmem_reserve at boot
    
    commit e08d3fdfe2dafa0331843f70ce1ff6c1c4900bf4 upstream.
    
    The lowmem_reserve arrays provide a means of applying pressure against
    allocations from lower zones that were targeted at higher zones.  Its
    values are a function of the number of pages managed by higher zones and
    are assigned by a call to the setup_per_zone_lowmem_reserve() function.
    
    The function is initially called at boot time by the function
    init_per_zone_wmark_min() and may be called later by accesses of the
    /proc/sys/vm/lowmem_reserve_ratio sysctl file.
    
    The function init_per_zone_wmark_min() was moved up from a module_init to
    a core_initcall to resolve a sequencing issue with khugepaged.
    Unfortunately this created a sequencing issue with CMA page accounting.
    
    The CMA pages are added to the managed page count of a zone when
    cma_init_reserved_areas() is called at boot also as a core_initcall.  This
    makes it uncertain whether the CMA pages will be added to the managed page
    counts of their zones before or after the call to
    init_per_zone_wmark_min() as it becomes dependent on link order.  With the
    current link order the pages are added to the managed count after the
    lowmem_reserve arrays are initialized at boot.
    
    This means the lowmem_reserve values at boot may be lower than the values
    used later if /proc/sys/vm/lowmem_reserve_ratio is accessed even if the
    ratio values are unchanged.
    
    In many cases the difference is not significant, but for example
    an ARM platform with 1GB of memory and the following memory layout
    
      cma: Reserved 256 MiB at 0x0000000030000000
      Zone ranges:
        DMA      [mem 0x0000000000000000-0x000000002fffffff]
        Normal   empty
        HighMem  [mem 0x0000000030000000-0x000000003fffffff]
    
    would result in 0 lowmem_reserve for the DMA zone.  This would allow
    userspace to deplete the DMA zone easily.
    
    Funnily enough
    
      $ cat /proc/sys/vm/lowmem_reserve_ratio
    
    would fix up the situation because as a side effect it forces
    setup_per_zone_lowmem_reserve.
    
    This commit breaks the link order dependency by invoking
    init_per_zone_wmark_min() as a postcore_initcall so that the CMA pages
    have the chance to be properly accounted in their zone(s) and allowing
    the lowmem_reserve arrays to receive consistent values.
    
    Fixes: bc22af74f271 ("mm: update min_free_kbytes from khugepaged after core initialization")
    Signed-off-by: Doug Berger <opendmb@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/1597423766-27849-1-git-send-email-opendmb@gmail.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2935e0a3cec1ffa558eea90db6279cff83aa3592
Author: Jann Horn <jannh@google.com>
Date:   Thu Aug 20 17:42:11 2020 -0700

    romfs: fix uninitialized memory leak in romfs_dev_read()
    
    commit bcf85fcedfdd17911982a3e3564fcfec7b01eebd upstream.
    
    romfs has a superblock field that limits the size of the filesystem; data
    beyond that limit is never accessed.
    
    romfs_dev_read() fetches a caller-supplied number of bytes from the
    backing device.  It returns 0 on success or an error code on failure;
    therefore, its API can't represent short reads, it's all-or-nothing.
    
    However, when romfs_dev_read() detects that the requested operation would
    cross the filesystem size limit, it currently silently truncates the
    requested number of bytes.  This e.g.  means that when the content of a
    file with size 0x1000 starts one byte before the filesystem size limit,
    ->readpage() will only fill a single byte of the supplied page while
    leaving the rest uninitialized, leaking that uninitialized memory to
    userspace.
    
    Fix it by returning an error code instead of truncating the read when the
    requested read operation would go beyond the end of the filesystem.
    
    Fixes: da4458bda237 ("NOMMU: Make it possible for RomFS to use MTD devices directly")
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20200818013202.2246365-1-jannh@google.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 72bb6330b9905b9063a3e30e4c1e947b057bc485
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Wed Jul 22 11:12:46 2020 -0400

    btrfs: don't show full path of bind mounts in subvol=
    
    [ Upstream commit 3ef3959b29c4a5bd65526ab310a1a18ae533172a ]
    
    Chris Murphy reported a problem where rpm ostree will bind mount a bunch
    of things for whatever voodoo it's doing.  But when it does this
    /proc/mounts shows something like
    
      /dev/sda /mnt/test btrfs rw,relatime,subvolid=256,subvol=/foo 0 0
      /dev/sda /mnt/test/baz btrfs rw,relatime,subvolid=256,subvol=/foo/bar 0 0
    
    Despite subvolid=256 being subvol=/foo.  This is because we're just
    spitting out the dentry of the mount point, which in the case of bind
    mounts is the source path for the mountpoint.  Instead we should spit
    out the path to the actual subvol.  Fix this by looking up the name for
    the subvolid we have mounted.  With this fix the same test looks like
    this
    
      /dev/sda /mnt/test btrfs rw,relatime,subvolid=256,subvol=/foo 0 0
      /dev/sda /mnt/test/baz btrfs rw,relatime,subvolid=256,subvol=/foo 0 0
    
    Reported-by: Chris Murphy <chris@colorremedies.com>
    CC: stable@vger.kernel.org # 4.4+
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6ebec50298965115e852dd141a542d2aee6ef0ad
Author: Marcos Paulo de Souza <mpdesouza@suse.com>
Date:   Fri Feb 21 14:56:12 2020 +0100

    btrfs: export helpers for subvolume name/id resolution
    
    [ Upstream commit c0c907a47dccf2cf26251a8fb4a8e7a3bf79ce84 ]
    
    The functions will be used outside of export.c and super.c to allow
    resolving subvolume name from a given id, eg. for subvolume deletion by
    id ioctl.
    
    Signed-off-by: Marcos Paulo de Souza <mpdesouza@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ split from the next patch ]
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 04af681e4c46d3287e80e9d0b4680ded2603c27b
Author: Hugh Dickins <hughd@google.com>
Date:   Thu Aug 20 17:42:02 2020 -0700

    khugepaged: adjust VM_BUG_ON_MM() in __khugepaged_enter()
    
    [ Upstream commit f3f99d63a8156c7a4a6b20aac22b53c5579c7dc1 ]
    
    syzbot crashes on the VM_BUG_ON_MM(khugepaged_test_exit(mm), mm) in
    __khugepaged_enter(): yes, when one thread is about to dump core, has set
    core_state, and is waiting for others, another might do something calling
    __khugepaged_enter(), which now crashes because I lumped the core_state
    test (known as "mmget_still_valid") into khugepaged_test_exit().  I still
    think it's best to lump them together, so just in this exceptional case,
    check mm->mm_users directly instead of khugepaged_test_exit().
    
    Fixes: bbe98f9cadff ("khugepaged: khugepaged_test_exit() check mmget_still_valid()")
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Yang Shi <shy828301@gmail.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Song Liu <songliubraving@fb.com>
    Cc: Mike Kravetz <mike.kravetz@oracle.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: <stable@vger.kernel.org>    [4.8+]
    Link: http://lkml.kernel.org/r/alpine.LSU.2.11.2008141503370.18085@eggly.anvils
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f7d00e2816ae3bbf322e758305acc02c326e8ca5
Author: Hugh Dickins <hughd@google.com>
Date:   Thu Aug 6 23:26:25 2020 -0700

    khugepaged: khugepaged_test_exit() check mmget_still_valid()
    
    [ Upstream commit bbe98f9cadff58cdd6a4acaeba0efa8565dabe65 ]
    
    Move collapse_huge_page()'s mmget_still_valid() check into
    khugepaged_test_exit() itself.  collapse_huge_page() is used for anon THP
    only, and earned its mmget_still_valid() check because it inserts a huge
    pmd entry in place of the page table's pmd entry; whereas
    collapse_file()'s retract_page_tables() or collapse_pte_mapped_thp()
    merely clears the page table's pmd entry.  But core dumping without mmap
    lock must have been as open to mistaking a racily cleared pmd entry for a
    page table at physical page 0, as exit_mmap() was.  And we certainly have
    no interest in mapping as a THP once dumping core.
    
    Fixes: 59ea6d06cfa9 ("coredump: fix race condition between collapse_huge_page() and core dumping")
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Song Liu <songliubraving@fb.com>
    Cc: Mike Kravetz <mike.kravetz@oracle.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: <stable@vger.kernel.org>    [4.8+]
    Link: http://lkml.kernel.org/r/alpine.LSU.2.11.2008021217020.27773@eggly.anvils
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c2c5147ee93e34f663627e75d56af430673eab28
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Thu Jun 13 15:56:11 2019 -0700

    coredump: fix race condition between collapse_huge_page() and core dumping
    
    [ Upstream commit 59ea6d06cfa9247b586a695c21f94afa7183af74 ]
    
    When fixing the race conditions between the coredump and the mmap_sem
    holders outside the context of the process, we focused on
    mmget_not_zero()/get_task_mm() callers in 04f5866e41fb70 ("coredump: fix
    race condition between mmget_not_zero()/get_task_mm() and core
    dumping"), but those aren't the only cases where the mmap_sem can be
    taken outside of the context of the process as Michal Hocko noticed
    while backporting that commit to older -stable kernels.
    
    If mmgrab() is called in the context of the process, but then the
    mm_count reference is transferred outside the context of the process,
    that can also be a problem if the mmap_sem has to be taken for writing
    through that mm_count reference.
    
    khugepaged registration calls mmgrab() in the context of the process,
    but the mmap_sem for writing is taken later in the context of the
    khugepaged kernel thread.
    
    collapse_huge_page() after taking the mmap_sem for writing doesn't
    modify any vma, so it's not obvious that it could cause a problem to the
    coredump, but it happens to modify the pmd in a way that breaks an
    invariant that pmd_trans_huge_lock() relies upon.  collapse_huge_page()
    needs the mmap_sem for writing just to block concurrent page faults that
    call pmd_trans_huge_lock().
    
    Specifically the invariant that "!pmd_trans_huge()" cannot become a
    "pmd_trans_huge()" doesn't hold while collapse_huge_page() runs.
    
    The coredump will call __get_user_pages() without mmap_sem for reading,
    which eventually can invoke a lockless page fault which will need a
    functional pmd_trans_huge_lock().
    
    So collapse_huge_page() needs to use mmget_still_valid() to check it's
    not running concurrently with the coredump...  as long as the coredump
    can invoke page faults without holding the mmap_sem for reading.
    
    This has "Fixes: khugepaged" to facilitate backporting, but in my view
    it's more a bug in the coredump code that will eventually have to be
    rewritten to stop invoking page faults without the mmap_sem for reading.
    So the long term plan is still to drop all mmget_still_valid().
    
    Link: http://lkml.kernel.org/r/20190607161558.32104-1-aarcange@redhat.com
    Fixes: ba76149f47d8 ("thp: khugepaged")
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Jann Horn <jannh@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Mike Kravetz <mike.kravetz@oracle.com>
    Cc: Peter Xu <peterx@redhat.com>
    Cc: Jason Gunthorpe <jgg@mellanox.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4b1003c3b6d8ea5c885a43410bc42c89ed89398b
Author: Ahmad Fatoum <a.fatoum@pengutronix.de>
Date:   Thu Jun 11 21:17:44 2020 +0200

    watchdog: f71808e_wdt: remove use of wrong watchdog_info option
    
    [ Upstream commit 802141462d844f2e6a4d63a12260d79b7afc4c34 ]
    
    The flags that should be or-ed into the watchdog_info.options by drivers
    all start with WDIOF_, e.g. WDIOF_SETTIMEOUT, which indicates that the
    driver's watchdog_ops has a usable set_timeout.
    
    WDIOC_SETTIMEOUT was used instead, which expands to 0xc0045706, which
    equals:
    
       WDIOF_FANFAULT | WDIOF_EXTERN1 | WDIOF_PRETIMEOUT | WDIOF_ALARMONLY |
       WDIOF_MAGICCLOSE | 0xc0045000
    
    These were so far indicated to userspace on WDIOC_GETSUPPORT.
    As the driver has not yet been migrated to the new watchdog kernel API,
    the constant can just be dropped without substitute.
    
    Fixes: 96cb4eb019ce ("watchdog: f71808e_wdt: new watchdog driver for Fintek F71808E and F71882FG")
    Cc: stable@vger.kernel.org
    Signed-off-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20200611191750.28096-4-a.fatoum@pengutronix.de
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 53a29e11b2ef75e454f88afc7cecf3998924a8e3
Author: Ahmad Fatoum <a.fatoum@pengutronix.de>
Date:   Thu Jun 11 21:17:43 2020 +0200

    watchdog: f71808e_wdt: indicate WDIOF_CARDRESET support in watchdog_info.options
    
    [ Upstream commit e871e93fb08a619dfc015974a05768ed6880fd82 ]
    
    The driver supports populating bootstatus with WDIOF_CARDRESET, but so
    far userspace couldn't portably determine whether absence of this flag
    meant no watchdog reset or no driver support. Or-in the bit to fix this.
    
    Fixes: b97cb21a4634 ("watchdog: f71808e_wdt: Fix WDTMOUT_STS register read")
    Cc: stable@vger.kernel.org
    Signed-off-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20200611191750.28096-3-a.fatoum@pengutronix.de
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 34c2166235171162c55ccdc2f3f77b377da76d7c
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 9 16:11:29 2020 -0700

    net/compat: Add missing sock updates for SCM_RIGHTS
    
    [ Upstream commit d9539752d23283db4692384a634034f451261e29 ]
    
    Add missed sock updates to compat path via a new helper, which will be
    used more in coming patches. (The net/core/scm.c code is left as-is here
    to assist with -stable backports for the compat path.)
    
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Sargun Dhillon <sargun@sargun.me>
    Cc: Jakub Kicinski <kuba@kernel.org>
    Cc: stable@vger.kernel.org
    Fixes: 48a87cc26c13 ("net: netprio: fd passed in SCM_RIGHTS datagram not set correctly")
    Fixes: d84295067fc7 ("net: net_cls: fd passed in SCM_RIGHTS datagram not set correctly")
    Acked-by: Christian Brauner <christian.brauner@ubuntu.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c5f1fa154b317a9c230d000a80407aed09fee1fd
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Fri Jul 10 22:11:23 2020 +0900

    perf probe: Fix memory leakage when the probe point is not found
    
    [ Upstream commit 12d572e785b15bc764e956caaa8a4c846fd15694 ]
    
    Fix the memory leakage in debuginfo__find_trace_events() when the probe
    point is not found in the debuginfo. If there is no probe point found in
    the debuginfo, debuginfo__find_probes() will NOT return -ENOENT, but 0.
    
    Thus the caller of debuginfo__find_probes() must check the tf.ntevs and
    release the allocated memory for the array of struct probe_trace_event.
    
    The current code releases the memory only if the debuginfo__find_probes()
    hits an error but not checks tf.ntevs. In the result, the memory allocated
    on *tevs are not released if tf.ntevs == 0.
    
    This fixes the memory leakage by checking tf.ntevs == 0 in addition to
    ret < 0.
    
    Fixes: ff741783506c ("perf probe: Introduce debuginfo to encapsulate dwarf information")
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Reviewed-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lore.kernel.org/lkml/159438668346.62703.10887420400718492503.stgit@devnote2
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4e09fc7e223029867d645a92892c14bd7c73e1ff
Author: Liu Ying <victor.liu@nxp.com>
Date:   Thu Jul 9 10:28:52 2020 +0800

    drm/imx: imx-ldb: Disable both channels for split mode in enc->disable()
    
    [ Upstream commit 3b2a999582c467d1883716b37ffcc00178a13713 ]
    
    Both of the two LVDS channels should be disabled for split mode
    in the encoder's ->disable() callback, because they are enabled
    in the encoder's ->enable() callback.
    
    Fixes: 6556f7f82b9c ("drm: imx: Move imx-drm driver out of staging")
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Pengutronix Kernel Team <kernel@pengutronix.de>
    Cc: NXP Linux Team <linux-imx@nxp.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Liu Ying <victor.liu@nxp.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
