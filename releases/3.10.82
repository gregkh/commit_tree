commit b3d78448444995411ba87af2237391bf68fc358d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jun 29 12:08:45 2015 -0700

    Linux 3.10.82

commit 17c06c69128f310cac51858455b1483a30c875ad
Author: James Smart <james.smart@emulex.com>
Date:   Wed May 7 17:16:46 2014 -0400

    lpfc: Add iotag memory barrier
    
    commit 27f344eb15dd0da80ebec80c7245e8c85043f841 upstream.
    
    Add a memory barrier to ensure the valid bit is read before
    any of the cqe payload is read. This fixes an issue seen
    on Power where the cqe payload was getting loaded before
    the valid bit. When this occurred, we saw an iotag out of
    range error when a command completed, but since the iotag
    looked invalid the command didn't get completed to scsi core.
    Later we hit the command timeout, attempted to abort the command,
    then waited for the aborted command to get returned. Since the
    adapter already returned the command, we timeout waiting,
    and end up escalating EEH all the way to host reset. This
    patch fixes this issue.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Smart <james.smart@emulex.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 14f81062f365fa9e3839bb2a16862217b71a553c
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Tue Jun 16 22:11:06 2015 +0100

    pipe: iovec: Fix memory corruption when retrying atomic copy as non-atomic
    
    pipe_iov_copy_{from,to}_user() may be tried twice with the same iovec,
    the first time atomically and the second time not.  The second attempt
    needs to continue from the iovec position, pipe buffer offset and
    remaining length where the first attempt failed, but currently the
    pipe buffer offset and remaining length are reset.  This will corrupt
    the piped data (possibly also leading to an information leak between
    processes) and may also corrupt kernel memory.
    
    This was fixed upstream by commits f0d1bec9d58d ("new helper:
    copy_page_from_iter()") and 637b58c2887e ("switch pipe_read() to
    copy_page_to_iter()"), but those aren't suitable for stable.  This fix
    for older kernel versions was made by Seth Jennings for RHEL and I
    have extracted it from their update.
    
    CVE-2015-1805
    
    References: https://bugzilla.redhat.com/show_bug.cgi?id=1202855
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 97d905e8568ff57c36c3e89b23b1c0f9f5146f96
Author: Adam Jackson <ajax@redhat.com>
Date:   Mon Jun 15 16:16:15 2015 -0400

    drm/mgag200: Reject non-character-cell-aligned mode widths
    
    commit 25161084b1c1b0c29948f6f77266a35f302196b7 upstream.
    
    Turns out 1366x768 does not in fact work on this hardware.
    
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 63dec3118397e4a94b92d2c395b4310ecb449581
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Mon Jun 15 17:50:25 2015 -0400

    tracing: Have filter check for balanced ops
    
    commit 2cf30dc180cea808077f003c5116388183e54f9e upstream.
    
    When the following filter is used it causes a warning to trigger:
    
     # cd /sys/kernel/debug/tracing
     # echo "((dev==1)blocks==2)" > events/ext4/ext4_truncate_exit/filter
    -bash: echo: write error: Invalid argument
     # cat events/ext4/ext4_truncate_exit/filter
    ((dev==1)blocks==2)
    ^
    parse_error: No error
    
     ------------[ cut here ]------------
     WARNING: CPU: 2 PID: 1223 at kernel/trace/trace_events_filter.c:1640 replace_preds+0x3c5/0x990()
     Modules linked in: bnep lockd grace bluetooth  ...
     CPU: 3 PID: 1223 Comm: bash Tainted: G        W       4.1.0-rc3-test+ #450
     Hardware name: Hewlett-Packard HP Compaq Pro 6300 SFF/339A, BIOS K01 v02.05 05/07/2012
      0000000000000668 ffff8800c106bc98 ffffffff816ed4f9 ffff88011ead0cf0
      0000000000000000 ffff8800c106bcd8 ffffffff8107fb07 ffffffff8136b46c
      ffff8800c7d81d48 ffff8800d4c2bc00 ffff8800d4d4f920 00000000ffffffea
     Call Trace:
      [<ffffffff816ed4f9>] dump_stack+0x4c/0x6e
      [<ffffffff8107fb07>] warn_slowpath_common+0x97/0xe0
      [<ffffffff8136b46c>] ? _kstrtoull+0x2c/0x80
      [<ffffffff8107fb6a>] warn_slowpath_null+0x1a/0x20
      [<ffffffff81159065>] replace_preds+0x3c5/0x990
      [<ffffffff811596b2>] create_filter+0x82/0xb0
      [<ffffffff81159944>] apply_event_filter+0xd4/0x180
      [<ffffffff81152bbf>] event_filter_write+0x8f/0x120
      [<ffffffff811db2a8>] __vfs_write+0x28/0xe0
      [<ffffffff811dda43>] ? __sb_start_write+0x53/0xf0
      [<ffffffff812e51e0>] ? security_file_permission+0x30/0xc0
      [<ffffffff811dc408>] vfs_write+0xb8/0x1b0
      [<ffffffff811dc72f>] SyS_write+0x4f/0xb0
      [<ffffffff816f5217>] system_call_fastpath+0x12/0x6a
     ---[ end trace e11028bd95818dcd ]---
    
    Worse yet, reading the error message (the filter again) it says that
    there was no error, when there clearly was. The issue is that the
    code that checks the input does not check for balanced ops. That is,
    having an op between a closed parenthesis and the next token.
    
    This would only cause a warning, and fail out before doing any real
    harm, but it should still not caues a warning, and the error reported
    should work:
    
     # cd /sys/kernel/debug/tracing
     # echo "((dev==1)blocks==2)" > events/ext4/ext4_truncate_exit/filter
    -bash: echo: write error: Invalid argument
     # cat events/ext4/ext4_truncate_exit/filter
    ((dev==1)blocks==2)
    ^
    parse_error: Meaningless filter expression
    
    And give no kernel warning.
    
    Link: http://lkml.kernel.org/r/20150615175025.7e809215@gandalf.local.home
    
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Reported-by: Vince Weaver <vincent.weaver@maine.edu>
    Tested-by: Vince Weaver <vincent.weaver@maine.edu>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    [ luis: backported to 3.16:
      - unconditionally decrement cnt as the OP_NOT logic was introduced only
        by e12c09cf3087 ("tracing: Add NOT to filtering logic") ]
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b6d2d39a05f2c6acb741b8edcab160be85b0b6bb
Author: Steve Cornelius <steve.cornelius@freescale.com>
Date:   Mon Jun 15 16:52:59 2015 -0700

    crypto: caam - fix RNG buffer cache alignment
    
    commit 412c98c1bef65fe7589f1300e93735d96130307c upstream.
    
    The hwrng output buffers (2) are cast inside of a a struct (caam_rng_ctx)
    allocated in one DMA-tagged region. While the kernel's heap allocator
    should place the overall struct on a cacheline aligned boundary, the 2
    buffers contained within may not necessarily align. Consenquently, the ends
    of unaligned buffers may not fully flush, and if so, stale data will be left
    behind, resulting in small repeating patterns.
    
    This fix aligns the buffers inside the struct.
    
    Note that not all of the data inside caam_rng_ctx necessarily needs to be
    DMA-tagged, only the buffers themselves require this. However, a fix would
    incur the expense of error-handling bloat in the case of allocation failure.
    
    Signed-off-by: Steve Cornelius <steve.cornelius@freescale.com>
    Signed-off-by: Victoria Milhoan <vicki.milhoan@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
