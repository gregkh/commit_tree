commit 0f5b96f6814376fe061a02604064b702ccf4bc6a
Author: Sasha Levin <sashal@kernel.org>
Date:   Thu Aug 26 09:19:05 2021 -0400

    Linux 4.4.282
    
    Tested-by: Pavel Machek (CIP) <pavel@denx.de>
    Tested-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c9e44fadc4a1955e2ec041ec7c31e1f2b3b8caa4
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Jul 8 12:56:13 2019 -0700

    mmc: dw_mmc: Fix occasional hang after tuning on eMMC
    
    [ Upstream commit ba2d139b02ba684c6c101de42fed782d6cd2b997 ]
    
    In commit 46d179525a1f ("mmc: dw_mmc: Wait for data transfer after
    response errors.") we fixed a tuning-induced hang that I saw when
    stress testing tuning on certain SD cards.  I won't re-hash that whole
    commit, but the summary is that as a normal part of tuning you need to
    deal with transfer errors and there were cases where these transfer
    errors was putting my system into a bad state causing all future
    transfers to fail.  That commit fixed handling of the transfer errors
    for me.
    
    In downstream Chrome OS my fix landed and had the same behavior for
    all SD/MMC commands.  However, it looks like when the commit landed
    upstream we limited it to only SD tuning commands.  Presumably this
    was to try to get around problems that Alim Akhtar reported on exynos
    [1].
    
    Unfortunately while stress testing reboots (and suspend/resume) on
    some rk3288-based Chromebooks I found the same problem on the eMMC on
    some of my Chromebooks (the ones with Hynix eMMC).  Since the eMMC
    tuning command is different (MMC_SEND_TUNING_BLOCK_HS200
    vs. MMC_SEND_TUNING_BLOCK) we were basically getting back into the
    same situation.
    
    I'm hoping that whatever problems exynos was having in the past are
    somehow magically fixed now and we can make the behavior the same for
    all commands.
    
    [1] https://lkml.kernel.org/r/CAGOxZ53WfNbaMe0_AM0qBqU47kAfgmPBVZC8K8Y-_J3mDMqW4A@mail.gmail.com
    
    Fixes: 46d179525a1f ("mmc: dw_mmc: Wait for data transfer after response errors.")
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Alim Akhtar <alim.akhtar@gmail.com>
    Cc: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 90cf9e72d4c093386cd4338e516932d97890cc6a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 19 17:29:45 2021 +0200

    ASoC: intel: atom: Fix breakage for PCM buffer address setup
    
    [ Upstream commit 65ca89c2b12cca0d473f3dd54267568ad3af55cc ]
    
    The commit 2e6b836312a4 ("ASoC: intel: atom: Fix reference to PCM
    buffer address") changed the reference of PCM buffer address to
    substream->runtime->dma_addr as the buffer address may change
    dynamically.  However, I forgot that the dma_addr field is still not
    set up for the CONTINUOUS buffer type (that this driver uses) yet in
    5.14 and earlier kernels, and it resulted in garbage I/O.  The problem
    will be fixed in 5.15, but we need to address it quickly for now.
    
    The fix is to deduce the address again from the DMA pointer with
    virt_to_phys(), but from the right one, substream->runtime->dma_area.
    
    Fixes: 2e6b836312a4 ("ASoC: intel: atom: Fix reference to PCM buffer address")
    Reported-and-tested-by: Hans de Goede <hdegoede@redhat.com>
    Cc: <stable@vger.kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/2048c6aa-2187-46bd-6772-36a4fb3c5aeb@redhat.com
    Link: https://lore.kernel.org/r/20210819152945.8510-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d2b2159b5a9f344e2ad98d23d3cf3f68e63f013c
Author: Dongliang Mu <mudongliangabcd@gmail.com>
Date:   Tue Aug 10 18:03:18 2021 +0800

    ipack: tpci200: fix many double free issues in tpci200_pci_probe
    
    [ Upstream commit 57a1681095f912239c7fb4d66683ab0425973838 ]
    
    The function tpci200_register called by tpci200_install and
    tpci200_unregister called by tpci200_uninstall are in pair. However,
    tpci200_unregister has some cleanup operations not in the
    tpci200_register. So the error handling code of tpci200_pci_probe has
    many different double free issues.
    
    Fix this problem by moving those cleanup operations out of
    tpci200_unregister, into tpci200_pci_remove and reverting
    the previous commit 9272e5d0028d ("ipack/carriers/tpci200:
    Fix a double free in tpci200_pci_probe").
    
    Fixes: 9272e5d0028d ("ipack/carriers/tpci200: Fix a double free in tpci200_pci_probe")
    Cc: stable@vger.kernel.org
    Reported-by: Dongliang Mu <mudongliangabcd@gmail.com>
    Signed-off-by: Dongliang Mu <mudongliangabcd@gmail.com>
    Link: https://lore.kernel.org/r/20210810100323.3938492-1-mudongliangabcd@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 591bf123ce10cd9c5b9b3f273c44fdc654966796
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Aug 11 18:14:41 2021 +0200

    ALSA: hda - fix the 'Capture Switch' value change notifications
    
    [ Upstream commit a2befe9380dd04ee76c871568deca00eedf89134 ]
    
    The original code in the cap_put_caller() function does not
    handle correctly the positive values returned from the passed
    function for multiple iterations. It means that the change
    notifications may be lost.
    
    Fixes: 352f7f914ebb ("ALSA: hda - Merge Realtek parser code to generic parser")
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=213851
    Cc: <stable@kernel.org>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Link: https://lore.kernel.org/r/20210811161441.1325250-1-perex@perex.cz
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 61eb2ee2c46b8e128489443fa3fd6d18669e0e1e
Author: Vincent Whitchurch <vincent.whitchurch@axis.com>
Date:   Wed Jun 30 12:22:32 2021 +0200

    mmc: dw_mmc: Fix hang on data CRC error
    
    [ Upstream commit 25f8203b4be1937c4939bb98623e67dcfd7da4d1 ]
    
    When a Data CRC interrupt is received, the driver disables the DMA, then
    sends the stop/abort command and then waits for Data Transfer Over.
    
    However, sometimes, when a data CRC error is received in the middle of a
    multi-block write transfer, the Data Transfer Over interrupt is never
    received, and the driver hangs and never completes the request.
    
    The driver sets the BMOD.SWR bit (SDMMC_IDMAC_SWRESET) when stopping the
    DMA, but according to the manual CMD.STOP_ABORT_CMD should be programmed
    "before assertion of SWR".  Do these operations in the recommended
    order.  With this change the Data Transfer Over is always received
    correctly in my tests.
    
    Signed-off-by: Vincent Whitchurch <vincent.whitchurch@axis.com>
    Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210630102232.16011-1-vincent.whitchurch@axis.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 613612a2ef1e1614eca90f590417ceecf5211699
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Thu Nov 17 16:40:37 2016 +0900

    mmc: dw_mmc: call the dw_mci_prep_stop_abort() by default
    
    [ Upstream commit e13c3c081845b51e8ba71a90e91c52679cfdbf89 ]
    
    stop_cmdr should be set to values relevant to stop command.
    It migth be assigned to values whatever there is mrq->stop or not.
    Then it doesn't need to use dw_mci_prepare_command().
    It's enough to use the prep_stop_abort for preparing stop command.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d7efc2186532797c375c622c69ee1d9d79c4f5d8
Author: Doug Anderson <dianders@chromium.org>
Date:   Tue Apr 26 10:03:58 2016 +0200

    mmc: dw_mmc: Wait for data transfer after response errors.
    
    [ Upstream commit 46d179525a1f6d16957dcb4624517bc04142b3e7 ]
    
    According to the DesignWare state machine description, after we get a
    "response error" or "response CRC error" we move into data transfer
    mode. That means that we don't necessarily need to special case
    trying to deal with the failure right away. We can wait until we are
    notified that the data transfer is complete (with or without errors)
    and then we can deal with the failure.
    
    It may sound strange to defer dealing with a command that we know will
    fail anyway, but this appears to fix a bug. During tuning (CMD19) on
    a specific card on an rk3288-based system, we found that we could get
    a "response CRC error". Sending the stop command after the "response
    CRC error" would then throw the system into a confused state causing
    all future tuning phases to report failure.
    
    When in the confused state, the controller would show these (hex codes
    are interrupt status register):
     CMD ERR: 0x00000046 (cmd=19)
     CMD ERR: 0x0000004e (cmd=12)
     DATA ERR: 0x00000208
     DATA ERR: 0x0000020c
     CMD ERR: 0x00000104 (cmd=19)
     CMD ERR: 0x00000104 (cmd=12)
     DATA ERR: 0x00000208
     DATA ERR: 0x0000020c
     ...
     ...
    
    It is inherently difficult to deal with the complexity of trying to
    correctly send a stop command while a data transfer is taking place
    since you need to deal with different corner cases caused by the fact
    that the data transfer could complete (with errors or without errors)
    during various places in sending the stop command (dw_mci_stop_dma,
    send_stop_abort, etc)
    
    Instead of adding a bunch of extra complexity to deal with this, it
    seems much simpler to just use the more straightforward (and less
    error-prone) path of letting the data transfer finish. There
    shouldn't be any huge benefit to sending the stop command slightly
    earlier, anyway.
    
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Cc: Alim Akhtar <alim.akhtar@gmail.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e5b8e3b9afdabbb4830203b04b129316fbcf5715
Author: Dinghao Liu <dinghao.liu@zju.edu.cn>
Date:   Mon Aug 16 21:14:04 2021 +0800

    net: qlcnic: add missed unlock in qlcnic_83xx_flash_read32
    
    [ Upstream commit 0a298d133893c72c96e2156ed7cb0f0c4a306a3e ]
    
    qlcnic_83xx_unlock_flash() is called on all paths after we call
    qlcnic_83xx_lock_flash(), except for one error path on failure
    of QLCRD32(), which may cause a deadlock. This bug is suggested
    by a static analysis tool, please advise.
    
    Fixes: 81d0aeb0a4fff ("qlcnic: flash template based firmware reset recovery")
    Signed-off-by: Dinghao Liu <dinghao.liu@zju.edu.cn>
    Link: https://lore.kernel.org/r/20210816131405.24024-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d66736076bd84742c18397785476e9a84d5b54ef
Author: Pavel Skripkin <paskripkin@gmail.com>
Date:   Fri Aug 13 18:14:33 2021 +0300

    net: 6pack: fix slab-out-of-bounds in decode_data
    
    [ Upstream commit 19d1532a187669ce86d5a2696eb7275310070793 ]
    
    Syzbot reported slab-out-of bounds write in decode_data().
    The problem was in missing validation checks.
    
    Syzbot's reproducer generated malicious input, which caused
    decode_data() to be called a lot in sixpack_decode(). Since
    rx_count_cooked is only 400 bytes and noone reported before,
    that 400 bytes is not enough, let's just check if input is malicious
    and complain about buffer overrun.
    
    Fail log:
    ==================================================================
    BUG: KASAN: slab-out-of-bounds in drivers/net/hamradio/6pack.c:843
    Write of size 1 at addr ffff888087c5544e by task kworker/u4:0/7
    
    CPU: 0 PID: 7 Comm: kworker/u4:0 Not tainted 5.6.0-rc3-syzkaller #0
    ...
    Workqueue: events_unbound flush_to_ldisc
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x197/0x210 lib/dump_stack.c:118
     print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374
     __kasan_report.cold+0x1b/0x32 mm/kasan/report.c:506
     kasan_report+0x12/0x20 mm/kasan/common.c:641
     __asan_report_store1_noabort+0x17/0x20 mm/kasan/generic_report.c:137
     decode_data.part.0+0x23b/0x270 drivers/net/hamradio/6pack.c:843
     decode_data drivers/net/hamradio/6pack.c:965 [inline]
     sixpack_decode drivers/net/hamradio/6pack.c:968 [inline]
    
    Reported-and-tested-by: syzbot+fc8cd9a673d4577fb2e4@syzkaller.appspotmail.com
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Signed-off-by: Pavel Skripkin <paskripkin@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 33d7135a1d43feb935420f3514ce12d959149783
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Aug 8 16:04:40 2021 -0700

    dccp: add do-while-0 stubs for dccp_pr_debug macros
    
    [ Upstream commit 86aab09a4870bb8346c9579864588c3d7f555299 ]
    
    GCC complains about empty macros in an 'if' statement, so convert
    them to 'do {} while (0)' macros.
    
    Fixes these build warnings:
    
    net/dccp/output.c: In function 'dccp_xmit_packet':
    ../net/dccp/output.c:283:71: warning: suggest braces around empty body in an 'if' statement [-Wempty-body]
      283 |                 dccp_pr_debug("transmit_skb() returned err=%d\n", err);
    net/dccp/ackvec.c: In function 'dccp_ackvec_update_old':
    ../net/dccp/ackvec.c:163:80: warning: suggest braces around empty body in an 'else' statement [-Wempty-body]
      163 |                                               (unsigned long long)seqno, state);
    
    Fixes: dc841e30eaea ("dccp: Extend CCID packet dequeueing interface")
    Fixes: 380240864451 ("dccp ccid-2: Update code for the Ack Vector input/registration routine")
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: dccp@vger.kernel.org
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jakub Kicinski <kuba@kernel.org>
    Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 84805a23ac4310c0e9f4a400c090f42ad56a0b20
Author: Ole Bjørn Midtbø <omidtbo@cisco.com>
Date:   Sat Oct 17 13:15:44 2020 +0200

    Bluetooth: hidp: use correct wait queue when removing ctrl_wait
    
    [ Upstream commit cca342d98bef68151a80b024f7bf5f388d1fbdea ]
    
    A different wait queue was used when removing ctrl_wait than when adding
    it. This effectively made the remove operation without locking compared
    to other operations on the wait queue ctrl_wait was part of. This caused
    issues like below where dead000000000100 is LIST_POISON1 and
    dead000000000200 is LIST_POISON2.
    
     list_add corruption. next->prev should be prev (ffffffc1b0a33a08), \
            but was dead000000000200. (next=ffffffc03ac77de0).
     ------------[ cut here ]------------
     CPU: 3 PID: 2138 Comm: bluetoothd Tainted: G           O    4.4.238+ #9
     ...
     ---[ end trace 0adc2158f0646eac ]---
     Call trace:
     [<ffffffc000443f78>] __list_add+0x38/0xb0
     [<ffffffc0000f0d04>] add_wait_queue+0x4c/0x68
     [<ffffffc00020eecc>] __pollwait+0xec/0x100
     [<ffffffc000d1556c>] bt_sock_poll+0x74/0x200
     [<ffffffc000bdb8a8>] sock_poll+0x110/0x128
     [<ffffffc000210378>] do_sys_poll+0x220/0x480
     [<ffffffc0002106f0>] SyS_poll+0x80/0x138
     [<ffffffc00008510c>] __sys_trace_return+0x0/0x4
    
     Unable to handle kernel paging request at virtual address dead000000000100
     ...
     CPU: 4 PID: 5387 Comm: kworker/u15:3 Tainted: G        W  O    4.4.238+ #9
     ...
     Call trace:
      [<ffffffc0000f079c>] __wake_up_common+0x7c/0xa8
      [<ffffffc0000f0818>] __wake_up+0x50/0x70
      [<ffffffc000be11b0>] sock_def_wakeup+0x58/0x60
      [<ffffffc000de5e10>] l2cap_sock_teardown_cb+0x200/0x224
      [<ffffffc000d3f2ac>] l2cap_chan_del+0xa4/0x298
      [<ffffffc000d45ea0>] l2cap_conn_del+0x118/0x198
      [<ffffffc000d45f8c>] l2cap_disconn_cfm+0x6c/0x78
      [<ffffffc000d29934>] hci_event_packet+0x564/0x2e30
      [<ffffffc000d19b0c>] hci_rx_work+0x10c/0x360
      [<ffffffc0000c2218>] process_one_work+0x268/0x460
      [<ffffffc0000c2678>] worker_thread+0x268/0x480
      [<ffffffc0000c94e0>] kthread+0x118/0x128
      [<ffffffc000085070>] ret_from_fork+0x10/0x20
      ---[ end trace 0adc2158f0646ead ]---
    
    Signed-off-by: Ole Bjørn Midtbø <omidtbo@cisco.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0d5f604e9f87c02ee4b6982c28457e78091d2759
Author: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
Date:   Mon Jul 26 17:24:02 2021 +0530

    scsi: core: Avoid printing an error if target_alloc() returns -ENXIO
    
    [ Upstream commit 70edd2e6f652f67d854981fd67f9ad0f1deaea92 ]
    
    Avoid printing a 'target allocation failed' error if the driver
    target_alloc() callback function returns -ENXIO. This return value
    indicates that the corresponding H:C:T:L entry is empty.
    
    Removing this error reduces the scan time if the user issues SCAN_WILD_CARD
    scan operation through sysfs parameter on a host with a lot of empty
    H:C:T:L entries.
    
    Avoiding the printk on -ENXIO matches the behavior of the other callback
    functions during scanning.
    
    Link: https://lore.kernel.org/r/20210726115402.1936-1-sreekanth.reddy@broadcom.com
    Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8eb70612706dc334bd0371de136c1f15af698556
Author: Harshvardhan Jha <harshvardhan.jha@oracle.com>
Date:   Thu Jul 8 13:16:42 2021 +0530

    scsi: megaraid_mm: Fix end of loop tests for list_for_each_entry()
    
    [ Upstream commit 77541f78eadfe9fdb018a7b8b69f0f2af2cf4b82 ]
    
    The list_for_each_entry() iterator, "adapter" in this code, can never be
    NULL.  If we exit the loop without finding the correct adapter then
    "adapter" points invalid memory that is an offset from the list head.  This
    will eventually lead to memory corruption and presumably a kernel crash.
    
    Link: https://lore.kernel.org/r/20210708074642.23599-1-harshvardhan.jha@oracle.com
    Acked-by: Sumit Saxena <sumit.saxena@broadcom.com>
    Signed-off-by: Harshvardhan Jha <harshvardhan.jha@oracle.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 731182179948207251054826d65efe61302c4384
Author: Peter Ujfalusi <peter.ujfalusi@gmail.com>
Date:   Sat Jul 17 22:00:21 2021 +0300

    dmaengine: of-dma: router_xlate to return -EPROBE_DEFER if controller is not yet available
    
    [ Upstream commit eda97cb095f2958bbad55684a6ca3e7d7af0176a ]
    
    If the router_xlate can not find the controller in the available DMA
    devices then it should return with -EPORBE_DEFER in a same way as the
    of_dma_request_slave_channel() does.
    
    The issue can be reproduced if the event router is registered before the
    DMA controller itself and a driver would request for a channel before the
    controller is registered.
    In of_dma_request_slave_channel():
    1. of_dma_find_controller() would find the dma_router
    2. ofdma->of_dma_xlate() would fail and returned NULL
    3. -ENODEV is returned as error code
    
    with this patch we would return in this case the correct -EPROBE_DEFER and
    the client can try to request the channel later.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@gmail.com>
    Link: https://lore.kernel.org/r/20210717190021.21897-1-peter.ujfalusi@gmail.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cc770cec14cf7cbba01013d5a0c4b9a993def7b8
Author: Dave Gerlach <d-gerlach@ti.com>
Date:   Fri Jul 16 09:07:30 2021 -0700

    ARM: dts: am43x-epos-evm: Reduce i2c0 bus speed for tps65218
    
    [ Upstream commit 20a6b3fd8e2e2c063b25fbf2ee74d86b898e5087 ]
    
    Based on the latest timing specifications for the TPS65218 from the data
    sheet, http://www.ti.com/lit/ds/symlink/tps65218.pdf, document SLDS206
    from November 2014, we must change the i2c bus speed to better fit within
    the minimum high SCL time required for proper i2c transfer.
    
    When running at 400khz, measurements show that SCL spends
    0.8125 uS/1.666 uS high/low which violates the requirement for minimum
    high period of SCL provided in datasheet Table 7.6 which is 1 uS.
    Switching to 100khz gives us 5 uS/5 uS high/low which both fall above
    the minimum given values for 100 khz, 4.0 uS/4.7 uS high/low.
    
    Without this patch occasionally a voltage set operation from the kernel
    will appear to have worked but the actual voltage reflected on the PMIC
    will not have updated, causing problems especially with cpufreq that may
    update to a higher OPP without actually raising the voltage on DCDC2,
    leading to a hang.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Kevin Hilman <khilman@baylibre.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0eee458057c0132e5ddaa1b6fe2080b1b6668ec0
Author: Yu Kuai <yukuai3@huawei.com>
Date:   Tue Jul 6 20:45:21 2021 +0800

    dmaengine: usb-dmac: Fix PM reference leak in usb_dmac_probe()
    
    [ Upstream commit 1da569fa7ec8cb0591c74aa3050d4ea1397778b4 ]
    
    pm_runtime_get_sync will increment pm usage counter even it failed.
    Forgetting to putting operation will result in reference leak here.
    Fix it by moving the error_pm label above the pm_runtime_put() in
    the error path.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Yu Kuai <yukuai3@huawei.com>
    Link: https://lore.kernel.org/r/20210706124521.1371901-1-yukuai3@huawei.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 53723b7be26ef31ad642ce5ffa8b42dec16db40e
Author: Maxim Levitsky <mlevitsk@redhat.com>
Date:   Mon Aug 16 16:02:31 2021 +0200

    KVM: nSVM: avoid picking up unsupported bits from L2 in int_ctl (CVE-2021-3653)
    
    [ upstream commit 0f923e07124df069ba68d8bb12324398f4b6b709 ]
    
    * Invert the mask of bits that we pick from L2 in
      nested_vmcb02_prepare_control
    
    * Invert and explicitly use VIRQ related bits bitmask in svm_clear_vintr
    
    This fixes a security issue that allowed a malicious L1 to run L2 with
    AVIC enabled, which allowed the L2 to exploit the uninitialized and enabled
    AVIC to read/write the host physical memory at some offsets.
    
    Fixes: 3d6368ef580a ("KVM: SVM: Add VMRUN handler")
    Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f1c2379db980d52f181d30321b2eb395e3a91858
Author: Nathan Chancellor <nathan@kernel.org>
Date:   Fri Jul 30 19:31:08 2021 -0700

    vmlinux.lds.h: Handle clang's module.{c,d}tor sections
    
    commit 848378812e40152abe9b9baf58ce2004f76fb988 upstream.
    
    A recent change in LLVM causes module_{c,d}tor sections to appear when
    CONFIG_K{A,C}SAN are enabled, which results in orphan section warnings
    because these are not handled anywhere:
    
    ld.lld: warning: arch/x86/pci/built-in.a(legacy.o):(.text.asan.module_ctor) is being placed in '.text.asan.module_ctor'
    ld.lld: warning: arch/x86/pci/built-in.a(legacy.o):(.text.asan.module_dtor) is being placed in '.text.asan.module_dtor'
    ld.lld: warning: arch/x86/pci/built-in.a(legacy.o):(.text.tsan.module_ctor) is being placed in '.text.tsan.module_ctor'
    
    Fangrui explains: "the function asan.module_ctor has the SHF_GNU_RETAIN
    flag, so it is in a separate section even with -fno-function-sections
    (default)".
    
    Place them in the TEXT_TEXT section so that these technologies continue
    to work with the newer compiler versions. All of the KASAN and KCSAN
    KUnit tests continue to pass after this change.
    
    Cc: stable@vger.kernel.org
    Link: https://github.com/ClangBuiltLinux/linux/issues/1432
    Link: https://github.com/llvm/llvm-project/commit/7b789562244ee941b7bf2cefeb3fc08a59a01865
    Signed-off-by: Nathan Chancellor <nathan@kernel.org>
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Fangrui Song <maskray@google.com>
    Acked-by: Marco Elver <elver@google.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Link: https://lore.kernel.org/r/20210731023107.1932981-1-nathan@kernel.org
    [nc: Fix conflicts due to lack of cf68fffb66d60 and 266ff2a8f51f0]
    Signed-off-by: Nathan Chancellor <nathan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 97e9d507936434a19575818defa123d5331c52b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 29 23:51:43 2021 +0200

    PCI/MSI: Enforce MSI[X] entry updates to be visible
    
    commit b9255a7cb51754e8d2645b65dd31805e282b4f3e upstream.
    
    Nothing enforces the posted writes to be visible when the function
    returns. Flush them even if the flush might be redundant when the entry is
    masked already as the unmask will flush as well. This is either setup or a
    rare affinity change event so the extra flush is not the end of the world.
    
    While this is more a theoretical issue especially the logic in the X86
    specific msi_set_affinity() function relies on the assumption that the
    update has reached the hardware when the function returns.
    
    Again, as this never has been enforced the Fixes tag refers to a commit in:
       git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git
    
    Fixes: f036d4ea5fa7 ("[PATCH] ia32 Message Signalled Interrupt support")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Marc Zyngier <maz@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210729222542.515188147@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 93a20a816fcf61e14ae6cf5efadbc88b5426dcd2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 29 23:51:42 2021 +0200

    PCI/MSI: Enforce that MSI-X table entry is masked for update
    
    commit da181dc974ad667579baece33c2c8d2d1e4558d5 upstream.
    
    The specification (PCIe r5.0, sec 6.1.4.5) states:
    
        For MSI-X, a function is permitted to cache Address and Data values
        from unmasked MSI-X Table entries. However, anytime software unmasks a
        currently masked MSI-X Table entry either by clearing its Mask bit or
        by clearing the Function Mask bit, the function must update any Address
        or Data values that it cached from that entry. If software changes the
        Address or Data value of an entry while the entry is unmasked, the
        result is undefined.
    
    The Linux kernel's MSI-X support never enforced that the entry is masked
    before the entry is modified hence the Fixes tag refers to a commit in:
          git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git
    
    Enforce the entry to be masked across the update.
    
    There is no point in enforcing this to be handled at all possible call
    sites as this is just pointless code duplication and the common update
    function is the obvious place to enforce this.
    
    Fixes: f036d4ea5fa7 ("[PATCH] ia32 Message Signalled Interrupt support")
    Reported-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Marc Zyngier <maz@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210729222542.462096385@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e6454fd429b0ba6513ac1de27a0bd6ccac021a40
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 29 23:51:41 2021 +0200

    PCI/MSI: Mask all unused MSI-X entries
    
    commit 7d5ec3d3612396dc6d4b76366d20ab9fc06f399f upstream.
    
    When MSI-X is enabled the ordering of calls is:
    
      msix_map_region();
      msix_setup_entries();
      pci_msi_setup_msi_irqs();
      msix_program_entries();
    
    This has a few interesting issues:
    
     1) msix_setup_entries() allocates the MSI descriptors and initializes them
        except for the msi_desc:masked member which is left zero initialized.
    
     2) pci_msi_setup_msi_irqs() allocates the interrupt descriptors and sets
        up the MSI interrupts which ends up in pci_write_msi_msg() unless the
        interrupt chip provides its own irq_write_msi_msg() function.
    
     3) msix_program_entries() does not do what the name suggests. It solely
        updates the entries array (if not NULL) and initializes the masked
        member for each MSI descriptor by reading the hardware state and then
        masks the entry.
    
    Obviously this has some issues:
    
     1) The uninitialized masked member of msi_desc prevents the enforcement
        of masking the entry in pci_write_msi_msg() depending on the cached
        masked bit. Aside of that half initialized data is a NONO in general
    
     2) msix_program_entries() only ensures that the actually allocated entries
        are masked. This is wrong as experimentation with crash testing and
        crash kernel kexec has shown.
    
        This limited testing unearthed that when the production kernel had more
        entries in use and unmasked when it crashed and the crash kernel
        allocated a smaller amount of entries, then a full scan of all entries
        found unmasked entries which were in use in the production kernel.
    
        This is obviously a device or emulation issue as the device reset
        should mask all MSI-X table entries, but obviously that's just part
        of the paper specification.
    
    Cure this by:
    
     1) Masking all table entries in hardware
     2) Initializing msi_desc::masked in msix_setup_entries()
     3) Removing the mask dance in msix_program_entries()
     4) Renaming msix_program_entries() to msix_update_entries() to
        reflect the purpose of that function.
    
    As the masking of unused entries has never been done the Fixes tag refers
    to a commit in:
       git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git
    
    Fixes: f036d4ea5fa7 ("[PATCH] ia32 Message Signalled Interrupt support")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Marc Zyngier <maz@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210729222542.403833459@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d54248ddd6c8c5846a231ac51b408e0372117b7b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 29 23:51:47 2021 +0200

    PCI/MSI: Protect msi_desc::masked for multi-MSI
    
    commit 77e89afc25f30abd56e76a809ee2884d7c1b63ce upstream.
    
    Multi-MSI uses a single MSI descriptor and there is a single mask register
    when the device supports per vector masking. To avoid reading back the mask
    register the value is cached in the MSI descriptor and updates are done by
    clearing and setting bits in the cache and writing it to the device.
    
    But nothing protects msi_desc::masked and the mask register from being
    modified concurrently on two different CPUs for two different Linux
    interrupts which belong to the same multi-MSI descriptor.
    
    Add a lock to struct device and protect any operation on the mask and the
    mask register with it.
    
    This makes the update of msi_desc::masked unconditional, but there is no
    place which requires a modification of the hardware register without
    updating the masked cache.
    
    msi_mask_irq() is now an empty wrapper which will be cleaned up in follow
    up changes.
    
    The problem goes way back to the initial support of multi-MSI, but picking
    the commit which introduced the mask cache is a valid cut off point
    (2.6.30).
    
    Fixes: f2440d9acbe8 ("PCI MSI: Refactor interrupt masking code")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Marc Zyngier <maz@kernel.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210729222542.726833414@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5c8a3894dae6b0342855b9b1a08c12e799fbbf07
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 29 23:51:46 2021 +0200

    PCI/MSI: Use msi_mask_irq() in pci_msi_shutdown()
    
    commit d28d4ad2a1aef27458b3383725bb179beb8d015c upstream.
    
    No point in using the raw write function from shutdown. Preparatory change
    to introduce proper serialization for the msi_desc::masked cache.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Marc Zyngier <maz@kernel.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210729222542.674391354@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 55db703b24b81da7e9e78fe96a2fd451e37a227f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 29 23:51:45 2021 +0200

    PCI/MSI: Correct misleading comments
    
    commit 689e6b5351573c38ccf92a0dd8b3e2c2241e4aff upstream.
    
    The comments about preserving the cached state in pci_msi[x]_shutdown() are
    misleading as the MSI descriptors are freed right after those functions
    return. So there is nothing to restore. Preparatory change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Marc Zyngier <maz@kernel.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210729222542.621609423@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7f6a68beb193d2054177655212b69ac4b2211b1b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 29 23:51:44 2021 +0200

    PCI/MSI: Do not set invalid bits in MSI mask
    
    commit 361fd37397f77578735907341579397d5bed0a2d upstream.
    
    msi_mask_irq() takes a mask and a flags argument. The mask argument is used
    to mask out bits from the cached mask and the flags argument to set bits.
    
    Some places invoke it with a flags argument which sets bits which are not
    used by the device, i.e. when the device supports up to 8 vectors a full
    unmask in some places sets the mask to 0xFFFFFF00. While devices probably
    do not care, it's still bad practice.
    
    Fixes: 7ba1930db02f ("PCI MSI: Unmask MSI if setup failed")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Marc Zyngier <maz@kernel.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210729222542.568173099@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f38090d7d7bb623bf0b0f02c49712ccb624d1382
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 29 23:51:40 2021 +0200

    PCI/MSI: Enable and mask MSI-X early
    
    commit 438553958ba19296663c6d6583d208dfb6792830 upstream.
    
    The ordering of MSI-X enable in hardware is dysfunctional:
    
     1) MSI-X is disabled in the control register
     2) Various setup functions
     3) pci_msi_setup_msi_irqs() is invoked which ends up accessing
        the MSI-X table entries
     4) MSI-X is enabled and masked in the control register with the
        comment that enabling is required for some hardware to access
        the MSI-X table
    
    Step #4 obviously contradicts #3. The history of this is an issue with the
    NIU hardware. When #4 was introduced the table access actually happened in
    msix_program_entries() which was invoked after enabling and masking MSI-X.
    
    This was changed in commit d71d6432e105 ("PCI/MSI: Kill redundant call of
    irq_set_msi_desc() for MSI-X interrupts") which removed the table write
    from msix_program_entries().
    
    Interestingly enough nobody noticed and either NIU still works or it did
    not get any testing with a kernel 3.19 or later.
    
    Nevertheless this is inconsistent and there is no reason why MSI-X can't be
    enabled and masked in the control register early on, i.e. move step #4
    above to step #1. This preserves the NIU workaround and has no side effects
    on other hardware.
    
    Fixes: d71d6432e105 ("PCI/MSI: Kill redundant call of irq_set_msi_desc() for MSI-X interrupts")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Ashok Raj <ashok.raj@intel.com>
    Reviewed-by: Marc Zyngier <maz@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210729222542.344136412@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d25b42e2d825fb16f61a1011d55b50fc45a8156f
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Fri Jul 30 17:01:46 2021 -0700

    x86/tools: Fix objdump version check again
    
    [ Upstream commit 839ad22f755132838f406751439363c07272ad87 ]
    
    Skip (omit) any version string info that is parenthesized.
    
    Warning: objdump version 15) is older than 2.19
    Warning: Skipping posttest.
    
    where 'objdump -v' says:
    GNU objdump (GNU Binutils; SUSE Linux Enterprise 15) 2.35.1.20201123-7.18
    
    Fixes: 8bee738bb1979 ("x86: Fix objdump version check in chkobjdump.awk for different formats.")
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
    Link: https://lore.kernel.org/r/20210731000146.2720-1-rdunlap@infradead.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a5d8667ebac2f866e98b948cfb9c115462fc90d6
Author: Maximilian Heyne <mheyne@amazon.de>
Date:   Thu Aug 12 13:09:27 2021 +0000

    xen/events: Fix race in set_evtchn_to_irq
    
    [ Upstream commit 88ca2521bd5b4e8b83743c01a2d4cb09325b51e9 ]
    
    There is a TOCTOU issue in set_evtchn_to_irq. Rows in the evtchn_to_irq
    mapping are lazily allocated in this function. The check whether the row
    is already present and the row initialization is not synchronized. Two
    threads can at the same time allocate a new row for evtchn_to_irq and
    add the irq mapping to the their newly allocated row. One thread will
    overwrite what the other has set for evtchn_to_irq[row] and therefore
    the irq mapping is lost. This will trigger a BUG_ON later in
    bind_evtchn_to_cpu:
    
      INFO: pci 0000:1a:15.4: [1d0f:8061] type 00 class 0x010802
      INFO: nvme 0000:1a:12.1: enabling device (0000 -> 0002)
      INFO: nvme nvme77: 1/0/0 default/read/poll queues
      CRIT: kernel BUG at drivers/xen/events/events_base.c:427!
      WARN: invalid opcode: 0000 [#1] SMP NOPTI
      WARN: Workqueue: nvme-reset-wq nvme_reset_work [nvme]
      WARN: RIP: e030:bind_evtchn_to_cpu+0xc2/0xd0
      WARN: Call Trace:
      WARN:  set_affinity_irq+0x121/0x150
      WARN:  irq_do_set_affinity+0x37/0xe0
      WARN:  irq_setup_affinity+0xf6/0x170
      WARN:  irq_startup+0x64/0xe0
      WARN:  __setup_irq+0x69e/0x740
      WARN:  ? request_threaded_irq+0xad/0x160
      WARN:  request_threaded_irq+0xf5/0x160
      WARN:  ? nvme_timeout+0x2f0/0x2f0 [nvme]
      WARN:  pci_request_irq+0xa9/0xf0
      WARN:  ? pci_alloc_irq_vectors_affinity+0xbb/0x130
      WARN:  queue_request_irq+0x4c/0x70 [nvme]
      WARN:  nvme_reset_work+0x82d/0x1550 [nvme]
      WARN:  ? check_preempt_wakeup+0x14f/0x230
      WARN:  ? check_preempt_curr+0x29/0x80
      WARN:  ? nvme_irq_check+0x30/0x30 [nvme]
      WARN:  process_one_work+0x18e/0x3c0
      WARN:  worker_thread+0x30/0x3a0
      WARN:  ? process_one_work+0x3c0/0x3c0
      WARN:  kthread+0x113/0x130
      WARN:  ? kthread_park+0x90/0x90
      WARN:  ret_from_fork+0x3a/0x50
    
    This patch sets evtchn_to_irq rows via a cmpxchg operation so that they
    will be set only once. The row is now cleared before writing it to
    evtchn_to_irq in order to not create a race once the row is visible for
    other threads.
    
    While at it, do not require the page to be zeroed, because it will be
    overwritten with -1's in clear_evtchn_to_irq_row anyway.
    
    Signed-off-by: Maximilian Heyne <mheyne@amazon.de>
    Fixes: d0b075ffeede ("xen/events: Refactor evtchn_to_irq array to be dynamically allocated")
    Link: https://lore.kernel.org/r/20210812130930.127134-1-mheyne@amazon.de
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 28c2d83c479c33766bec28772855169fb0bbe0cd
Author: Takeshi Misawa <jeliantsurux@gmail.com>
Date:   Thu Aug 5 16:54:14 2021 +0900

    net: Fix memory leak in ieee802154_raw_deliver
    
    [ Upstream commit 1090340f7ee53e824fd4eef66a4855d548110c5b ]
    
    If IEEE-802.15.4-RAW is closed before receive skb, skb is leaked.
    Fix this, by freeing sk_receive_queue in sk->sk_destruct().
    
    syzbot report:
    BUG: memory leak
    unreferenced object 0xffff88810f644600 (size 232):
      comm "softirq", pid 0, jiffies 4294967032 (age 81.270s)
      hex dump (first 32 bytes):
        10 7d 4b 12 81 88 ff ff 10 7d 4b 12 81 88 ff ff  .}K......}K.....
        00 00 00 00 00 00 00 00 40 7c 4b 12 81 88 ff ff  ........@|K.....
      backtrace:
        [<ffffffff83651d4a>] skb_clone+0xaa/0x2b0 net/core/skbuff.c:1496
        [<ffffffff83fe1b80>] ieee802154_raw_deliver net/ieee802154/socket.c:369 [inline]
        [<ffffffff83fe1b80>] ieee802154_rcv+0x100/0x340 net/ieee802154/socket.c:1070
        [<ffffffff8367cc7a>] __netif_receive_skb_one_core+0x6a/0xa0 net/core/dev.c:5384
        [<ffffffff8367cd07>] __netif_receive_skb+0x27/0xa0 net/core/dev.c:5498
        [<ffffffff8367cdd9>] netif_receive_skb_internal net/core/dev.c:5603 [inline]
        [<ffffffff8367cdd9>] netif_receive_skb+0x59/0x260 net/core/dev.c:5662
        [<ffffffff83fe6302>] ieee802154_deliver_skb net/mac802154/rx.c:29 [inline]
        [<ffffffff83fe6302>] ieee802154_subif_frame net/mac802154/rx.c:102 [inline]
        [<ffffffff83fe6302>] __ieee802154_rx_handle_packet net/mac802154/rx.c:212 [inline]
        [<ffffffff83fe6302>] ieee802154_rx+0x612/0x620 net/mac802154/rx.c:284
        [<ffffffff83fe59a6>] ieee802154_tasklet_handler+0x86/0xa0 net/mac802154/main.c:35
        [<ffffffff81232aab>] tasklet_action_common.constprop.0+0x5b/0x100 kernel/softirq.c:557
        [<ffffffff846000bf>] __do_softirq+0xbf/0x2ab kernel/softirq.c:345
        [<ffffffff81232f4c>] do_softirq kernel/softirq.c:248 [inline]
        [<ffffffff81232f4c>] do_softirq+0x5c/0x80 kernel/softirq.c:235
        [<ffffffff81232fc1>] __local_bh_enable_ip+0x51/0x60 kernel/softirq.c:198
        [<ffffffff8367a9a4>] local_bh_enable include/linux/bottom_half.h:32 [inline]
        [<ffffffff8367a9a4>] rcu_read_unlock_bh include/linux/rcupdate.h:745 [inline]
        [<ffffffff8367a9a4>] __dev_queue_xmit+0x7f4/0xf60 net/core/dev.c:4221
        [<ffffffff83fe2db4>] raw_sendmsg+0x1f4/0x2b0 net/ieee802154/socket.c:295
        [<ffffffff8363af16>] sock_sendmsg_nosec net/socket.c:654 [inline]
        [<ffffffff8363af16>] sock_sendmsg+0x56/0x80 net/socket.c:674
        [<ffffffff8363deec>] __sys_sendto+0x15c/0x200 net/socket.c:1977
        [<ffffffff8363dfb6>] __do_sys_sendto net/socket.c:1989 [inline]
        [<ffffffff8363dfb6>] __se_sys_sendto net/socket.c:1985 [inline]
        [<ffffffff8363dfb6>] __x64_sys_sendto+0x26/0x30 net/socket.c:1985
    
    Fixes: 9ec767160357 ("net: add IEEE 802.15.4 socket family implementation")
    Reported-and-tested-by: syzbot+1f68113fa907bf0695a8@syzkaller.appspotmail.com
    Signed-off-by: Takeshi Misawa <jeliantsurux@gmail.com>
    Acked-by: Alexander Aring <aahringo@redhat.com>
    Link: https://lore.kernel.org/r/20210805075414.GA15796@DESKTOP
    Signed-off-by: Stefan Schmidt <stefan@datenfreihafen.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b431f245843b24d2b07d7ea8333710cb17406d3b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jul 29 16:35:32 2021 +0200

    i2c: dev: zero out array used for i2c reads from userspace
    
    commit 86ff25ed6cd8240d18df58930bd8848b19fce308 upstream.
    
    If an i2c driver happens to not provide the full amount of data that a
    user asks for, it is possible that some uninitialized data could be sent
    to userspace.  While all in-kernel drivers look to be safe, just be sure
    by initializing the buffer to zero before it is passed to the i2c driver
    so that any future drivers will not have this issue.
    
    Also properly copy the amount of data recvieved to the userspace buffer,
    as pointed out by Dan Carpenter.
    
    Reported-by: Eric Dumazet <edumazet@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9902683b0ce2de145892eecad644f4c98d0dac88
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 28 13:23:50 2021 +0200

    ASoC: intel: atom: Fix reference to PCM buffer address
    
    commit 2e6b836312a477d647a7920b56810a5a25f6c856 upstream.
    
    PCM buffers might be allocated dynamically when the buffer
    preallocation failed or a larger buffer is requested, and it's not
    guaranteed that substream->dma_buffer points to the actually used
    buffer.  The address should be retrieved from runtime->dma_addr,
    instead of substream->dma_buffer (and shouldn't use virt_to_phys).
    
    Also, remove the line overriding runtime->dma_area superfluously,
    which was already set up at the PCM buffer allocation.
    
    Cc: Cezary Rojewski <cezary.rojewski@intel.com>
    Cc: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20210728112353.6675-3-tiwai@suse.de
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
