commit e350cd02e293be9a6b93398b2d3ff1edf7695ab2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 8 09:04:09 2021 +0200

    Linux 5.4.139
    
    Link: https://lore.kernel.org/r/20210806081112.104686873@linuxfoundation.org
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Tested-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Tested-by: Aakash Hemadri <aakashhemadri123@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 03ff8a4f9db632ef8fc163b6bcdfa0689043472b
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Aug 1 20:00:23 2021 -0700

    spi: mediatek: Fix fifo transfer
    
    commit 0d5c3954b35eddff0da0436c31e8d721eceb7dc2 upstream.
    
    Commit 3a70dd2d0503 ("spi: mediatek: fix fifo rx mode") claims that
    fifo RX mode was never handled, and adds the presumably missing code
    to the FIFO transfer function. However, the claim that receive data
    was not handled is incorrect. It was handled as part of interrupt
    handling after the transfer was complete. The code added with the above
    mentioned commit reads data from the receive FIFO before the transfer
    is started, which is wrong. This results in an actual transfer error
    on a Hayato Chromebook.
    
    Remove the code trying to handle receive data before the transfer is
    started to fix the problem.
    
    Fixes: 3a70dd2d0503 ("spi: mediatek: fix fifo rx mode")
    Cc: Peter Hess <peter.hess@ph-home.de>
    Cc: Frank Wunderlich <frank-w@public-files.de>
    Cc: Tzung-Bi Shih <tzungbi@google.com>
    Cc: Hsin-Yi Wang <hsinyi@google.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Hsin-Yi Wang <hsinyi@google.com>
    Tested-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20210802030023.1748777-1-linux@roeck-us.net
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a0f66ddf05c2050e1b7f53256bd9c25c2bb3022b
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Aug 5 18:53:43 2021 +0300

    bpf, selftests: Adjust few selftest outcomes wrt unreachable code
    
    commit 973377ffe8148180b2651825b92ae91988141b05 upstream
    
    In almost all cases from test_verifier that have been changed in here, we've
    had an unreachable path with a load from a register which has an invalid
    address on purpose. This was basically to make sure that we never walk this
    path and to have the verifier complain if it would otherwise. Change it to
    match on the right error for unprivileged given we now test these paths
    under speculative execution.
    
    There's one case where we match on exact # of insns_processed. Due to the
    extra path, this will of course mismatch on unprivileged. Thus, restrict the
    test->insn_processed check to privileged-only.
    
    In one other case, we result in a 'pointer comparison prohibited' error. This
    is similarly due to verifying an 'invalid' branch where we end up with a value
    pointer on one side of the comparison.
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: John Fastabend <john.fastabend@gmail.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    [OP: ignore changes to tests that do not exist in 5.4]
    Signed-off-by: Ovidiu Panait <ovidiu.panait@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d3796e8f6b3d25c74e416ec3eb0efc011acb547c
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Thu Aug 5 18:53:42 2021 +0300

    bpf, selftests: Add a verifier test for assigning 32bit reg states to 64bit ones
    
    commit cf66c29bd7534813d2e1971fab71e25fe87c7e0a upstream
    
    Added a verifier test for assigning 32bit reg states to
    64bit where 32bit reg holds a constant value of 0.
    
    Without previous kernel verifier.c fix, the test in
    this patch will fail.
    
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/159077335867.6014.2075350327073125374.stgit@john-Precision-5820-Tower
    Signed-off-by: Ovidiu Panait <ovidiu.panait@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8dec99abcd74b817666f48645fe54fc759163e52
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Thu Aug 5 18:53:41 2021 +0300

    bpf: Test_verifier, add alu32 bounds tracking tests
    
    commit 41f70fe0649dddf02046315dc566e06da5a2dc91 upstream
    
    Its possible to have divergent ALU32 and ALU64 bounds when using JMP32
    instructins and ALU64 arithmatic operations. Sometimes the clang will
    even generate this code. Because the case is a bit tricky lets add
    a specific test for it.
    
    Here is  pseudocode asm version to illustrate the idea,
    
     1 r0 = 0xffffffff00000001;
     2 if w0 > 1 goto %l[fail];
     3 r0 += 1
     5 if w0 > 2 goto %l[fail]
     6 exit
    
    The intent here is the verifier will fail the load if the 32bit bounds
    are not tracked correctly through ALU64 op. Similarly we can check the
    64bit bounds are correctly zero extended after ALU32 ops.
    
     1 r0 = 0xffffffff00000001;
     2 w0 += 1
     2 if r0 > 3 goto %l[fail];
     6 exit
    
    The above will fail if we do not correctly zero extend 64bit bounds
    after 32bit op.
    
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/158560430155.10843.514209255758200922.stgit@john-Precision-5820-Tower
    Signed-off-by: Ovidiu Panait <ovidiu.panait@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fd568de5806f8859190e6305a1792ba8cb20de61
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Aug 5 18:53:40 2021 +0300

    bpf: Fix leakage under speculation on mispredicted branches
    
    commit 9183671af6dbf60a1219371d4ed73e23f43b49db upstream
    
    The verifier only enumerates valid control-flow paths and skips paths that
    are unreachable in the non-speculative domain. And so it can miss issues
    under speculative execution on mispredicted branches.
    
    For example, a type confusion has been demonstrated with the following
    crafted program:
    
      // r0 = pointer to a map array entry
      // r6 = pointer to readable stack slot
      // r9 = scalar controlled by attacker
      1: r0 = *(u64 *)(r0) // cache miss
      2: if r0 != 0x0 goto line 4
      3: r6 = r9
      4: if r0 != 0x1 goto line 6
      5: r9 = *(u8 *)(r6)
      6: // leak r9
    
    Since line 3 runs iff r0 == 0 and line 5 runs iff r0 == 1, the verifier
    concludes that the pointer dereference on line 5 is safe. But: if the
    attacker trains both the branches to fall-through, such that the following
    is speculatively executed ...
    
      r6 = r9
      r9 = *(u8 *)(r6)
      // leak r9
    
    ... then the program will dereference an attacker-controlled value and could
    leak its content under speculative execution via side-channel. This requires
    to mistrain the branch predictor, which can be rather tricky, because the
    branches are mutually exclusive. However such training can be done at
    congruent addresses in user space using different branches that are not
    mutually exclusive. That is, by training branches in user space ...
    
      A:  if r0 != 0x0 goto line C
      B:  ...
      C:  if r0 != 0x0 goto line D
      D:  ...
    
    ... such that addresses A and C collide to the same CPU branch prediction
    entries in the PHT (pattern history table) as those of the BPF program's
    lines 2 and 4, respectively. A non-privileged attacker could simply brute
    force such collisions in the PHT until observing the attack succeeding.
    
    Alternative methods to mistrain the branch predictor are also possible that
    avoid brute forcing the collisions in the PHT. A reliable attack has been
    demonstrated, for example, using the following crafted program:
    
      // r0 = pointer to a [control] map array entry
      // r7 = *(u64 *)(r0 + 0), training/attack phase
      // r8 = *(u64 *)(r0 + 8), oob address
      // [...]
      // r0 = pointer to a [data] map array entry
      1: if r7 == 0x3 goto line 3
      2: r8 = r0
      // crafted sequence of conditional jumps to separate the conditional
      // branch in line 193 from the current execution flow
      3: if r0 != 0x0 goto line 5
      4: if r0 == 0x0 goto exit
      5: if r0 != 0x0 goto line 7
      6: if r0 == 0x0 goto exit
      [...]
      187: if r0 != 0x0 goto line 189
      188: if r0 == 0x0 goto exit
      // load any slowly-loaded value (due to cache miss in phase 3) ...
      189: r3 = *(u64 *)(r0 + 0x1200)
      // ... and turn it into known zero for verifier, while preserving slowly-
      // loaded dependency when executing:
      190: r3 &= 1
      191: r3 &= 2
      // speculatively bypassed phase dependency
      192: r7 += r3
      193: if r7 == 0x3 goto exit
      194: r4 = *(u8 *)(r8 + 0)
      // leak r4
    
    As can be seen, in training phase (phase != 0x3), the condition in line 1
    turns into false and therefore r8 with the oob address is overridden with
    the valid map value address, which in line 194 we can read out without
    issues. However, in attack phase, line 2 is skipped, and due to the cache
    miss in line 189 where the map value is (zeroed and later) added to the
    phase register, the condition in line 193 takes the fall-through path due
    to prior branch predictor training, where under speculation, it'll load the
    byte at oob address r8 (unknown scalar type at that point) which could then
    be leaked via side-channel.
    
    One way to mitigate these is to 'branch off' an unreachable path, meaning,
    the current verification path keeps following the is_branch_taken() path
    and we push the other branch to the verification stack. Given this is
    unreachable from the non-speculative domain, this branch's vstate is
    explicitly marked as speculative. This is needed for two reasons: i) if
    this path is solely seen from speculative execution, then we later on still
    want the dead code elimination to kick in in order to sanitize these
    instructions with jmp-1s, and ii) to ensure that paths walked in the
    non-speculative domain are not pruned from earlier walks of paths walked in
    the speculative domain. Additionally, for robustness, we mark the registers
    which have been part of the conditional as unknown in the speculative path
    given there should be no assumptions made on their content.
    
    The fix in here mitigates type confusion attacks described earlier due to
    i) all code paths in the BPF program being explored and ii) existing
    verifier logic already ensuring that given memory access instruction
    references one specific data structure.
    
    An alternative to this fix that has also been looked at in this scope was to
    mark aux->alu_state at the jump instruction with a BPF_JMP_TAKEN state as
    well as direction encoding (always-goto, always-fallthrough, unknown), such
    that mixing of different always-* directions themselves as well as mixing of
    always-* with unknown directions would cause a program rejection by the
    verifier, e.g. programs with constructs like 'if ([...]) { x = 0; } else
    { x = 1; }' with subsequent 'if (x == 1) { [...] }'. For unprivileged, this
    would result in only single direction always-* taken paths, and unknown taken
    paths being allowed, such that the former could be patched from a conditional
    jump to an unconditional jump (ja). Compared to this approach here, it would
    have two downsides: i) valid programs that otherwise are not performing any
    pointer arithmetic, etc, would potentially be rejected/broken, and ii) we are
    required to turn off path pruning for unprivileged, where both can be avoided
    in this work through pushing the invalid branch to the verification stack.
    
    The issue was originally discovered by Adam and Ofek, and later independently
    discovered and reported as a result of Benedict and Piotr's research work.
    
    Fixes: b2157399cc98 ("bpf: prevent out-of-bounds speculation")
    Reported-by: Adam Morrison <mad@cs.tau.ac.il>
    Reported-by: Ofek Kirzner <ofekkir@gmail.com>
    Reported-by: Benedict Schlueter <benedict.schlueter@rub.de>
    Reported-by: Piotr Krysiuk <piotras@gmail.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: John Fastabend <john.fastabend@gmail.com>
    Reviewed-by: Benedict Schlueter <benedict.schlueter@rub.de>
    Reviewed-by: Piotr Krysiuk <piotras@gmail.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    [OP: use allow_ptr_leaks instead of bypass_spec_v1]
    Signed-off-by: Ovidiu Panait <ovidiu.panait@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d2f790327f83b457db357e7c66f942bc00d43462
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Aug 5 18:53:39 2021 +0300

    bpf: Do not mark insn as seen under speculative path verification
    
    commit fe9a5ca7e370e613a9a75a13008a3845ea759d6e upstream
    
    ... in such circumstances, we do not want to mark the instruction as seen given
    the goal is still to jmp-1 rewrite/sanitize dead code, if it is not reachable
    from the non-speculative path verification. We do however want to verify it for
    safety regardless.
    
    With the patch as-is all the insns that have been marked as seen before the
    patch will also be marked as seen after the patch (just with a potentially
    different non-zero count). An upcoming patch will also verify paths that are
    unreachable in the non-speculative domain, hence this extension is needed.
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: John Fastabend <john.fastabend@gmail.com>
    Reviewed-by: Benedict Schlueter <benedict.schlueter@rub.de>
    Reviewed-by: Piotr Krysiuk <piotras@gmail.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    [OP: - env->pass_cnt is not used in 5.4, so adjust sanitize_mark_insn_seen()
           to assign "true" instead
         - drop sanitize_insn_aux_data() comment changes, as the function is not
           present in 5.4]
    Signed-off-by: Ovidiu Panait <ovidiu.panait@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 283d742988f6b304f32110f39e189a00d4e52b92
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Aug 5 18:53:38 2021 +0300

    bpf: Inherit expanded/patched seen count from old aux data
    
    commit d203b0fd863a2261e5d00b97f3d060c4c2a6db71 upstream
    
    Instead of relying on current env->pass_cnt, use the seen count from the
    old aux data in adjust_insn_aux_data(), and expand it to the new range of
    patched instructions. This change is valid given we always expand 1:n
    with n>=1, so what applies to the old/original instruction needs to apply
    for the replacement as well.
    
    Not relying on env->pass_cnt is a prerequisite for a later change where we
    want to avoid marking an instruction seen when verified under speculative
    execution path.
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: John Fastabend <john.fastabend@gmail.com>
    Reviewed-by: Benedict Schlueter <benedict.schlueter@rub.de>
    Reviewed-by: Piotr Krysiuk <piotras@gmail.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    [OP: declare old_data as bool instead of u32 (struct bpf_insn_aux_data.seen
         is bool in 5.4)]
    Signed-off-by: Ovidiu Panait <ovidiu.panait@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a0a9546aaec31237eada027a02fc925ba7454289
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 6 08:28:48 2021 +0200

    Revert "watchdog: iTCO_wdt: Account for rebooting on second timeout"
    
    This reverts commit f58ab0b02ee7b095e0cae4ba706caa86fff5557b which is
    commit cb011044e34c293e139570ce5c01aed66a34345c upstream.
    
    It is reported to cause problems with systems and probably should not
    have been backported in the first place :(
    
    Link: https://lore.kernel.org/r/20210803165108.4154cd52@endymion
    Reported-by: Jean Delvare <jdelvare@suse.de>
    Cc: Jan Kiszka <jan.kiszka@siemens.com>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Wim Van Sebroeck <wim@linux-watchdog.org>
    Cc: Sasha Levin <sashal@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 76f5314d7859dc36121274dfd7d1a7b0545c0032
Author: Cristian Marussi <cristian.marussi@arm.com>
Date:   Tue Jun 8 11:30:56 2021 +0100

    firmware: arm_scmi: Add delayed response status check
    
    commit f1748b1ee1fa0fd1a074504045b530b62f949188 upstream.
    
    A successfully received delayed response could anyway report a failure at
    the protocol layer in the message status field.
    
    Add a check also for this error condition.
    
    Link: https://lore.kernel.org/r/20210608103056.3388-1-cristian.marussi@arm.com
    Fixes: 58ecdf03dbb9 ("firmware: arm_scmi: Add support for asynchronous commands and delayed response")
    Signed-off-by: Cristian Marussi <cristian.marussi@arm.com>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1b38f70bbc7c2b293d0352010228b896c3cdd914
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu Jun 24 10:50:59 2021 +0100

    firmware: arm_scmi: Ensure drivers provide a probe function
    
    commit 5e469dac326555d2038d199a6329458cc82a34e5 upstream.
    
    The bus probe callback calls the driver callback without further
    checking. Better be safe than sorry and refuse registration of a driver
    without a probe function to prevent a NULL pointer exception.
    
    Link: https://lore.kernel.org/r/20210624095059.4010157-2-sudeep.holla@arm.com
    Fixes: 933c504424a2 ("firmware: arm_scmi: add scmi protocol bus to enumerate protocol devices")
    Reported-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Tested-by: Cristian Marussi <cristian.marussi@arm.com>
    Reviewed-by: Cristian Marussi <cristian.marussi@arm.com>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 44f522298c946d7f7b68ce0f5c7986f4c926281a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Aug 5 20:58:57 2021 +0200

    Revert "Bluetooth: Shutdown controller after workqueues are flushed or cancelled"
    
    This reverts commit aa9a2ec7ee08dda41bb565b692f34c620d63b517 which is
    commit 0ea9fd001a14ebc294f112b0361a4e601551d508 upstream.
    
    It has been reported to have problems:
            https://lore.kernel.org/linux-bluetooth/8735ryk0o7.fsf@baylibre.com/
    
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Cc: Marcel Holtmann <marcel@holtmann.org>
    Cc: Sasha Levin <sashal@kernel.org>
    Link: https://lore.kernel.org/r/efee3a58-a4d2-af22-0931-e81b877ab539@roeck-us.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 38f54217b423c0101d03a00feec6fb8ec608b12e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 24 15:25:54 2021 -0700

    ACPI: fix NULL pointer dereference
    
    [ Upstream commit fc68f42aa737dc15e7665a4101d4168aadb8e4c4 ]
    
    Commit 71f642833284 ("ACPI: utils: Fix reference counting in
    for_each_acpi_dev_match()") started doing "acpi_dev_put()" on a pointer
    that was possibly NULL.  That fails miserably, because that helper
    inline function is not set up to handle that case.
    
    Just make acpi_dev_put() silently accept a NULL pointer, rather than
    calling down to put_device() with an invalid offset off that NULL
    pointer.
    
    Link: https://lore.kernel.org/lkml/a607c149-6bf6-0fd0-0e31-100378504da2@kernel.dk/
    Reported-and-tested-by: Jens Axboe <axboe@kernel.dk>
    Tested-by: Daniel Scally <djrscally@gmail.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0ea2f55babb729007f3b27fd3d444b121deecbb2
Author: Keith Busch <kbusch@kernel.org>
Date:   Mon Jul 19 09:44:39 2021 -0700

    nvme: fix nvme_setup_command metadata trace event
    
    [ Upstream commit 234211b8dd161fa25f192c78d5a8d2dd6bf920a0 ]
    
    The metadata address is set after the trace event, so the trace is not
    capturing anything useful. Rather than logging the memory address, it's
    useful to know if the command carries a metadata payload, so change the
    trace event to log that true/false state instead.
    
    Signed-off-by: Keith Busch <kbusch@kernel.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b508b652d4f3d03929e6f0533a44b3dea7493ece
Author: Pravin B Shelar <pshelar@ovn.org>
Date:   Thu Jul 15 16:59:00 2021 -0700

    net: Fix zero-copy head len calculation.
    
    [ Upstream commit a17ad0961706244dce48ec941f7e476a38c0e727 ]
    
    In some cases skb head could be locked and entire header
    data is pulled from skb. When skb_zerocopy() called in such cases,
    following BUG is triggered. This patch fixes it by copying entire
    skb in such cases.
    This could be optimized incase this is performance bottleneck.
    
    ---8<---
    kernel BUG at net/core/skbuff.c:2961!
    invalid opcode: 0000 [#1] SMP PTI
    CPU: 2 PID: 0 Comm: swapper/2 Tainted: G           OE     5.4.0-77-generic #86-Ubuntu
    Hardware name: OpenStack Foundation OpenStack Nova, BIOS 1.13.0-1ubuntu1.1 04/01/2014
    RIP: 0010:skb_zerocopy+0x37a/0x3a0
    RSP: 0018:ffffbcc70013ca38 EFLAGS: 00010246
    Call Trace:
     <IRQ>
     queue_userspace_packet+0x2af/0x5e0 [openvswitch]
     ovs_dp_upcall+0x3d/0x60 [openvswitch]
     ovs_dp_process_packet+0x125/0x150 [openvswitch]
     ovs_vport_receive+0x77/0xd0 [openvswitch]
     netdev_port_receive+0x87/0x130 [openvswitch]
     netdev_frame_hook+0x4b/0x60 [openvswitch]
     __netif_receive_skb_core+0x2b4/0xc90
     __netif_receive_skb_one_core+0x3f/0xa0
     __netif_receive_skb+0x18/0x60
     process_backlog+0xa9/0x160
     net_rx_action+0x142/0x390
     __do_softirq+0xe1/0x2d6
     irq_exit+0xae/0xb0
     do_IRQ+0x5a/0xf0
     common_interrupt+0xf/0xf
    
    Code that triggered BUG:
    int
    skb_zerocopy(struct sk_buff *to, struct sk_buff *from, int len, int hlen)
    {
            int i, j = 0;
            int plen = 0; /* length of skb->head fragment */
            int ret;
            struct page *page;
            unsigned int offset;
    
            BUG_ON(!from->head_frag && !hlen);
    
    Signed-off-by: Pravin B Shelar <pshelar@ovn.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit bf692e7ef657bae632b1b61482116d571b56d7b8
Author: Jia He <justin.he@arm.com>
Date:   Thu Jul 15 16:08:21 2021 +0800

    qed: fix possible unpaired spin_{un}lock_bh in _qed_mcp_cmd_and_union()
    
    [ Upstream commit 6206b7981a36476f4695d661ae139f7db36a802d ]
    
    Liajian reported a bug_on hit on a ThunderX2 arm64 server with FastLinQ
    QL41000 ethernet controller:
     BUG: scheduling while atomic: kworker/0:4/531/0x00000200
      [qed_probe:488()]hw prepare failed
      kernel BUG at mm/vmalloc.c:2355!
      Internal error: Oops - BUG: 0 [#1] SMP
      CPU: 0 PID: 531 Comm: kworker/0:4 Tainted: G W 5.4.0-77-generic #86-Ubuntu
      pstate: 00400009 (nzcv daif +PAN -UAO)
     Call trace:
      vunmap+0x4c/0x50
      iounmap+0x48/0x58
      qed_free_pci+0x60/0x80 [qed]
      qed_probe+0x35c/0x688 [qed]
      __qede_probe+0x88/0x5c8 [qede]
      qede_probe+0x60/0xe0 [qede]
      local_pci_probe+0x48/0xa0
      work_for_cpu_fn+0x24/0x38
      process_one_work+0x1d0/0x468
      worker_thread+0x238/0x4e0
      kthread+0xf0/0x118
      ret_from_fork+0x10/0x18
    
    In this case, qed_hw_prepare() returns error due to hw/fw error, but in
    theory work queue should be in process context instead of interrupt.
    
    The root cause might be the unpaired spin_{un}lock_bh() in
    _qed_mcp_cmd_and_union(), which causes botton half is disabled incorrectly.
    
    Reported-by: Lijian Zhang <Lijian.Zhang@arm.com>
    Signed-off-by: Jia He <justin.he@arm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6bc48348eca77837cb5307b83d73fcbbfb6efe85
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 14 19:00:21 2021 +0200

    r8152: Fix potential PM refcount imbalance
    
    [ Upstream commit 9c23aa51477a37f8b56c3c40192248db0663c196 ]
    
    rtl8152_close() takes the refcount via usb_autopm_get_interface() but
    it doesn't release when RTL8152_UNPLUG test hits.  This may lead to
    the imbalance of PM refcount.  This patch addresses it.
    
    Link: https://bugzilla.suse.com/show_bug.cgi?id=1186194
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a57c75ff070044b9da238143adafd684f0d5d7cc
Author: Kyle Russell <bkylerussell@gmail.com>
Date:   Mon Jun 21 21:09:41 2021 -0400

    ASoC: tlv320aic31xx: fix reversed bclk/wclk master bits
    
    [ Upstream commit 9cf76a72af6ab81030dea6481b1d7bdd814fbdaf ]
    
    These are backwards from Table 7-71 of the TLV320AIC3100 spec [1].
    
    This was broken in 12eb4d66ba2e when BCLK_MASTER and WCLK_MASTER
    were converted from 0x08 and 0x04 to BIT(2) and BIT(3), respectively.
    
    -#define AIC31XX_BCLK_MASTER            0x08
    -#define AIC31XX_WCLK_MASTER            0x04
    +#define AIC31XX_BCLK_MASTER            BIT(2)
    +#define AIC31XX_WCLK_MASTER            BIT(3)
    
    Probably just a typo since the defines were not listed in bit order.
    
    [1] https://www.ti.com/lit/gpn/tlv320aic3100
    
    Signed-off-by: Kyle Russell <bkylerussell@gmail.com>
    Link: https://lore.kernel.org/r/20210622010941.241386-1-bkylerussell@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e2cccb839a184d66087fae745c5d9d578088f0ec
Author: Alain Volmat <alain.volmat@foss.st.com>
Date:   Wed Jun 30 10:45:19 2021 +0200

    spi: stm32h7: fix full duplex irq handler handling
    
    [ Upstream commit e4a5c19888a5f8a9390860ca493e643be58c8791 ]
    
    In case of Full-Duplex mode, DXP flag is set when RXP and TXP flags are
    set. But to avoid 2 different handlings, just add TXP and RXP flag in
    the mask instead of DXP, and then keep the initial handling of TXP and
    RXP events.
    Also rephrase comment about EOTIE which is one of the interrupt enable
    bits. It is not triggered by any event.
    
    Signed-off-by: Amelie Delaunay <amelie.delaunay@foss.st.com>
    Signed-off-by: Alain Volmat <alain.volmat@foss.st.com>
    Reviewed-by: Amelie Delaunay <amelie.delaunay@foss.st.com>
    Link: https://lore.kernel.org/r/1625042723-661-3-git-send-email-alain.volmat@foss.st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b72f2d9e91e1fa10f6b537b40836bbff61d5d819
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Jun 27 16:04:18 2021 +0800

    regulator: rt5033: Fix n_voltages settings for BUCK and LDO
    
    [ Upstream commit 6549c46af8551b346bcc0b9043f93848319acd5c ]
    
    For linear regulators, the n_voltages should be (max - min) / step + 1.
    
    Buck voltage from 1v to 3V, per step 100mV, and vout mask is 0x1f.
    If value is from 20 to 31, the voltage will all be fixed to 3V.
    And LDO also, just vout range is different from 1.2v to 3v, step is the
    same. If value is from 18 to 31, the voltage will also be fixed to 3v.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Reviewed-by: ChiYuan Huang <cy_huang@richtek.com>
    Link: https://lore.kernel.org/r/20210627080418.1718127-1-axel.lin@ingics.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 86f2a3e9aae9f88ef2189fdaa2ccf9e7321dcc8f
Author: Filipe Manana <fdmanana@suse.com>
Date:   Tue Jul 27 11:24:43 2021 +0100

    btrfs: fix lost inode on log replay after mix of fsync, rename and inode eviction
    
    [ Upstream commit ecc64fab7d49c678e70bd4c35fe64d2ab3e3d212 ]
    
    When checking if we need to log the new name of a renamed inode, we are
    checking if the inode and its parent inode have been logged before, and if
    not we don't log the new name. The check however is buggy, as it directly
    compares the logged_trans field of the inodes versus the ID of the current
    transaction. The problem is that logged_trans is a transient field, only
    stored in memory and never persisted in the inode item, so if an inode
    was logged before, evicted and reloaded, its logged_trans field is set to
    a value of 0, meaning the check will return false and the new name of the
    renamed inode is not logged. If the old parent directory was previously
    fsynced and we deleted the logged directory entries corresponding to the
    old name, we end up with a log that when replayed will delete the renamed
    inode.
    
    The following example triggers the problem:
    
      $ mkfs.btrfs -f /dev/sdc
      $ mount /dev/sdc /mnt
    
      $ mkdir /mnt/A
      $ mkdir /mnt/B
      $ echo -n "hello world" > /mnt/A/foo
    
      $ sync
    
      # Add some new file to A and fsync directory A.
      $ touch /mnt/A/bar
      $ xfs_io -c "fsync" /mnt/A
    
      # Now trigger inode eviction. We are only interested in triggering
      # eviction for the inode of directory A.
      $ echo 2 > /proc/sys/vm/drop_caches
    
      # Move foo from directory A to directory B.
      # This deletes the directory entries for foo in A from the log, and
      # does not add the new name for foo in directory B to the log, because
      # logged_trans of A is 0, which is less than the current transaction ID.
      $ mv /mnt/A/foo /mnt/B/foo
    
      # Now make an fsync to anything except A, B or any file inside them,
      # like for example create a file at the root directory and fsync this
      # new file. This syncs the log that contains all the changes done by
      # previous rename operation.
      $ touch /mnt/baz
      $ xfs_io -c "fsync" /mnt/baz
    
      <power fail>
    
      # Mount the filesystem and replay the log.
      $ mount /dev/sdc /mnt
    
      # Check the filesystem content.
      $ ls -1R /mnt
      /mnt/:
      A
      B
      baz
    
      /mnt/A:
      bar
    
      /mnt/B:
      $
    
      # File foo is gone, it's neither in A/ nor in B/.
    
    Fix this by using the inode_logged() helper at btrfs_log_new_name(), which
    safely checks if an inode was logged before in the current transaction.
    
    A test case for fstests will follow soon.
    
    CC: stable@vger.kernel.org # 4.14+
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b7f0fa2192c5263a57033de763d2d00fe7c05116
Author: Filipe Manana <fdmanana@suse.com>
Date:   Wed Nov 25 12:19:23 2020 +0000

    btrfs: fix race causing unnecessary inode logging during link and rename
    
    [ Upstream commit de53d892e5c51dfa0a158e812575a75a6c991f39 ]
    
    When we are doing a rename or a link operation for an inode that was logged
    in the previous transaction and that transaction is still committing, we
    have a time window where we incorrectly consider that the inode was logged
    previously in the current transaction and therefore decide to log it to
    update it in the log. The following steps give an example on how this
    happens during a link operation:
    
    1) Inode X is logged in transaction 1000, so its logged_trans field is set
       to 1000;
    
    2) Task A starts to commit transaction 1000;
    
    3) The state of transaction 1000 is changed to TRANS_STATE_UNBLOCKED;
    
    4) Task B starts a link operation for inode X, and as a consequence it
       starts transaction 1001;
    
    5) Task A is still committing transaction 1000, therefore the value stored
       at fs_info->last_trans_committed is still 999;
    
    6) Task B calls btrfs_log_new_name(), it reads a value of 999 from
       fs_info->last_trans_committed and because the logged_trans field of
       inode X has a value of 1000, the function does not return immediately,
       instead it proceeds to logging the inode, which should not happen
       because the inode was logged in the previous transaction (1000) and
       not in the current one (1001).
    
    This is not a functional problem, just wasted time and space logging an
    inode that does not need to be logged, contributing to higher latency
    for link and rename operations.
    
    So fix this by comparing the inodes' logged_trans field with the
    generation of the current transaction instead of comparing with the value
    stored in fs_info->last_trans_committed.
    
    This case is often hit when running dbench for a long enough duration, as
    it does lots of rename operations.
    
    This patch belongs to a patch set that is comprised of the following
    patches:
    
      btrfs: fix race causing unnecessary inode logging during link and rename
      btrfs: fix race that results in logging old extents during a fast fsync
      btrfs: fix race that causes unnecessary logging of ancestor inodes
      btrfs: fix race that makes inode logging fallback to transaction commit
      btrfs: fix race leading to unnecessary transaction commit when logging inode
      btrfs: do not block inode logging for so long during transaction commit
    
    Performance results are mentioned in the change log of the last patch.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cb006da62a9e526fd754dd16564a8e7967b33417
Author: Filipe Manana <fdmanana@suse.com>
Date:   Tue Aug 11 12:43:48 2020 +0100

    btrfs: do not commit logs and transactions during link and rename operations
    
    [ Upstream commit 75b463d2b47aef96fe1dc3e0237629963034764b ]
    
    Since commit d4682ba03ef618 ("Btrfs: sync log after logging new name") we
    started to commit logs, and fallback to transaction commits when we failed
    to log the new names or commit the logs, after link and rename operations
    when the target inodes (or their parents) were previously logged in the
    current transaction. This was to avoid losing directories despite an
    explicit fsync on them when they are ancestors of some inode that got a
    new named logged, due to a link or rename operation. However that adds the
    cost of starting IO and waiting for it to complete, which can cause higher
    latencies for applications.
    
    Instead of doing that, just make sure that when we log a new name for an
    inode we don't mark any of its ancestors as logged, so that if any one
    does an fsync against any of them, without doing any other change on them,
    the fsync commits the log. This way we only pay the cost of a log commit
    (or a transaction commit if something goes wrong or a new block group was
    created) if the application explicitly asks to fsync any of the parent
    directories.
    
    Using dbench, which mixes several filesystems operations including renames,
    revealed some significant latency gains. The following script that uses
    dbench was used to test this:
    
      #!/bin/bash
    
      DEV=/dev/nvme0n1
      MNT=/mnt/btrfs
      MOUNT_OPTIONS="-o ssd -o space_cache=v2"
      MKFS_OPTIONS="-m single -d single"
      THREADS=16
    
      echo "performance" | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
      mkfs.btrfs -f $MKFS_OPTIONS $DEV
      mount $MOUNT_OPTIONS $DEV $MNT
    
      dbench -t 300 -D $MNT $THREADS
    
      umount $MNT
    
    The test was run on bare metal, no virtualization, on a box with 12 cores
    (Intel i7-8700), 64Gb of RAM and using a NVMe device, with a kernel
    configuration that is the default of typical distributions (debian in this
    case), without debug options enabled (kasan, kmemleak, slub debug, debug
    of page allocations, lock debugging, etc).
    
    Results before this patch:
    
     Operation      Count    AvgLat    MaxLat
     ----------------------------------------
     NTCreateX    10750455     0.011   155.088
     Close         7896674     0.001     0.243
     Rename         455222     2.158  1101.947
     Unlink        2171189     0.067   121.638
     Deltree           256     2.425     7.816
     Mkdir             128     0.002     0.003
     Qpathinfo     9744323     0.006    21.370
     Qfileinfo     1707092     0.001     0.146
     Qfsinfo       1786756     0.001    11.228
     Sfileinfo      875612     0.003    21.263
     Find          3767281     0.025     9.617
     WriteX        5356924     0.011   211.390
     ReadX        16852694     0.003     9.442
     LockX           35008     0.002     0.119
     UnlockX         35008     0.001     0.138
     Flush          753458     4.252  1102.249
    
    Throughput 1128.35 MB/sec  16 clients  16 procs  max_latency=1102.255 ms
    
    Results after this patch:
    
    16 clients, after
    
     Operation      Count    AvgLat    MaxLat
     ----------------------------------------
     NTCreateX    11471098     0.012   448.281
     Close         8426396     0.001     0.925
     Rename         485746     0.123   267.183
     Unlink        2316477     0.080    63.433
     Deltree           288     2.830    11.144
     Mkdir             144     0.003     0.010
     Qpathinfo    10397420     0.006    10.288
     Qfileinfo     1822039     0.001     0.169
     Qfsinfo       1906497     0.002    14.039
     Sfileinfo      934433     0.004     2.438
     Find          4019879     0.026    10.200
     WriteX        5718932     0.011   200.985
     ReadX        17981671     0.003    10.036
     LockX           37352     0.002     0.076
     UnlockX         37352     0.001     0.109
     Flush          804018     5.015   778.033
    
    Throughput 1201.98 MB/sec  16 clients  16 procs  max_latency=778.036 ms
    (+6.5% throughput, -29.4% max latency, -75.8% rename latency)
    
    Test case generic/498 from fstests tests the scenario that the previously
    mentioned commit fixed.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 174c27d0f9ef82baf257e47deb9927aa59cf889b
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Aug 4 19:48:34 2020 -0700

    btrfs: delete duplicated words + other fixes in comments
    
    [ Upstream commit 260db43cd2f556677f6ae818ba09f997eed81004 ]
    
    Delete repeated words in fs/btrfs/.
    {to, the, a, and old}
    and change "into 2 part" to "into 2 parts".
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
