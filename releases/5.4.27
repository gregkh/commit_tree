commit 585e0cc080690239f0689973c119459ff69db473
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Mar 21 08:12:00 2020 +0100

    Linux 5.4.27

commit 20ba40d262b0d88e6cf3e2eaf756ad70809018c6
Author: Matteo Croce <mcroce@redhat.com>
Date:   Fri Feb 21 12:28:38 2020 +0100

    ipv4: ensure rcu_read_lock() in cipso_v4_error()
    
    commit 3e72dfdf8227b052393f71d820ec7599909dddc2 upstream.
    
    Similarly to commit c543cb4a5f07 ("ipv4: ensure rcu_read_lock() in
    ipv4_link_failure()"), __ip_options_compile() must be called under rcu
    protection.
    
    Fixes: 3da1ed7ac398 ("net: avoid use IPCB in cipso_v4_error")
    Suggested-by: Guillaume Nault <gnault@redhat.com>
    Signed-off-by: Matteo Croce <mcroce@redhat.com>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 81e0dac3780a71a765b5a128dd3596b5da2e1384
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Feb 18 09:15:34 2020 +0100

    ARM: 8961/2: Fix Kbuild issue caused by per-task stack protector GCC plugin
    
    commit 89604523a76eb3e13014b2bdab7f8870becee284 upstream.
    
    When using plugins, GCC requires that the -fplugin= options precedes
    any of its plugin arguments appearing on the command line as well.
    This is usually not a concern, but as it turns out, this requirement
    is causing some issues with ARM's per-task stack protector plugin
    and Kbuild's implementation of $(cc-option).
    
    When the per-task stack protector plugin is enabled, and we tweak
    the implementation of cc-option not to pipe the stderr output of
    GCC to /dev/null, the following output is generated when GCC is
    executed in the context of cc-option:
    
      cc1: error: plugin arm_ssp_per_task_plugin should be specified before \
             -fplugin-arg-arm_ssp_per_task_plugin-tso=1 in the command line
      cc1: error: plugin arm_ssp_per_task_plugin should be specified before \
             -fplugin-arg-arm_ssp_per_task_plugin-offset=24 in the command line
    
    These errors will cause any option passed to cc-option to be treated
    as unsupported, which is obviously incorrect.
    
    The cause of this issue is the fact that the -fplugin= argument is
    added to GCC_PLUGINS_CFLAGS, whereas the arguments above are added
    to KBUILD_CFLAGS, and the contents of the former get filtered out of
    the latter before being passed to the GCC running the cc-option test,
    and so the -fplugin= option does not appear at all on the GCC command
    line.
    
    Adding the arguments to GCC_PLUGINS_CFLAGS instead of KBUILD_CFLAGS
    would be the correct approach here, if it weren't for the fact that we
    are using $(eval) to defer the moment that they are added until after
    asm-offsets.h is generated, which is after the point where the contents
    of GCC_PLUGINS_CFLAGS are added to KBUILD_CFLAGS. So instead, we have
    to add our plugin arguments to both.
    
    For similar reasons, we cannot append DISABLE_ARM_SSP_PER_TASK_PLUGIN
    to KBUILD_CFLAGS, as it will be passed to GCC when executing in the
    context of cc-option, whereas the other plugin arguments will have
    been filtered out, resulting in a similar error and false negative
    result as above. So add it to ccflags-y instead.
    
    Fixes: 189af4657186da08 ("ARM: smp: add support for per-task stack canaries")
    Reported-by: Merlijn Wajer <merlijn@wizzup.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1dc67950e2d1a9be2a7e6470becb7c0ba42a92d3
Author: Tony Fischetti <tony.fischetti@gmail.com>
Date:   Thu Mar 12 12:16:06 2020 -0400

    HID: add ALWAYS_POLL quirk to lenovo pixart mouse
    
    commit 819d578d51d0ce73f06e35d69395ef55cd683a74 upstream.
    
    A lenovo pixart mouse (17ef:608d) is afflicted common the the malfunction
    where it disconnects and reconnects every minute--each time incrementing
    the device number. This patch adds the device id of the device and
    specifies that it needs the HID_QUIRK_ALWAYS_POLL quirk in order to
    work properly.
    
    Signed-off-by: Tony Fischetti <tony.fischetti@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5d961582ea884243c5a987520ae4866d9f826ca2
Author: Chen-Tsung Hsieh <chentsung@chromium.org>
Date:   Mon Mar 16 15:24:19 2020 +0800

    HID: google: add moonball USB id
    
    commit 58322a1590fc189a8e1e349d309637d4a4942840 upstream.
    
    Add 1 additional hammer-like device.
    
    Signed-off-by: Chen-Tsung Hsieh <chentsung@chromium.org>
    Reviewed-by: Nicolas Boichat <drinkcat@chromium.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ae119b7e12472517bc35c1c003d5abf26653674a
Author: Jann Horn <jannh@google.com>
Date:   Tue Mar 17 01:28:45 2020 +0100

    mm: slub: add missing TID bump in kmem_cache_alloc_bulk()
    
    commit fd4d9c7d0c71866ec0c2825189ebd2ce35bd95b8 upstream.
    
    When kmem_cache_alloc_bulk() attempts to allocate N objects from a percpu
    freelist of length M, and N > M > 0, it will first remove the M elements
    from the percpu freelist, then call ___slab_alloc() to allocate the next
    element and repopulate the percpu freelist. ___slab_alloc() can re-enable
    IRQs via allocate_slab(), so the TID must be bumped before ___slab_alloc()
    to properly commit the freelist head change.
    
    Fix it by unconditionally bumping c->tid when entering the slowpath.
    
    Cc: stable@vger.kernel.org
    Fixes: ebe909e0fdb3 ("slub: improve bulk alloc strategy")
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 47b6d269dbbdbee277f8089ebceae9c9666bd918
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Feb 10 02:04:17 2020 +0100

    ARM: 8958/1: rename missed uaccess .fixup section
    
    commit f87b1c49bc675da30d8e1e8f4b60b800312c7b90 upstream.
    
    When the uaccess .fixup section was renamed to .text.fixup, one case was
    missed. Under ld.bfd, the orphaned section was moved close to .text
    (since they share the "ax" bits), so things would work normally on
    uaccess faults. Under ld.lld, the orphaned section was placed outside
    the .text section, making it unreachable.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/282
    Link: https://bugs.chromium.org/p/chromium/issues/detail?id=1020633#c44
    Link: https://lore.kernel.org/r/nycvar.YSQ.7.76.1912032147340.17114@knanqh.ubzr
    Link: https://lore.kernel.org/lkml/202002071754.F5F073F1D@keescook/
    
    Fixes: c4a84ae39b4a5 ("ARM: 8322/1: keep .text and .fixup regions closer together")
    Cc: stable@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1a9e78628d44803a8b146f4c641551d29afaa9b6
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jan 28 20:22:13 2020 +0100

    ARM: 8957/1: VDSO: Match ARMv8 timer in cntvct_functional()
    
    commit 45939ce292b4b11159719faaf60aba7d58d5fe33 upstream.
    
    It is possible for a system with an ARMv8 timer to run a 32-bit kernel.
    When this happens we will unconditionally have the vDSO code remove the
    __vdso_gettimeofday and __vdso_clock_gettime symbols because
    cntvct_functional() returns false since it does not match that
    compatibility string.
    
    Fixes: ecf99a439105 ("ARM: 8331/1: VDSO initialization, mapping, and synchronization")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 881876bee65765a26af68492fd3cd5fd6a599034
Author: Carl Huang <cjhuang@codeaurora.org>
Date:   Fri Jan 3 12:50:16 2020 +0800

    net: qrtr: fix len of skb_put_padto in qrtr_node_enqueue
    
    commit ce57785bf91b1ceaef4f4bffed8a47dc0919c8da upstream.
    
    The len used for skb_put_padto is wrong, it need to add len of hdr.
    
    In qrtr_node_enqueue, local variable size_t len is assign with
    skb->len, then skb_push(skb, sizeof(*hdr)) will add skb->len with
    sizeof(*hdr), so local variable size_t len is not same with skb->len
    after skb_push(skb, sizeof(*hdr)).
    
    Then the purpose of skb_put_padto(skb, ALIGN(len, 4)) is to add add
    pad to the end of the skb's data if skb->len is not aligned to 4, but
    unfortunately it use len instead of skb->len, at this line, skb->len
    is 32 bytes(sizeof(*hdr)) more than len, for example, len is 3 bytes,
    then skb->len is 35 bytes(3 + 32), and ALIGN(len, 4) is 4 bytes, so
    __skb_put_padto will do nothing after check size(35) < len(4), the
    correct value should be 36(sizeof(*hdr) + ALIGN(len, 4) = 32 + 4),
    then __skb_put_padto will pass check size(35) < len(36) and add 1 byte
    to the end of skb's data, then logic is correct.
    
    function of skb_push:
    void *skb_push(struct sk_buff *skb, unsigned int len)
    {
            skb->data -= len;
            skb->len  += len;
            if (unlikely(skb->data < skb->head))
                    skb_under_panic(skb, len, __builtin_return_address(0));
            return skb->data;
    }
    
    function of skb_put_padto
    static inline int skb_put_padto(struct sk_buff *skb, unsigned int len)
    {
            return __skb_put_padto(skb, len, true);
    }
    
    function of __skb_put_padto
    static inline int __skb_put_padto(struct sk_buff *skb, unsigned int len,
                                      bool free_on_error)
    {
            unsigned int size = skb->len;
    
            if (unlikely(size < len)) {
                    len -= size;
                    if (__skb_pad(skb, len, free_on_error))
                            return -ENOMEM;
                    __skb_put(skb, len);
            }
            return 0;
    }
    
    Signed-off-by: Carl Huang <cjhuang@codeaurora.org>
    Signed-off-by: Wen Gong <wgong@codeaurora.org>
    Cc: Doug Anderson <dianders@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 235fb892d84649f7971f12437a25d6f1d427c538
Author: Ming Lei <ming.lei@redhat.com>
Date:   Thu Mar 12 17:15:48 2020 +0800

    blk-mq: insert flush request to the front of dispatch queue
    
    [ Upstream commit cc3200eac4c5eb11c3f34848a014d1f286316310 ]
    
    commit 01e99aeca397 ("blk-mq: insert passthrough request into
    hctx->dispatch directly") may change to add flush request to the tail
    of dispatch by applying the 'add_head' parameter of
    blk_mq_sched_insert_request.
    
    Turns out this way causes performance regression on NCQ controller because
    flush is non-NCQ command, which can't be queued when there is any in-flight
    NCQ command. When adding flush rq to the front of hctx->dispatch, it is
    easier to introduce extra time to flush rq's latency compared with adding
    to the tail of dispatch queue because of S_SCHED_RESTART, then chance of
    flush merge is increased, and less flush requests may be issued to
    controller.
    
    So always insert flush request to the front of dispatch queue just like
    before applying commit 01e99aeca397 ("blk-mq: insert passthrough request
    into hctx->dispatch directly").
    
    Cc: Damien Le Moal <Damien.LeMoal@wdc.com>
    Cc: Shinichiro Kawasaki <shinichiro.kawasaki@wdc.com>
    Reported-by: Shinichiro Kawasaki <shinichiro.kawasaki@wdc.com>
    Fixes: 01e99aeca397 ("blk-mq: insert passthrough request into hctx->dispatch directly")
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit dbce8292217a85b30a1152036112ed0e809dbd1f
Author: Qian Cai <cai@lca.pw>
Date:   Fri Feb 21 23:31:11 2020 -0500

    jbd2: fix data races at struct journal_head
    
    [ Upstream commit 6c5d911249290f41f7b50b43344a7520605b1acb ]
    
    journal_head::b_transaction and journal_head::b_next_transaction could
    be accessed concurrently as noticed by KCSAN,
    
     LTP: starting fsync04
     /dev/zero: Can't open blockdev
     EXT4-fs (loop0): mounting ext3 file system using the ext4 subsystem
     EXT4-fs (loop0): mounted filesystem with ordered data mode. Opts: (null)
     ==================================================================
     BUG: KCSAN: data-race in __jbd2_journal_refile_buffer [jbd2] / jbd2_write_access_granted [jbd2]
    
     write to 0xffff99f9b1bd0e30 of 8 bytes by task 25721 on cpu 70:
      __jbd2_journal_refile_buffer+0xdd/0x210 [jbd2]
      __jbd2_journal_refile_buffer at fs/jbd2/transaction.c:2569
      jbd2_journal_commit_transaction+0x2d15/0x3f20 [jbd2]
      (inlined by) jbd2_journal_commit_transaction at fs/jbd2/commit.c:1034
      kjournald2+0x13b/0x450 [jbd2]
      kthread+0x1cd/0x1f0
      ret_from_fork+0x27/0x50
    
     read to 0xffff99f9b1bd0e30 of 8 bytes by task 25724 on cpu 68:
      jbd2_write_access_granted+0x1b2/0x250 [jbd2]
      jbd2_write_access_granted at fs/jbd2/transaction.c:1155
      jbd2_journal_get_write_access+0x2c/0x60 [jbd2]
      __ext4_journal_get_write_access+0x50/0x90 [ext4]
      ext4_mb_mark_diskspace_used+0x158/0x620 [ext4]
      ext4_mb_new_blocks+0x54f/0xca0 [ext4]
      ext4_ind_map_blocks+0xc79/0x1b40 [ext4]
      ext4_map_blocks+0x3b4/0x950 [ext4]
      _ext4_get_block+0xfc/0x270 [ext4]
      ext4_get_block+0x3b/0x50 [ext4]
      __block_write_begin_int+0x22e/0xae0
      __block_write_begin+0x39/0x50
      ext4_write_begin+0x388/0xb50 [ext4]
      generic_perform_write+0x15d/0x290
      ext4_buffered_write_iter+0x11f/0x210 [ext4]
      ext4_file_write_iter+0xce/0x9e0 [ext4]
      new_sync_write+0x29c/0x3b0
      __vfs_write+0x92/0xa0
      vfs_write+0x103/0x260
      ksys_write+0x9d/0x130
      __x64_sys_write+0x4c/0x60
      do_syscall_64+0x91/0xb05
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
     5 locks held by fsync04/25724:
      #0: ffff99f9911093f8 (sb_writers#13){.+.+}, at: vfs_write+0x21c/0x260
      #1: ffff99f9db4c0348 (&sb->s_type->i_mutex_key#15){+.+.}, at: ext4_buffered_write_iter+0x65/0x210 [ext4]
      #2: ffff99f5e7dfcf58 (jbd2_handle){++++}, at: start_this_handle+0x1c1/0x9d0 [jbd2]
      #3: ffff99f9db4c0168 (&ei->i_data_sem){++++}, at: ext4_map_blocks+0x176/0x950 [ext4]
      #4: ffffffff99086b40 (rcu_read_lock){....}, at: jbd2_write_access_granted+0x4e/0x250 [jbd2]
     irq event stamp: 1407125
     hardirqs last  enabled at (1407125): [<ffffffff980da9b7>] __find_get_block+0x107/0x790
     hardirqs last disabled at (1407124): [<ffffffff980da8f9>] __find_get_block+0x49/0x790
     softirqs last  enabled at (1405528): [<ffffffff98a0034c>] __do_softirq+0x34c/0x57c
     softirqs last disabled at (1405521): [<ffffffff97cc67a2>] irq_exit+0xa2/0xc0
    
     Reported by Kernel Concurrency Sanitizer on:
     CPU: 68 PID: 25724 Comm: fsync04 Tainted: G L 5.6.0-rc2-next-20200221+ #7
     Hardware name: HPE ProLiant DL385 Gen10/ProLiant DL385 Gen10, BIOS A40 07/10/2019
    
    The plain reads are outside of jh->b_state_lock critical section which result
    in data races. Fix them by adding pairs of READ|WRITE_ONCE().
    
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Qian Cai <cai@lca.pw>
    Link: https://lore.kernel.org/r/20200222043111.2227-1-cai@lca.pw
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 99746e92fa4c6f45e7f3eec4f4290674073059fc
Author: Alex Maftei (amaftei) <amaftei@solarflare.com>
Date:   Wed Feb 26 17:33:19 2020 +0000

    sfc: fix timestamp reconstruction at 16-bit rollover points
    
    [ Upstream commit 23797b98909f34b75fd130369bde86f760db69d0 ]
    
    We can't just use the top bits of the last sync event as they could be
    off-by-one every 65,536 seconds, giving an error in reconstruction of
    65,536 seconds.
    
    This patch uses the difference in the bottom 16 bits (mod 2^16) to
    calculate an offset that needs to be applied to the last sync event to
    get to the current time.
    
    Signed-off-by: Alexandru-Mihai Maftei <amaftei@solarflare.com>
    Acked-by: Martin Habets <mhabets@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e2b8b042c98b3db81ac03c62656ee73866e62ea9
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:26:15 2020 +0000

    net: rmnet: fix packet forwarding in rmnet bridge mode
    
    [ Upstream commit ad3cc31b599ea80f06b29ebdc18b3a39878a48d6 ]
    
    Packet forwarding is not working in rmnet bridge mode.
    Because when a packet is forwarded, skb_push() for an ethernet header
    is needed. But it doesn't call skb_push().
    So, the ethernet header will be lost.
    
    Test commands:
        modprobe rmnet
        ip netns add nst
        ip netns add nst2
        ip link add veth0 type veth peer name veth1
        ip link add veth2 type veth peer name veth3
        ip link set veth1 netns nst
        ip link set veth3 netns nst2
    
        ip link add rmnet0 link veth0 type rmnet mux_id 1
        ip link set veth2 master rmnet0
        ip link set veth0 up
        ip link set veth2 up
        ip link set rmnet0 up
        ip a a 192.168.100.1/24 dev rmnet0
    
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip a a 192.168.100.2/24 dev veth1
        ip netns exec nst2 ip link set veth3 up
        ip netns exec nst2 ip a a 192.168.100.3/24 dev veth3
        ip netns exec nst2 ping 192.168.100.2
    
    Fixes: 60d58f971c10 ("net: qualcomm: rmnet: Implement bridge mode")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 34c550ebb219db27c15a290683630359f9e1cbc6
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:26:02 2020 +0000

    net: rmnet: fix bridge mode bugs
    
    [ Upstream commit d939b6d30bea1a2322bc536b12be0a7c4c2bccd7 ]
    
    In order to attach a bridge interface to the rmnet interface,
    "master" operation is used.
    (e.g. ip link set dummy1 master rmnet0)
    But, in the rmnet_add_bridge(), which is a callback of ->ndo_add_slave()
    doesn't register lower interface.
    So, ->ndo_del_slave() doesn't work.
    There are other problems too.
    1. It couldn't detect circular upper/lower interface relationship.
    2. It couldn't prevent stack overflow because of too deep depth
    of upper/lower interface
    3. It doesn't check the number of lower interfaces.
    4. Panics because of several reasons.
    
    The root problem of these issues is actually the same.
    So, in this patch, these all problems will be fixed.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link add dummy1 master rmnet0 type dummy
        ip link add dummy2 master rmnet0 type dummy
        ip link del rmnet0
        ip link del dummy2
        ip link del dummy1
    
    Splat looks like:
    [   41.867595][ T1164] general protection fault, probably for non-canonical address 0xdffffc0000000101I
    [   41.869993][ T1164] KASAN: null-ptr-deref in range [0x0000000000000808-0x000000000000080f]
    [   41.872950][ T1164] CPU: 0 PID: 1164 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   41.873915][ T1164] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   41.875161][ T1164] RIP: 0010:rmnet_unregister_bridge.isra.6+0x71/0xf0 [rmnet]
    [   41.876178][ T1164] Code: 48 89 ef 48 89 c6 5b 5d e9 fc fe ff ff e8 f7 f3 ff ff 48 8d b8 08 08 00 00 48 ba 00 7
    [   41.878925][ T1164] RSP: 0018:ffff8880c4d0f188 EFLAGS: 00010202
    [   41.879774][ T1164] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000101
    [   41.887689][ T1164] RDX: dffffc0000000000 RSI: ffffffffb8cf64f0 RDI: 0000000000000808
    [   41.888727][ T1164] RBP: ffff8880c40e4000 R08: ffffed101b3c0e3c R09: 0000000000000001
    [   41.889749][ T1164] R10: 0000000000000001 R11: ffffed101b3c0e3b R12: 1ffff110189a1e3c
    [   41.890783][ T1164] R13: ffff8880c4d0f200 R14: ffffffffb8d56160 R15: ffff8880ccc2c000
    [   41.891794][ T1164] FS:  00007f4300edc0c0(0000) GS:ffff8880d9c00000(0000) knlGS:0000000000000000
    [   41.892953][ T1164] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   41.893800][ T1164] CR2: 00007f43003bc8c0 CR3: 00000000ca53e001 CR4: 00000000000606f0
    [   41.894824][ T1164] Call Trace:
    [   41.895274][ T1164]  ? rcu_is_watching+0x2c/0x80
    [   41.895895][ T1164]  rmnet_config_notify_cb+0x1f7/0x590 [rmnet]
    [   41.896687][ T1164]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   41.897611][ T1164]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   41.898508][ T1164]  ? __module_text_address+0x13/0x140
    [   41.899162][ T1164]  notifier_call_chain+0x90/0x160
    [   41.899814][ T1164]  rollback_registered_many+0x660/0xcf0
    [   41.900544][ T1164]  ? netif_set_real_num_tx_queues+0x780/0x780
    [   41.901316][ T1164]  ? __lock_acquire+0xdfe/0x3de0
    [   41.901958][ T1164]  ? memset+0x1f/0x40
    [   41.902468][ T1164]  ? __nla_validate_parse+0x98/0x1ab0
    [   41.903166][ T1164]  unregister_netdevice_many.part.133+0x13/0x1b0
    [   41.903988][ T1164]  rtnl_delete_link+0xbc/0x100
    [ ... ]
    
    Fixes: 60d58f971c10 ("net: qualcomm: rmnet: Implement bridge mode")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8eccc6d06ea18805441386fbd2e8ab06be708b5b
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:25:43 2020 +0000

    net: rmnet: use upper/lower device infrastructure
    
    [ Upstream commit 037f9cdf72fb8a7ff9ec2b5dd05336ec1492bdf1 ]
    
    netdev_upper_dev_link() is useful to manage lower/upper interfaces.
    And this function internally validates looping, maximum depth.
    All or most virtual interfaces that could have a real interface
    (e.g. macsec, macvlan, ipvlan etc.) use lower/upper infrastructure.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add rmnet1 link dummy0 type rmnet mux_id 1
        for i in {2..100}
        do
            let A=$i-1
            ip link add rmnet$i link rmnet$A type rmnet mux_id $i
        done
        ip link del dummy0
    
    The purpose of the test commands is to make stack overflow.
    
    Splat looks like:
    [   52.411438][ T1395] BUG: KASAN: slab-out-of-bounds in find_busiest_group+0x27e/0x2c00
    [   52.413218][ T1395] Write of size 64 at addr ffff8880c774bde0 by task ip/1395
    [   52.414841][ T1395]
    [   52.430720][ T1395] CPU: 1 PID: 1395 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   52.496511][ T1395] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   52.513597][ T1395] Call Trace:
    [   52.546516][ T1395]
    [   52.558773][ T1395] Allocated by task 3171537984:
    [   52.588290][ T1395] BUG: unable to handle page fault for address: ffffffffb999e260
    [   52.589311][ T1395] #PF: supervisor read access in kernel mode
    [   52.590529][ T1395] #PF: error_code(0x0000) - not-present page
    [   52.591374][ T1395] PGD d6818067 P4D d6818067 PUD d6819063 PMD 0
    [   52.592288][ T1395] Thread overran stack, or stack corrupted
    [   52.604980][ T1395] Oops: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [   52.605856][ T1395] CPU: 1 PID: 1395 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   52.611764][ T1395] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   52.621520][ T1395] RIP: 0010:stack_depot_fetch+0x10/0x30
    [   52.622296][ T1395] Code: ff e9 f9 fe ff ff 48 89 df e8 9c 1d 91 ff e9 ca fe ff ff cc cc cc cc cc cc cc 89 f8 0
    [   52.627887][ T1395] RSP: 0018:ffff8880c774bb60 EFLAGS: 00010006
    [   52.628735][ T1395] RAX: 00000000001f8880 RBX: ffff8880c774d140 RCX: 0000000000000000
    [   52.631773][ T1395] RDX: 000000000000001d RSI: ffff8880c774bb68 RDI: 0000000000003ff0
    [   52.649584][ T1395] RBP: ffffea00031dd200 R08: ffffed101b43e403 R09: ffffed101b43e403
    [   52.674857][ T1395] R10: 0000000000000001 R11: ffffed101b43e402 R12: ffff8880d900e5c0
    [   52.678257][ T1395] R13: ffff8880c774c000 R14: 0000000000000000 R15: dffffc0000000000
    [   52.694541][ T1395] FS:  00007fe867f6e0c0(0000) GS:ffff8880da000000(0000) knlGS:0000000000000000
    [   52.764039][ T1395] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   52.815008][ T1395] CR2: ffffffffb999e260 CR3: 00000000c26aa005 CR4: 00000000000606e0
    [   52.862312][ T1395] Call Trace:
    [   52.887133][ T1395] Modules linked in: dummy rmnet veth openvswitch nsh nf_conncount nf_nat nf_conntrack nf_dex
    [   52.936749][ T1395] CR2: ffffffffb999e260
    [   52.965695][ T1395] ---[ end trace 7e32ca99482dbb31 ]---
    [   52.966556][ T1395] RIP: 0010:stack_depot_fetch+0x10/0x30
    [   52.971083][ T1395] Code: ff e9 f9 fe ff ff 48 89 df e8 9c 1d 91 ff e9 ca fe ff ff cc cc cc cc cc cc cc 89 f8 0
    [   53.003650][ T1395] RSP: 0018:ffff8880c774bb60 EFLAGS: 00010006
    [   53.043183][ T1395] RAX: 00000000001f8880 RBX: ffff8880c774d140 RCX: 0000000000000000
    [   53.076480][ T1395] RDX: 000000000000001d RSI: ffff8880c774bb68 RDI: 0000000000003ff0
    [   53.093858][ T1395] RBP: ffffea00031dd200 R08: ffffed101b43e403 R09: ffffed101b43e403
    [   53.112795][ T1395] R10: 0000000000000001 R11: ffffed101b43e402 R12: ffff8880d900e5c0
    [   53.139837][ T1395] R13: ffff8880c774c000 R14: 0000000000000000 R15: dffffc0000000000
    [   53.141500][ T1395] FS:  00007fe867f6e0c0(0000) GS:ffff8880da000000(0000) knlGS:0000000000000000
    [   53.143343][ T1395] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   53.152007][ T1395] CR2: ffffffffb999e260 CR3: 00000000c26aa005 CR4: 00000000000606e0
    [   53.156459][ T1395] Kernel panic - not syncing: Fatal exception
    [   54.213570][ T1395] Shutting down cpus with NMI
    [   54.354112][ T1395] Kernel Offset: 0x33000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0x)
    [   54.355687][ T1395] Rebooting in 5 seconds..
    
    Fixes: b37f78f234bf ("net: qualcomm: rmnet: Fix crash on real dev unregistration")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 835bbd892683bc191bf0e3ec5502a0c6e272943d
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:25:19 2020 +0000

    net: rmnet: do not allow to change mux id if mux id is duplicated
    
    [ Upstream commit 1dc49e9d164cd7e11c81279c83db84a147e14740 ]
    
    Basically, duplicate mux id isn't be allowed.
    So, the creation of rmnet will be failed if there is duplicate mux id
    is existing.
    But, changelink routine doesn't check duplicate mux id.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link add rmnet1 link dummy0 type rmnet mux_id 2
        ip link set rmnet1 type rmnet mux_id 1
    
    Fixes: 23790ef12082 ("net: qualcomm: rmnet: Allow to configure flags for existing devices")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5ce5e95d72f10e18d6d9d18931ac398940f95188
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:25:05 2020 +0000

    net: rmnet: remove rcu_read_lock in rmnet_force_unassociate_device()
    
    [ Upstream commit c026d970102e9af9958edefb4a015702c6aab636 ]
    
    The notifier_call() of the slave interface removes rmnet interface with
    unregister_netdevice_queue().
    But, before calling unregister_netdevice_queue(), it acquires
    rcu readlock.
    In the RCU critical section, sleeping isn't be allowed.
    But, unregister_netdevice_queue() internally calls synchronize_net(),
    which would sleep.
    So, suspicious RCU usage warning occurs.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add dummy1 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link set dummy1 master rmnet0
        ip link del dummy0
    
    Splat looks like:
    [   79.639245][ T1195] =============================
    [   79.640134][ T1195] WARNING: suspicious RCU usage
    [   79.640852][ T1195] 5.6.0-rc1+ #447 Not tainted
    [   79.641657][ T1195] -----------------------------
    [   79.642472][ T1195] ./include/linux/rcupdate.h:273 Illegal context switch in RCU read-side critical section!
    [   79.644043][ T1195]
    [   79.644043][ T1195] other info that might help us debug this:
    [   79.644043][ T1195]
    [   79.645682][ T1195]
    [   79.645682][ T1195] rcu_scheduler_active = 2, debug_locks = 1
    [   79.646980][ T1195] 2 locks held by ip/1195:
    [   79.647629][ T1195]  #0: ffffffffa3cf64f0 (rtnl_mutex){+.+.}, at: rtnetlink_rcv_msg+0x457/0x890
    [   79.649312][ T1195]  #1: ffffffffa39256c0 (rcu_read_lock){....}, at: rmnet_config_notify_cb+0xf0/0x590 [rmnet]
    [   79.651717][ T1195]
    [   79.651717][ T1195] stack backtrace:
    [   79.652650][ T1195] CPU: 3 PID: 1195 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   79.653702][ T1195] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   79.655037][ T1195] Call Trace:
    [   79.655560][ T1195]  dump_stack+0x96/0xdb
    [   79.656252][ T1195]  ___might_sleep+0x345/0x440
    [   79.656994][ T1195]  synchronize_net+0x18/0x30
    [   79.661132][ T1195]  netdev_rx_handler_unregister+0x40/0xb0
    [   79.666266][ T1195]  rmnet_unregister_real_device+0x42/0xb0 [rmnet]
    [   79.667211][ T1195]  rmnet_config_notify_cb+0x1f7/0x590 [rmnet]
    [   79.668121][ T1195]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   79.669166][ T1195]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   79.670286][ T1195]  ? __module_text_address+0x13/0x140
    [   79.671139][ T1195]  notifier_call_chain+0x90/0x160
    [   79.671973][ T1195]  rollback_registered_many+0x660/0xcf0
    [   79.672893][ T1195]  ? netif_set_real_num_tx_queues+0x780/0x780
    [   79.675091][ T1195]  ? __lock_acquire+0xdfe/0x3de0
    [   79.675825][ T1195]  ? memset+0x1f/0x40
    [   79.676367][ T1195]  ? __nla_validate_parse+0x98/0x1ab0
    [   79.677290][ T1195]  unregister_netdevice_many.part.133+0x13/0x1b0
    [   79.678163][ T1195]  rtnl_delete_link+0xbc/0x100
    [ ... ]
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 002b4bd9b51d688764ccd1c7cf980b3513f08271
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:24:45 2020 +0000

    net: rmnet: fix suspicious RCU usage
    
    [ Upstream commit 102210f7664442d8c0ce332c006ea90626df745b ]
    
    rmnet_get_port() internally calls rcu_dereference_rtnl(),
    which checks RTNL.
    But rmnet_get_port() could be called by packet path.
    The packet path is not protected by RTNL.
    So, the suspicious RCU usage problem occurs.
    
    Test commands:
        modprobe rmnet
        ip netns add nst
        ip link add veth0 type veth peer name veth1
        ip link set veth1 netns nst
        ip link add rmnet0 link veth0 type rmnet mux_id 1
        ip netns exec nst ip link add rmnet1 link veth1 type rmnet mux_id 1
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip link set rmnet1 up
        ip netns exec nst ip a a 192.168.100.2/24 dev rmnet1
        ip link set veth0 up
        ip link set rmnet0 up
        ip a a 192.168.100.1/24 dev rmnet0
        ping 192.168.100.2
    
    Splat looks like:
    [  146.630958][ T1174] WARNING: suspicious RCU usage
    [  146.631735][ T1174] 5.6.0-rc1+ #447 Not tainted
    [  146.632387][ T1174] -----------------------------
    [  146.633151][ T1174] drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c:386 suspicious rcu_dereference_check() !
    [  146.634742][ T1174]
    [  146.634742][ T1174] other info that might help us debug this:
    [  146.634742][ T1174]
    [  146.645992][ T1174]
    [  146.645992][ T1174] rcu_scheduler_active = 2, debug_locks = 1
    [  146.646937][ T1174] 5 locks held by ping/1174:
    [  146.647609][ T1174]  #0: ffff8880c31dea70 (sk_lock-AF_INET){+.+.}, at: raw_sendmsg+0xab8/0x2980
    [  146.662463][ T1174]  #1: ffffffff93925660 (rcu_read_lock_bh){....}, at: ip_finish_output2+0x243/0x2150
    [  146.671696][ T1174]  #2: ffffffff93925660 (rcu_read_lock_bh){....}, at: __dev_queue_xmit+0x213/0x2940
    [  146.673064][ T1174]  #3: ffff8880c19ecd58 (&dev->qdisc_running_key#7){+...}, at: ip_finish_output2+0x714/0x2150
    [  146.690358][ T1174]  #4: ffff8880c5796898 (&dev->qdisc_xmit_lock_key#3){+.-.}, at: sch_direct_xmit+0x1e2/0x1020
    [  146.699875][ T1174]
    [  146.699875][ T1174] stack backtrace:
    [  146.701091][ T1174] CPU: 0 PID: 1174 Comm: ping Not tainted 5.6.0-rc1+ #447
    [  146.705215][ T1174] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  146.706565][ T1174] Call Trace:
    [  146.707102][ T1174]  dump_stack+0x96/0xdb
    [  146.708007][ T1174]  rmnet_get_port.part.9+0x76/0x80 [rmnet]
    [  146.709233][ T1174]  rmnet_egress_handler+0x107/0x420 [rmnet]
    [  146.710492][ T1174]  ? sch_direct_xmit+0x1e2/0x1020
    [  146.716193][ T1174]  rmnet_vnd_start_xmit+0x3d/0xa0 [rmnet]
    [  146.717012][ T1174]  dev_hard_start_xmit+0x160/0x740
    [  146.717854][ T1174]  sch_direct_xmit+0x265/0x1020
    [  146.718577][ T1174]  ? register_lock_class+0x14d0/0x14d0
    [  146.719429][ T1174]  ? dev_watchdog+0xac0/0xac0
    [  146.723738][ T1174]  ? __dev_queue_xmit+0x15fd/0x2940
    [  146.724469][ T1174]  ? lock_acquire+0x164/0x3b0
    [  146.725172][ T1174]  __dev_queue_xmit+0x20c7/0x2940
    [ ... ]
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8a027eee62f74d3489ceea27e8c5fa1453b73928
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:24:26 2020 +0000

    net: rmnet: fix NULL pointer dereference in rmnet_changelink()
    
    [ Upstream commit 1eb1f43a6e37282348a41e3d68f5e9a6a4359212 ]
    
    In the rmnet_changelink(), it uses IFLA_LINK without checking
    NULL pointer.
    tb[IFLA_LINK] could be NULL pointer.
    So, NULL-ptr-deref could occur.
    
    rmnet already has a lower interface (real_dev).
    So, after this patch, rmnet_changelink() does not use IFLA_LINK anymore.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link set rmnet0 type rmnet mux_id 2
    
    Splat looks like:
    [   90.578726][ T1131] general protection fault, probably for non-canonical address 0xdffffc0000000000I
    [   90.581121][ T1131] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
    [   90.582380][ T1131] CPU: 2 PID: 1131 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   90.584285][ T1131] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   90.587506][ T1131] RIP: 0010:rmnet_changelink+0x5a/0x8a0 [rmnet]
    [   90.588546][ T1131] Code: 83 ec 20 48 c1 ea 03 80 3c 02 00 0f 85 6f 07 00 00 48 8b 5e 28 48 b8 00 00 00 00 00 0
    [   90.591447][ T1131] RSP: 0018:ffff8880ce78f1b8 EFLAGS: 00010247
    [   90.592329][ T1131] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffff8880ce78f8b0
    [   90.593253][ T1131] RDX: 0000000000000000 RSI: ffff8880ce78f4a0 RDI: 0000000000000004
    [   90.594058][ T1131] RBP: ffff8880cf543e00 R08: 0000000000000002 R09: 0000000000000002
    [   90.594859][ T1131] R10: ffffffffc0586a40 R11: 0000000000000000 R12: ffff8880ca47c000
    [   90.595690][ T1131] R13: ffff8880ca47c000 R14: ffff8880cf545000 R15: 0000000000000000
    [   90.596553][ T1131] FS:  00007f21f6c7e0c0(0000) GS:ffff8880da400000(0000) knlGS:0000000000000000
    [   90.597504][ T1131] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   90.599418][ T1131] CR2: 0000556e413db458 CR3: 00000000c917a002 CR4: 00000000000606e0
    [   90.600289][ T1131] Call Trace:
    [   90.600631][ T1131]  __rtnl_newlink+0x922/0x1270
    [   90.601194][ T1131]  ? lock_downgrade+0x6e0/0x6e0
    [   90.601724][ T1131]  ? rtnl_link_unregister+0x220/0x220
    [   90.602309][ T1131]  ? lock_acquire+0x164/0x3b0
    [   90.602784][ T1131]  ? is_bpf_image_address+0xff/0x1d0
    [   90.603331][ T1131]  ? rtnl_newlink+0x4c/0x90
    [   90.603810][ T1131]  ? kernel_text_address+0x111/0x140
    [   90.604419][ T1131]  ? __kernel_text_address+0xe/0x30
    [   90.604981][ T1131]  ? unwind_get_return_address+0x5f/0xa0
    [   90.605616][ T1131]  ? create_prof_cpu_mask+0x20/0x20
    [   90.606304][ T1131]  ? arch_stack_walk+0x83/0xb0
    [   90.606985][ T1131]  ? stack_trace_save+0x82/0xb0
    [   90.607656][ T1131]  ? stack_trace_consume_entry+0x160/0x160
    [   90.608503][ T1131]  ? deactivate_slab.isra.78+0x2c5/0x800
    [   90.609336][ T1131]  ? kasan_unpoison_shadow+0x30/0x40
    [   90.610096][ T1131]  ? kmem_cache_alloc_trace+0x135/0x350
    [   90.610889][ T1131]  ? rtnl_newlink+0x4c/0x90
    [   90.611512][ T1131]  rtnl_newlink+0x65/0x90
    [ ... ]
    
    Fixes: 23790ef12082 ("net: qualcomm: rmnet: Allow to configure flags for existing devices")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 006cd2426a056639a5daea1004450476da44c87a
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:23:52 2020 +0000

    net: rmnet: fix NULL pointer dereference in rmnet_newlink()
    
    [ Upstream commit 93b5cbfa9636d385126f211dca9efa7e3f683202 ]
    
    rmnet registers IFLA_LINK interface as a lower interface.
    But, IFLA_LINK could be NULL.
    In the current code, rmnet doesn't check IFLA_LINK.
    So, panic would occur.
    
    Test commands:
        modprobe rmnet
        ip link add rmnet0 type rmnet mux_id 1
    
    Splat looks like:
    [   36.826109][ T1115] general protection fault, probably for non-canonical address 0xdffffc0000000000I
    [   36.838817][ T1115] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
    [   36.839908][ T1115] CPU: 1 PID: 1115 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   36.840569][ T1115] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   36.841408][ T1115] RIP: 0010:rmnet_newlink+0x54/0x510 [rmnet]
    [   36.841986][ T1115] Code: 83 ec 18 48 c1 e9 03 80 3c 01 00 0f 85 d4 03 00 00 48 8b 6a 28 48 b8 00 00 00 00 00 c
    [   36.843923][ T1115] RSP: 0018:ffff8880b7e0f1c0 EFLAGS: 00010247
    [   36.844756][ T1115] RAX: dffffc0000000000 RBX: ffff8880d14cca00 RCX: 1ffff11016fc1e99
    [   36.845859][ T1115] RDX: 0000000000000000 RSI: ffff8880c3d04000 RDI: 0000000000000004
    [   36.846961][ T1115] RBP: 0000000000000000 R08: ffff8880b7e0f8b0 R09: ffff8880b6ac2d90
    [   36.848020][ T1115] R10: ffffffffc0589a40 R11: ffffed1016d585b7 R12: ffffffff88ceaf80
    [   36.848788][ T1115] R13: ffff8880c3d04000 R14: ffff8880b7e0f8b0 R15: ffff8880c3d04000
    [   36.849546][ T1115] FS:  00007f50ab3360c0(0000) GS:ffff8880da000000(0000) knlGS:0000000000000000
    [   36.851784][ T1115] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   36.852422][ T1115] CR2: 000055871afe5ab0 CR3: 00000000ae246001 CR4: 00000000000606e0
    [   36.853181][ T1115] Call Trace:
    [   36.853514][ T1115]  __rtnl_newlink+0xbdb/0x1270
    [   36.853967][ T1115]  ? lock_downgrade+0x6e0/0x6e0
    [   36.854420][ T1115]  ? rtnl_link_unregister+0x220/0x220
    [   36.854936][ T1115]  ? lock_acquire+0x164/0x3b0
    [   36.855376][ T1115]  ? is_bpf_image_address+0xff/0x1d0
    [   36.855884][ T1115]  ? rtnl_newlink+0x4c/0x90
    [   36.856304][ T1115]  ? kernel_text_address+0x111/0x140
    [   36.856857][ T1115]  ? __kernel_text_address+0xe/0x30
    [   36.857440][ T1115]  ? unwind_get_return_address+0x5f/0xa0
    [   36.858063][ T1115]  ? create_prof_cpu_mask+0x20/0x20
    [   36.858644][ T1115]  ? arch_stack_walk+0x83/0xb0
    [   36.859171][ T1115]  ? stack_trace_save+0x82/0xb0
    [   36.859710][ T1115]  ? stack_trace_consume_entry+0x160/0x160
    [   36.860357][ T1115]  ? deactivate_slab.isra.78+0x2c5/0x800
    [   36.860928][ T1115]  ? kasan_unpoison_shadow+0x30/0x40
    [   36.861520][ T1115]  ? kmem_cache_alloc_trace+0x135/0x350
    [   36.862125][ T1115]  ? rtnl_newlink+0x4c/0x90
    [   36.864073][ T1115]  rtnl_newlink+0x65/0x90
    [ ... ]
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cfc7f5fe5c6190d3e1c4247a3adec2006e18015f
Author: Luo bin <luobin9@huawei.com>
Date:   Thu Feb 27 06:34:44 2020 +0000

    hinic: fix a bug of rss configuration
    
    [ Upstream commit 386d4716fd91869e07c731657f2cde5a33086516 ]
    
    should use real receive queue number to configure hw rss
    indirect table rather than maximal queue number
    
    Signed-off-by: Luo bin <luobin9@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e6f52d5ce1722bd5600cc617f7a2e5048813ed14
Author: Luo bin <luobin9@huawei.com>
Date:   Thu Feb 27 06:34:43 2020 +0000

    hinic: fix a bug of setting hw_ioctxt
    
    [ Upstream commit d2ed69ce9ed3477e2a9527e6b89fe4689d99510e ]
    
    a reserved field is used to signify prime physical function index
    in the latest firmware version, so we must assign a value to it
    correctly
    
    Signed-off-by: Luo bin <luobin9@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 65340b196811e9287b107d5a0b55c57b24609b28
Author: Luo bin <luobin9@huawei.com>
Date:   Thu Feb 27 06:34:42 2020 +0000

    hinic: fix a irq affinity bug
    
    [ Upstream commit 0bff777bd0cba73ad4cd0145696ad284d7e6a99f ]
    
    can not use a local variable as an input parameter of
    irq_set_affinity_hint
    
    Signed-off-by: Luo bin <luobin9@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1c7dde0a9bfcb71dc0605e363f25b4b084d638a8
Author: Antoine Tenart <antoine.tenart@bootlin.com>
Date:   Wed Feb 26 16:26:50 2020 +0100

    net: phy: mscc: fix firmware paths
    
    [ Upstream commit c87a9d6fc6d555e4981f2ded77d9a8cce950743e ]
    
    The firmware paths for the VSC8584 PHYs not not contain the leading
    'microchip/' directory, as used in linux-firmware, resulting in an
    error when probing the driver. This patch fixes it.
    
    Fixes: a5afc1678044 ("net: phy: mscc: add support for VSC8584 PHY")
    Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4d6ee3123d65743b7110b8def64f8015b2adbebb
Author: yangerkun <yangerkun@huawei.com>
Date:   Wed Feb 26 11:54:35 2020 +0800

    slip: not call free_netdev before rtnl_unlock in slip_open
    
    [ Upstream commit f596c87005f7b1baeb7d62d9a9e25d68c3dfae10 ]
    
    As the description before netdev_run_todo, we cannot call free_netdev
    before rtnl_unlock, fix it by reorder the code.
    
    Signed-off-by: yangerkun <yangerkun@huawei.com>
    Reviewed-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d1984c92f07252a6a8fa6e73cd120322b125f29f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 24 12:47:14 2020 -0800

    signal: avoid double atomic counter increments for user accounting
    
    [ Upstream commit fda31c50292a5062332fa0343c084bd9f46604d9 ]
    
    When queueing a signal, we increment both the users count of pending
    signals (for RLIMIT_SIGPENDING tracking) and we increment the refcount
    of the user struct itself (because we keep a reference to the user in
    the signal structure in order to correctly account for it when freeing).
    
    That turns out to be fairly expensive, because both of them are atomic
    updates, and particularly under extreme signal handling pressure on big
    machines, you can get a lot of cache contention on the user struct.
    That can then cause horrid cacheline ping-pong when you do these
    multiple accesses.
    
    So change the reference counting to only pin the user for the _first_
    pending signal, and to unpin it when the last pending signal is
    dequeued.  That means that when a user sees a lot of concurrent signal
    queuing - which is the only situation when this matters - the only
    atomic access needed is generally the 'sigpending' count update.
    
    This was noticed because of a particularly odd timing artifact on a
    dual-socket 96C/192T Cascade Lake platform: when you get into bad
    contention, on that machine for some reason seems to be much worse when
    the contention happens in the upper 32-byte half of the cacheline.
    
    As a result, the kernel test robot will-it-scale 'signal1' benchmark had
    an odd performance regression simply due to random alignment of the
    'struct user_struct' (and pointed to a completely unrelated and
    apparently nonsensical commit for the regression).
    
    Avoiding the double increments (and decrements on the dequeueing side,
    of course) makes for much less contention and hugely improved
    performance on that will-it-scale microbenchmark.
    
    Quoting Feng Tang:
    
     "It makes a big difference, that the performance score is tripled! bump
      from original 17000 to 54000. Also the gap between 5.0-rc6 and
      5.0-rc6+Jiri's patch is reduced to around 2%"
    
    [ The "2% gap" is the odd cacheline placement difference on that
      platform: under the extreme contention case, the effect of which half
      of the cacheline was hot was 5%, so with the reduced contention the
      odd timing artifact is reduced too ]
    
    It does help in the non-contended case too, but is not nearly as
    noticeable.
    
    Reported-and-tested-by: Feng Tang <feng.tang@intel.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Huang, Ying <ying.huang@intel.com>
    Cc: Philip Li <philip.li@intel.com>
    Cc: Andi Kleen <andi.kleen@intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit df8e98b0094137189b69e21973e5b318bb8d2dcf
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Sun Feb 23 04:04:34 2020 +0900

    kbuild: add dt_binding_check to PHONY in a correct place
    
    [ Upstream commit c473a8d03ea8e03ca9d649b0b6d72fbcf6212c05 ]
    
    The dt_binding_check is added to PHONY, but it is invisible when
    $(dtstree) is empty. So, it is not specified as phony for
    ARCH=x86 etc.
    
    Add it to PHONY outside the ifneq ... endif block.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fd1f29f2a82405adb2439f020efd6ffc422e496e
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Sun Feb 23 04:04:33 2020 +0900

    kbuild: add dtbs_check to PHONY
    
    [ Upstream commit 964a596db8db8c77c9903dd05655696696e6b3ad ]
    
    The dtbs_check should be a phony target, but currently it is not
    specified so.
    
    'make dtbs_check' works even if a file named 'dtbs_check' exists
    because it depends on another phony target, scripts_dtc, but we
    should not rely on it.
    
    Add dtbs_check to PHONY.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit bbf3acbb8a7786ecf8f223fb18131ea255e0a7ef
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Sat Feb 8 19:01:21 2020 +0800

    drm/amdgpu: fix memory leak during TDR test(v2)
    
    [ Upstream commit 4829f89855f1d3a3d8014e74cceab51b421503db ]
    
    fix system memory leak
    
    v2:
    fix coding style
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 74c77d6a4ea998fed8f99e0a71e2b60295d1a57d
Author: Ming Lei <ming.lei@redhat.com>
Date:   Tue Feb 25 09:04:32 2020 +0800

    blk-mq: insert passthrough request into hctx->dispatch directly
    
    [ Upstream commit 01e99aeca3979600302913cef3f89076786f32c8 ]
    
    For some reason, device may be in one situation which can't handle
    FS request, so STS_RESOURCE is always returned and the FS request
    will be added to hctx->dispatch. However passthrough request may
    be required at that time for fixing the problem. If passthrough
    request is added to scheduler queue, there isn't any chance for
    blk-mq to dispatch it given we prioritize requests in hctx->dispatch.
    Then the FS IO request may never be completed, and IO hang is caused.
    
    So passthrough request has to be added to hctx->dispatch directly
    for fixing the IO hang.
    
    Fix this issue by inserting passthrough request into hctx->dispatch
    directly together withing adding FS request to the tail of
    hctx->dispatch in blk_mq_dispatch_rq_list(). Actually we add FS request
    to tail of hctx->dispatch at default, see blk_mq_request_bypass_insert().
    
    Then it becomes consistent with original legacy IO request
    path, in which passthrough request is always added to q->queue_head.
    
    Cc: Dongli Zhang <dongli.zhang@oracle.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Ewan D. Milne <emilne@redhat.com>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 74886a6d9de8a53ed4fee501a35da222974cf66e
Author: Esben Haabendal <esben@geanix.com>
Date:   Fri Feb 21 07:47:58 2020 +0100

    net: ll_temac: Handle DMA halt condition caused by buffer underrun
    
    [ Upstream commit 1d63b8d66d146deaaedbe16c80de105f685ea012 ]
    
    The SDMA engine used by TEMAC halts operation when it has finished
    processing of the last buffer descriptor in the buffer ring.
    Unfortunately, no interrupt event is generated when this happens,
    so we need to setup another mechanism to make sure DMA operation is
    restarted when enough buffers have been added to the ring.
    
    Fixes: 92744989533c ("net: add Xilinx ll_temac device driver")
    Signed-off-by: Esben Haabendal <esben@geanix.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c2cffaea4fde4f0938aacf5c11413750421e58ea
Author: Esben Haabendal <esben@geanix.com>
Date:   Fri Feb 21 07:47:45 2020 +0100

    net: ll_temac: Fix RX buffer descriptor handling on GFP_ATOMIC pressure
    
    [ Upstream commit 770d9c67974c4c71af4beb786dc43162ad2a15ba ]
    
    Failures caused by GFP_ATOMIC memory pressure have been observed, and
    due to the missing error handling, results in kernel crash such as
    
    [1876998.350133] kernel BUG at mm/slub.c:3952!
    [1876998.350141] invalid opcode: 0000 [#1] PREEMPT SMP PTI
    [1876998.350147] CPU: 2 PID: 0 Comm: swapper/2 Not tainted 5.3.0-scnxt #1
    [1876998.350150] Hardware name: N/A N/A/COMe-bIP2, BIOS CCR2R920 03/01/2017
    [1876998.350160] RIP: 0010:kfree+0x1ca/0x220
    [1876998.350164] Code: 85 db 74 49 48 8b 95 68 01 00 00 48 31 c2 48 89 10 e9 d7 fe ff ff 49 8b 04 24 a9 00 00 01 00 75 0b 49 8b 44 24 08 a8 01 75 02 <0f> 0b 49 8b 04 24 31 f6 a9 00 00 01 00 74 06 41 0f b6 74 24
     5b
    [1876998.350172] RSP: 0018:ffffc900000f0df0 EFLAGS: 00010246
    [1876998.350177] RAX: ffffea00027f0708 RBX: ffff888008d78000 RCX: 0000000000391372
    [1876998.350181] RDX: 0000000000000000 RSI: ffffe8ffffd01400 RDI: ffff888008d78000
    [1876998.350185] RBP: ffff8881185a5d00 R08: ffffc90000087dd8 R09: 000000000000280a
    [1876998.350189] R10: 0000000000000002 R11: 0000000000000000 R12: ffffea0000235e00
    [1876998.350193] R13: ffff8881185438a0 R14: 0000000000000000 R15: ffff888118543870
    [1876998.350198] FS:  0000000000000000(0000) GS:ffff88811f300000(0000) knlGS:0000000000000000
    [1876998.350203] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    s#1 Part1
    [1876998.350206] CR2: 00007f8dac7b09f0 CR3: 000000011e20a006 CR4: 00000000001606e0
    [1876998.350210] Call Trace:
    [1876998.350215]  <IRQ>
    [1876998.350224]  ? __netif_receive_skb_core+0x70a/0x920
    [1876998.350229]  kfree_skb+0x32/0xb0
    [1876998.350234]  __netif_receive_skb_core+0x70a/0x920
    [1876998.350240]  __netif_receive_skb_one_core+0x36/0x80
    [1876998.350245]  process_backlog+0x8b/0x150
    [1876998.350250]  net_rx_action+0xf7/0x340
    [1876998.350255]  __do_softirq+0x10f/0x353
    [1876998.350262]  irq_exit+0xb2/0xc0
    [1876998.350265]  do_IRQ+0x77/0xd0
    [1876998.350271]  common_interrupt+0xf/0xf
    [1876998.350274]  </IRQ>
    
    In order to handle such failures more graceful, this change splits the
    receive loop into one for consuming the received buffers, and one for
    allocating new buffers.
    
    When GFP_ATOMIC allocations fail, the receive will continue with the
    buffers that is still there, and with the expectation that the allocations
    will succeed in a later call to receive.
    
    Fixes: 92744989533c ("net: add Xilinx ll_temac device driver")
    Signed-off-by: Esben Haabendal <esben@geanix.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6e3b69543b5e905fc49901009845ca2e27f1a3bf
Author: Esben Haabendal <esben@geanix.com>
Date:   Fri Feb 21 07:47:33 2020 +0100

    net: ll_temac: Add more error handling of dma_map_single() calls
    
    [ Upstream commit d07c849cd2b97d6809430dfb7e738ad31088037a ]
    
    This adds error handling to the remaining dma_map_single() calls, so that
    behavior is well defined if/when we run out of DMA memory.
    
    Fixes: 92744989533c ("net: add Xilinx ll_temac device driver")
    Signed-off-by: Esben Haabendal <esben@geanix.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0c050d6554757f1be861b9f288406989c4053449
Author: Esben Haabendal <esben@geanix.com>
Date:   Fri Feb 21 07:47:21 2020 +0100

    net: ll_temac: Fix race condition causing TX hang
    
    [ Upstream commit 84823ff80f7403752b59e00bb198724100dc611c ]
    
    It is possible that the interrupt handler fires and frees up space in
    the TX ring in between checking for sufficient TX ring space and
    stopping the TX queue in temac_start_xmit. If this happens, the
    queue wake from the interrupt handler will occur before the queue is
    stopped, causing a lost wakeup and the adapter's transmit hanging.
    
    To avoid this, after stopping the queue, check again whether there is
    sufficient space in the TX ring. If so, wake up the queue again.
    
    This is a port of the similar fix in axienet driver,
    commit 7de44285c1f6 ("net: axienet: Fix race condition causing TX hang").
    
    Fixes: 23ecc4bde21f ("net: ll_temac: fix checksum offload logic")
    Signed-off-by: Esben Haabendal <esben@geanix.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a342bb7b9902cbb08ac5a948528badfcb64d8441
Author: Madhuparna Bhowmik <madhuparnabhowmik10@gmail.com>
Date:   Sun Feb 23 20:03:02 2020 +0530

    mac80211: rx: avoid RCU list traversal under mutex
    
    [ Upstream commit 253216ffb2a002a682c6f68bd3adff5b98b71de8 ]
    
    local->sta_mtx is held in __ieee80211_check_fast_rx_iface().
    No need to use list_for_each_entry_rcu() as it also requires
    a cond argument to avoid false lockdep warnings when not used in
    RCU read-side section (with CONFIG_PROVE_RCU_LIST).
    Therefore use list_for_each_entry();
    
    Signed-off-by: Madhuparna Bhowmik <madhuparnabhowmik10@gmail.com>
    Link: https://lore.kernel.org/r/20200223143302.15390-1-madhuparnabhowmik10@gmail.com
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5d92d834aa27a8592a3c83aa88d18b60a56a010a
Author: Marek Vasut <marex@denx.de>
Date:   Sun Feb 23 14:38:40 2020 +0100

    net: ks8851-ml: Fix IRQ handling and locking
    
    [ Upstream commit 44343418d0f2f623cb9da6f5000df793131cbe3b ]
    
    The KS8851 requires that packet RX and TX are mutually exclusive.
    Currently, the driver hopes to achieve this by disabling interrupt
    from the card by writing the card registers and by disabling the
    interrupt on the interrupt controller. This however is racy on SMP.
    
    Replace this approach by expanding the spinlock used around the
    ks_start_xmit() TX path to ks_irq() RX path to assure true mutual
    exclusion and remove the interrupt enabling/disabling, which is
    now not needed anymore. Furthermore, disable interrupts also in
    ks_net_stop(), which was missing before.
    
    Note that a massive improvement here would be to re-use the KS8851
    driver approach, which is to move the TX path into a worker thread,
    interrupt handling to threaded interrupt, and synchronize everything
    with mutexes, but that would be a much bigger rework, for a separate
    patch.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: Petr Stetiar <ynezz@true.cz>
    Cc: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d939f3389f9bc1cb7c734b6b79148aa1ff21e7d6
Author: Daniele Palmas <dnlplm@gmail.com>
Date:   Fri Feb 21 14:17:05 2020 +0100

    net: usb: qmi_wwan: restore mtu min/max values after raw_ip switch
    
    [ Upstream commit eae7172f8141eb98e64e6e81acc9e9d5b2add127 ]
    
    usbnet creates network interfaces with min_mtu = 0 and
    max_mtu = ETH_MAX_MTU.
    
    These values are not modified by qmi_wwan when the network interface
    is created initially, allowing, for example, to set mtu greater than 1500.
    
    When a raw_ip switch is done (raw_ip set to 'Y', then set to 'N') the mtu
    values for the network interface are set through ether_setup, with
    min_mtu = ETH_MIN_MTU and max_mtu = ETH_DATA_LEN, not allowing anymore to
    set mtu greater than 1500 (error: mtu greater than device maximum).
    
    The patch restores the original min/max mtu values set by usbnet after a
    raw_ip switch.
    
    Signed-off-by: Daniele Palmas <dnlplm@gmail.com>
    Acked-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6c663120ecdb8d06968f7cfbfb0ed8e9b7e299e0
Author: Igor Druzhinin <igor.druzhinin@citrix.com>
Date:   Tue Jan 14 14:43:19 2020 +0000

    scsi: libfc: free response frame from GPN_ID
    
    [ Upstream commit ff6993bb79b9f99bdac0b5378169052931b65432 ]
    
    fc_disc_gpn_id_resp() should be the last function using it so free it here
    to avoid memory leak.
    
    Link: https://lore.kernel.org/r/1579013000-14570-2-git-send-email-igor.druzhinin@citrix.com
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Igor Druzhinin <igor.druzhinin@citrix.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 079e9ad79410dbcae245dc4bffa1f5d17682d69e
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Feb 21 10:44:50 2020 +0100

    cfg80211: check reg_rule for NULL in handle_channel_custom()
    
    [ Upstream commit a7ee7d44b57c9ae174088e53a668852b7f4f452d ]
    
    We may end up with a NULL reg_rule after the loop in
    handle_channel_custom() if the bandwidth didn't fit,
    check if this is the case and bail out if so.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Link: https://lore.kernel.org/r/20200221104449.3b558a50201c.I4ad3725c4dacaefd2d18d3cc65ba6d18acd5dbfe@changeid
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a6f7e69cfafd19daeea51f60083b4528444ee086
Author: Tom Zanussi <zanussi@kernel.org>
Date:   Fri Feb 14 16:56:41 2020 -0600

    tracing: Fix number printing bug in print_synth_event()
    
    [ Upstream commit 784bd0847eda032ed2f3522f87250655a18c0190 ]
    
    Fix a varargs-related bug in print_synth_event() which resulted in
    strange output and oopses on 32-bit x86 systems. The problem is that
    trace_seq_printf() expects the varargs to match the format string, but
    print_synth_event() was always passing u64 values regardless.  This
    results in unspecified behavior when unpacking with va_arg() in
    trace_seq_printf().
    
    Add a function that takes the size into account when calling
    trace_seq_printf().
    
    Before:
    
      modprobe-1731  [003] ....   919.039758: gen_synth_test: next_pid_field=777(null)next_comm_field=hula hoops ts_ns=1000000 ts_ms=1000 cpu=3(null)my_string_field=thneed my_int_field=598(null)
    
    After:
    
     insmod-1136  [001] ....    36.634590: gen_synth_test: next_pid_field=777 next_comm_field=hula hoops ts_ns=1000000 ts_ms=1000 cpu=1 my_string_field=thneed my_int_field=598
    
    Link: http://lkml.kernel.org/r/a9b59eb515dbbd7d4abe53b347dccf7a8e285657.1581720155.git.zanussi@kernel.org
    
    Reported-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Tom Zanussi <zanussi@kernel.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c35aa36fec91975a8c2d7b7003d87c87c4b3f6ae
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Feb 20 22:37:48 2020 +1100

    selftests/rseq: Fix out-of-tree compilation
    
    [ Upstream commit ef89d0545132d685f73da6f58b7e7fe002536f91 ]
    
    Currently if you build with O=... the rseq tests don't build:
    
      $ make O=$PWD/output -C tools/testing/selftests/ TARGETS=rseq
      make: Entering directory '/linux/tools/testing/selftests'
      ...
      make[1]: Entering directory '/linux/tools/testing/selftests/rseq'
      gcc -O2 -Wall -g -I./ -I../../../../usr/include/ -L./ -Wl,-rpath=./  -shared -fPIC rseq.c -lpthread -o /linux/output/rseq/librseq.so
      gcc -O2 -Wall -g -I./ -I../../../../usr/include/ -L./ -Wl,-rpath=./  basic_test.c -lpthread -lrseq -o /linux/output/rseq/basic_test
      /usr/bin/ld: cannot find -lrseq
      collect2: error: ld returned 1 exit status
    
    This is because the library search path points to the source
    directory, not the output.
    
    We can fix it by changing the library search path to $(OUTPUT).
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit dd0d2d6ab6a2c13382512f9bd11634fc7588568a
Author: Hanno Zulla <kontakt@hanno.de>
Date:   Tue Feb 18 12:39:31 2020 +0100

    HID: hid-bigbenff: fix race condition for scheduled work during removal
    
    [ Upstream commit 4eb1b01de5b9d8596d6c103efcf1a15cfc1bedf7 ]
    
    It's possible that there is scheduled work left while the device is
    already being removed, which can cause a kernel crash. Adding a flag
    will avoid this.
    
    Signed-off-by: Hanno Zulla <kontakt@hanno.de>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ccb747d805d3552e99019e3f8b9c2a28e75cacdf
Author: Hanno Zulla <kontakt@hanno.de>
Date:   Tue Feb 18 12:38:34 2020 +0100

    HID: hid-bigbenff: call hid_hw_stop() in case of error
    
    [ Upstream commit 976a54d0f4202cb412a3b1fc7f117e1d97db35f3 ]
    
    It's required to call hid_hw_stop() once hid_hw_start() was called
    previously, so error cases need to handle this. Also, hid_hw_close() is
    not necessary during removal.
    
    Signed-off-by: Hanno Zulla <kontakt@hanno.de>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1bc271dd397d1f7a74ae4511019bf83f678f2960
Author: Hanno Zulla <kontakt@hanno.de>
Date:   Tue Feb 18 12:37:47 2020 +0100

    HID: hid-bigbenff: fix general protection fault caused by double kfree
    
    [ Upstream commit 789a2c250340666220fa74bc6c8f58497e3863b3 ]
    
    The struct *bigben was allocated via devm_kzalloc() and then used as a
    parameter in input_ff_create_memless(). This caused a double kfree
    during removal of the device, since both the managed resource API and
    ml_ff_destroy() in drivers/input/ff-memless.c would call kfree() on it.
    
    Signed-off-by: Hanno Zulla <kontakt@hanno.de>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 190e929e6cba5a9bcb7dd6c6f5acf8713d04c3c9
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Fri Feb 14 14:53:07 2020 +0800

    HID: i2c-hid: add Trekstor Surfbook E11B to descriptor override
    
    [ Upstream commit be0aba826c4a6ba5929def1962a90d6127871969 ]
    
    The Surfbook E11B uses the SIPODEV SP1064 touchpad, which does not supply
    descriptors, so it has to be added to the override list.
    
    BugLink: https://bugs.launchpad.net/bugs/1858299
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 87bd74b77531b9eb6ce2f1a160d73e2f9451484c
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Feb 12 17:59:41 2020 +0300

    ACPI: watchdog: Set default timeout in probe
    
    [ Upstream commit cabe17d0173ab04bd3f87b8199ae75f43f1ea473 ]
    
    If the BIOS default timeout for the watchdog is too small userspace may
    not have enough time to configure new timeout after opening the device
    before the system is already reset. For this reason program default
    timeout of 30 seconds in the driver probe and allow userspace to change
    this from command line or through module parameter (wdat_wdt.timeout).
    
    Reported-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 65b44497414b97b38bcbb1c6f718151998250e29
Author: Mansour Behabadi <mansour@oxplot.com>
Date:   Wed Jan 29 17:26:31 2020 +1100

    HID: apple: Add support for recent firmware on Magic Keyboards
    
    [ Upstream commit e433be929e63265b7412478eb7ff271467aee2d7 ]
    
    Magic Keyboards with more recent firmware (0x0100) report Fn key differently.
    Without this patch, Fn key may not behave as expected and may not be
    configurable via hid_apple fnmode module parameter.
    
    Signed-off-by: Mansour Behabadi <mansour@oxplot.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 20eed76927492b4a2b099e40835e8b9a686f6748
Author: Jean Delvare <jdelvare@suse.de>
Date:   Thu Feb 6 16:58:45 2020 +0100

    ACPI: watchdog: Allow disabling WDAT at boot
    
    [ Upstream commit 3f9e12e0df012c4a9a7fd7eb0d3ae69b459d6b2c ]
    
    In case the WDAT interface is broken, give the user an option to
    ignore it to let a native driver bind to the watchdog device instead.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f3c478104a9a47ee13864f0b2c16912ec6f126ea
Author: Felix Kuehling <Felix.Kuehling@amd.com>
Date:   Fri Jan 17 19:54:45 2020 -0500

    drm/amdgpu: Fix TLB invalidation request when using semaphore
    
    [ Upstream commit 37c58ddf57364d1a636850bb8ba6acbe1e16195e ]
    
    Use a more meaningful variable name for the invalidation request
    that is distinct from the tmp variable that gets overwritten when
    acquiring the invalidation semaphore.
    
    Fixes: 4ed8a03740d0 ("drm/amdgpu: invalidate mmhub semaphore workaround in gmc9/gmc10")
    Signed-off-by: Felix Kuehling <Felix.Kuehling@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Yong Zhao <Yong.Zhao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f6fccb0a0e59d6e34fab80f5684764d689f27ca7
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Wed Feb 12 22:53:52 2020 -0800

    netfilter: xt_hashlimit: unregister proc file before releasing mutex
    
    [ Upstream commit 99b79c3900d4627672c85d9f344b5b0f06bc2a4d ]
    
    Before releasing the global mutex, we only unlink the hashtable
    from the hash list, its proc file is still not unregistered at
    this point. So syzbot could trigger a race condition where a
    parallel htable_create() could register the same file immediately
    after the mutex is released.
    
    Move htable_remove_proc_entry() back to mutex protection to
    fix this. And, fold htable_destroy() into htable_put() to make
    the code slightly easier to understand.
    
    Reported-and-tested-by: syzbot+d195fd3b9a364ddd6731@syzkaller.appspotmail.com
    Fixes: c4a3922d2d20 ("netfilter: xt_hashlimit: reduce hashlimit_mutex scope for htable_put()")
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 536942bf70b5d51a0e800d09adb6b57605e7227c
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Jan 7 12:25:10 2020 +0100

    netfilter: hashlimit: do not use indirect calls during gc
    
    [ Upstream commit 28b3a4270c0fc064557e409111f2a678e64b6fa7 ]
    
    no need, just use a simple boolean to indicate we want to reap all
    entries.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
