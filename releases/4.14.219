commit edf7dfe5d9ae60daeea947324eff5784e9b4036b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Feb 3 23:22:23 2021 +0100

    Linux 4.14.219
    
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20210202132942.138623851@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 432f313577d47bcdec08ac0316ae5b3a02ddeb61
Author: Pengcheng Yang <yangpc@wangsu.com>
Date:   Sun Jan 24 13:07:14 2021 +0800

    tcp: fix TLP timer not set when CA_STATE changes from DISORDER to OPEN
    
    commit 62d9f1a6945ba69c125e548e72a36d203b30596e upstream.
    
    Upon receiving a cumulative ACK that changes the congestion state from
    Disorder to Open, the TLP timer is not set. If the sender is app-limited,
    it can only wait for the RTO timer to expire and retransmit.
    
    The reason for this is that the TLP timer is set before the congestion
    state changes in tcp_ack(), so we delay the time point of calling
    tcp_set_xmit_timer() until after tcp_fastretrans_alert() returns and
    remove the FLAG_SET_XMIT_TIMER from ack_flag when the RACK reorder timer
    is set.
    
    This commit has two additional benefits:
    1) Make sure to reset RTO according to RFC6298 when receiving ACK, to
    avoid spurious RTO caused by RTO timer early expires.
    2) Reduce the xmit timer reschedule once per ACK when the RACK reorder
    timer is set.
    
    Fixes: df92c8394e6e ("tcp: fix xmit timer to only be reset if data ACKed/SACKed")
    Link: https://lore.kernel.org/netdev/1611311242-6675-1-git-send-email-yangpc@wangsu.com
    Signed-off-by: Pengcheng Yang <yangpc@wangsu.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Acked-by: Yuchung Cheng <ycheng@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Link: https://lore.kernel.org/r/1611464834-23030-1-git-send-email-yangpc@wangsu.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ca0a26360d8814474e1bf0fdb1525586418c3886
Author: Ivan Vecera <ivecera@redhat.com>
Date:   Mon Jan 25 08:44:16 2021 +0100

    team: protect features update by RCU to avoid deadlock
    
    commit f0947d0d21b219e03940b9be6628a43445c0de7a upstream.
    
    Function __team_compute_features() is protected by team->lock
    mutex when it is called from team_compute_features() used when
    features of an underlying device is changed. This causes
    a deadlock when NETDEV_FEAT_CHANGE notifier for underlying device
    is fired due to change propagated from team driver (e.g. MTU
    change). It's because callbacks like team_change_mtu() or
    team_vlan_rx_{add,del}_vid() protect their port list traversal
    by team->lock mutex.
    
    Example (r8169 case where this driver disables TSO for certain MTU
    values):
    ...
    [ 6391.348202]  __mutex_lock.isra.6+0x2d0/0x4a0
    [ 6391.358602]  team_device_event+0x9d/0x160 [team]
    [ 6391.363756]  notifier_call_chain+0x47/0x70
    [ 6391.368329]  netdev_update_features+0x56/0x60
    [ 6391.373207]  rtl8169_change_mtu+0x14/0x50 [r8169]
    [ 6391.378457]  dev_set_mtu_ext+0xe1/0x1d0
    [ 6391.387022]  dev_set_mtu+0x52/0x90
    [ 6391.390820]  team_change_mtu+0x64/0xf0 [team]
    [ 6391.395683]  dev_set_mtu_ext+0xe1/0x1d0
    [ 6391.399963]  do_setlink+0x231/0xf50
    ...
    
    In fact team_compute_features() called from team_device_event()
    does not need to be protected by team->lock mutex and rcu_read_lock()
    is sufficient there for port list traversal.
    
    Fixes: 3d249d4ca7d0 ("net: introduce ethernet teaming device")
    Cc: Saeed Mahameed <saeed@kernel.org>
    Signed-off-by: Ivan Vecera <ivecera@redhat.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Reviewed-by: Jiri Pirko <jiri@nvidia.com>
    Link: https://lore.kernel.org/r/20210125074416.4056484-1-ivecera@redhat.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f7f55a40b65bfc2f15bc695ad9f93b996ccc8ea3
Author: Pan Bian <bianpan2016@163.com>
Date:   Thu Jan 21 07:37:45 2021 -0800

    NFC: fix possible resource leak
    
    commit d8f923c3ab96dbbb4e3c22d1afc1dc1d3b195cd8 upstream.
    
    Put the device to avoid resource leak on path that the polling flag is
    invalid.
    
    Fixes: a831b9132065 ("NFC: Do not return EBUSY when stopping a poll that's already stopped")
    Signed-off-by: Pan Bian <bianpan2016@163.com>
    Link: https://lore.kernel.org/r/20210121153745.122184-1-bianpan2016@163.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a49daeaa592c0d2cf7b378f6240ac69c7b019e1e
Author: Pan Bian <bianpan2016@163.com>
Date:   Thu Jan 21 07:27:48 2021 -0800

    NFC: fix resource leak when target index is invalid
    
    commit 3a30537cee233fb7da302491b28c832247d89bbe upstream.
    
    Goto to the label put_dev instead of the label error to fix potential
    resource leak on path that the target index is invalid.
    
    Fixes: c4fbb6515a4d ("NFC: The core part should generate the target index")
    Signed-off-by: Pan Bian <bianpan2016@163.com>
    Link: https://lore.kernel.org/r/20210121152748.98409-1-bianpan2016@163.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 49639ef61f0e4e8e3923573b7b226d5d2566dea1
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Tue Feb 2 01:04:45 2021 +0100

    iommu/vt-d: Don't dereference iommu_device if IOMMU_API is not built
    
    commit 9def3b1a07c41e21c68a0eb353e3e569fdd1d2b1 upstream.
    
    Since commit c40aaaac1018 ("iommu/vt-d: Gracefully handle DMAR units
    with no supported address widths") dmar.c needs struct iommu_device to
    be selected. We can drop this dependency by not dereferencing struct
    iommu_device if IOMMU_API is not selected and by reusing the information
    stored in iommu->drhd->ignored instead.
    
    This fixes the following build error when IOMMU_API is not selected:
    
    drivers/iommu/dmar.c: In function ‘free_iommu’:
    drivers/iommu/dmar.c:1139:41: error: ‘struct iommu_device’ has no member named ‘ops’
     1139 |  if (intel_iommu_enabled && iommu->iommu.ops) {
                                                    ^
    
    Fixes: c40aaaac1018 ("iommu/vt-d: Gracefully handle DMAR units with no supported address widths")
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
    Acked-by: David Woodhouse <dwmw@amazon.co.uk>
    Link: https://lore.kernel.org/r/20201013073055.11262-1-brgl@bgdev.pl
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    [ - context change due to moving drivers/iommu/dmar.c to
        drivers/iommu/intel/dmar.c
      - set the drhr in the iommu like in upstream commit b1012ca8dc4f
        ("iommu/vt-d: Skip TE disabling on quirky gfx dedicated iommu") ]
    Signed-off-by: Filippo Sironi <sironi@amazon.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bc4093706c88772ecba469c6c564fb710ca68316
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Tue Feb 2 01:04:44 2021 +0100

    iommu/vt-d: Gracefully handle DMAR units with no supported address widths
    
    commit c40aaaac1018ff1382f2d35df5129a6bcea3df6b upstream.
    
    Instead of bailing out completely, such a unit can still be used for
    interrupt remapping.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Reviewed-by: Lu Baolu <baolu.lu@linux.intel.com>
    Link: https://lore.kernel.org/linux-iommu/549928db2de6532117f36c9c810373c14cf76f51.camel@infradead.org/
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    [ context change due to moving drivers/iommu/dmar.c to
      drivers/iommu/intel/dmar.c ]
    Signed-off-by: Filippo Sironi <sironi@amazon.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f57a527a52cb634fc7d5637b270be1c0a1682995
Author: Andy Lutomirski <luto@kernel.org>
Date:   Tue Jun 26 22:45:52 2018 -0700

    x86/entry/64/compat: Fix "x86/entry/64/compat: Preserve r8-r11 in int $0x80"
    
    commit 22cd978e598618e82c3c3348d2069184f6884182 upstream.
    
    Commit:
    
      8bb2610bc496 ("x86/entry/64/compat: Preserve r8-r11 in int $0x80")
    
    was busted: my original patch had a minor conflict with
    some of the nospec changes, but "git apply" is very clever
    and silently accepted the patch by making the same changes
    to a different function in the same file.  There was obviously
    a huge offset, but "git apply" for some reason doesn't feel
    any need to say so.
    
    Move the changes to the correct function.  Now the
    test_syscall_vdso_32 selftests passes.
    
    If anyone cares to observe the original problem, try applying the
    patch at:
    
      https://lore.kernel.org/lkml/d4c4d9985fbe64f8c9e19291886453914b48caee.1523975710.git.luto@kernel.org/raw
    
    to the kernel at 316d097c4cd4e7f2ef50c40cff2db266593c4ec4:
    
     - "git am" and "git apply" accept the patch without any complaints at all
     - "patch -p1" at least prints out a message about the huge offset.
    
    Reported-by: zhijianx.li@intel.com
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org #v4.17+
    Fixes: 8bb2610bc496 ("x86/entry/64/compat: Preserve r8-r11 in int $0x80")
    Link: http://lkml.kernel.org/r/6012b922485401bc42676e804171ded262fc2ef2.1530078306.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Alistair Delva <adelva@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1e1911b2ea10cf0007050b372352e0851eb4c27c
Author: Andy Lutomirski <luto@kernel.org>
Date:   Tue Apr 17 07:36:36 2018 -0700

    x86/entry/64/compat: Preserve r8-r11 in int $0x80
    
    commit 8bb2610bc4967f19672444a7b0407367f1540028 upstream.
    
    32-bit user code that uses int $80 doesn't care about r8-r11.  There is,
    however, some 64-bit user code that intentionally uses int $0x80 to invoke
    32-bit system calls.  From what I've seen, basically all such code assumes
    that r8-r15 are all preserved, but the kernel clobbers r8-r11.  Since I
    doubt that there's any code that depends on int $0x80 zeroing r8-r11,
    change the kernel to preserve them.
    
    I suspect that very little user code is broken by the old clobber, since
    r8-r11 are only rarely allocated by gcc, and they're clobbered by function
    calls, so they only way we'd see a problem is if the same function that
    invokes int $0x80 also spills something important to one of these
    registers.
    
    The current behavior seems to date back to the historical commit
    "[PATCH] x86-64 merge for 2.6.4".  Before that, all regs were
    preserved.  I can't find any explanation of why this change was made.
    
    Update the test_syscall_vdso_32 testcase as well to verify the new
    behavior, and it strengthens the test to make sure that the kernel doesn't
    accidentally permute r8..r15.
    
    Suggested-by: Denys Vlasenko <dvlasenk@redhat.com>
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Link: https://lkml.kernel.org/r/d4c4d9985fbe64f8c9e19291886453914b48caee.1523975710.git.luto@kernel.org
    Signed-off-by: Alistair Delva <adelva@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2efc5bfe67024ee56fb5eb831081263895eb5970
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jan 21 09:08:05 2021 +0300

    can: dev: prevent potential information leak in can_fill_info()
    
    [ Upstream commit b552766c872f5b0d90323b24e4c9e8fa67486dd5 ]
    
    The "bec" struct isn't necessarily always initialized. For example, the
    mcp251xfd_get_berr_counter() function doesn't initialize anything if the
    interface is down.
    
    Fixes: 52c793f24054 ("can: netlink support for bus-error reporting and counters")
    Link: https://lore.kernel.org/r/YAkaRdRJncsJO8Ve@mwanda
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d882652c1c6fc339c5fb9535005f70ee79f11859
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jan 22 17:11:16 2021 +0100

    mac80211: pause TX while changing interface type
    
    [ Upstream commit 054c9939b4800a91475d8d89905827bf9e1ad97a ]
    
    syzbot reported a crash that happened when changing the interface
    type around a lot, and while it might have been easy to fix just
    the symptom there, a little deeper investigation found that really
    the reason is that we allowed packets to be transmitted while in
    the middle of changing the interface type.
    
    Disallow TX by stopping the queues while changing the type.
    
    Fixes: 34d4bc4d41d2 ("mac80211: support runtime interface type changes")
    Reported-by: syzbot+d7a3b15976bf7de2238a@syzkaller.appspotmail.com
    Link: https://lore.kernel.org/r/20210122171115.b321f98f4d4f.I6997841933c17b093535c31d29355be3c0c39628@changeid
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 006015bdd3a465af54153ddf319d3ec0b67ac300
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jan 15 13:05:58 2021 +0200

    iwlwifi: pcie: reschedule in long-running memory reads
    
    [ Upstream commit 3d372c4edfd4dffb7dea71c6b096fb414782b776 ]
    
    If we spin for a long time in memory reads that (for some reason in
    hardware) take a long time, then we'll eventually get messages such
    as
    
      watchdog: BUG: soft lockup - CPU#2 stuck for 24s! [kworker/2:2:272]
    
    This is because the reading really does take a very long time, and
    we don't schedule, so we're hogging the CPU with this task, at least
    if CONFIG_PREEMPT is not set, e.g. with CONFIG_PREEMPT_VOLUNTARY=y.
    
    Previously I misinterpreted the situation and thought that this was
    only going to happen if we had interrupts disabled, and then fixed
    this (which is good anyway, however), but that didn't always help;
    looking at it again now I realized that the spin unlock will only
    reschedule if CONFIG_PREEMPT is used.
    
    In order to avoid this issue, change the code to cond_resched() if
    we've been spinning for too long here.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Fixes: 04516706bb99 ("iwlwifi: pcie: limit memory read spin time")
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/iwlwifi.20210115130253.217a9d6a6a12.If964cb582ab0aaa94e81c4ff3b279eaafda0fd3f@changeid
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fa55f96464ab5bfbcc2f5be2ea4fda40529e7c17
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jan 15 13:05:57 2021 +0200

    iwlwifi: pcie: use jiffies for memory read spin time limit
    
    [ Upstream commit 6701317476bbfb1f341aa935ddf75eb73af784f9 ]
    
    There's no reason to use ktime_get() since we don't need any better
    precision than jiffies, and since we no longer disable interrupts
    around this code (when grabbing NIC access), jiffies will work fine.
    Use jiffies instead of ktime_get().
    
    This cleanup is preparation for the following patch "iwlwifi: pcie: reschedule
    in long-running memory reads". The code gets simpler with the weird clock use
    etc. removed before we add cond_resched().
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/iwlwifi.20210115130253.621c948b1fad.I3ee9f4bc4e74a0c9125d42fb7c35cd80df4698a1@changeid
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8ef6c49a63057962a009338f9f00f9c8c53bc640
Author: Kamal Heib <kamalheib1@gmail.com>
Date:   Thu Jan 14 21:14:23 2021 +0200

    RDMA/cxgb4: Fix the reported max_recv_sge value
    
    [ Upstream commit a372173bf314d374da4dd1155549d8ca7fc44709 ]
    
    The max_recv_sge value is wrongly reported when calling query_qp, This is
    happening due to a typo when assigning the max_recv_sge value, the value
    of sq_max_sges was assigned instead of rq_max_sges.
    
    Fixes: 3e5c02c9ef9a ("iw_cxgb4: Support query_qp() verb")
    Link: https://lore.kernel.org/r/20210114191423.423529-1-kamalheib1@gmail.com
    Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
    Reviewed-by: Potnuri Bharat Teja <bharat@chelsio.com>
    Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5e63f64ff531887d57ee5d7820c3bf71481fef1c
Author: Shmulik Ladkani <shmulik@metanetworks.com>
Date:   Mon Dec 14 15:38:32 2020 +0200

    xfrm: Fix oops in xfrm_replay_advance_bmp
    
    [ Upstream commit 56ce7c25ae1525d83cf80a880cf506ead1914250 ]
    
    When setting xfrm replay_window to values higher than 32, a rare
    page-fault occurs in xfrm_replay_advance_bmp:
    
      BUG: unable to handle page fault for address: ffff8af350ad7920
      #PF: supervisor write access in kernel mode
      #PF: error_code(0x0002) - not-present page
      PGD ad001067 P4D ad001067 PUD 0
      Oops: 0002 [#1] SMP PTI
      CPU: 3 PID: 30 Comm: ksoftirqd/3 Kdump: loaded Not tainted 5.4.52-050452-generic #202007160732
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-2.el7 04/01/2014
      RIP: 0010:xfrm_replay_advance_bmp+0xbb/0x130
      RSP: 0018:ffffa1304013ba40 EFLAGS: 00010206
      RAX: 000000000000010d RBX: 0000000000000002 RCX: 00000000ffffff4b
      RDX: 0000000000000018 RSI: 00000000004c234c RDI: 00000000ffb3dbff
      RBP: ffffa1304013ba50 R08: ffff8af330ad7920 R09: 0000000007fffffa
      R10: 0000000000000800 R11: 0000000000000010 R12: ffff8af29d6258c0
      R13: ffff8af28b95c700 R14: 0000000000000000 R15: ffff8af29d6258fc
      FS:  0000000000000000(0000) GS:ffff8af339ac0000(0000) knlGS:0000000000000000
      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      CR2: ffff8af350ad7920 CR3: 0000000015ee4000 CR4: 00000000001406e0
      Call Trace:
       xfrm_input+0x4e5/0xa10
       xfrm4_rcv_encap+0xb5/0xe0
       xfrm4_udp_encap_rcv+0x140/0x1c0
    
    Analysis revealed offending code is when accessing:
    
            replay_esn->bmp[nr] |= (1U << bitnr);
    
    with 'nr' being 0x07fffffa.
    
    This happened in an SMP system when reordering of packets was present;
    A packet arrived with a "too old" sequence number (outside the window,
    i.e 'diff > replay_window'), and therefore the following calculation:
    
                            bitnr = replay_esn->replay_window - (diff - pos);
    
    yields a negative result, but since bitnr is u32 we get a large unsigned
    quantity (in crash dump above: 0xffffff4b seen in ecx).
    
    This was supposed to be protected by xfrm_input()'s former call to:
    
                    if (x->repl->check(x, skb, seq)) {
    
    However, the state's spinlock x->lock is *released* after '->check()'
    is performed, and gets re-acquired before '->advance()' - which gives a
    chance for a different core to update the xfrm state, e.g. by advancing
    'replay_esn->seq' when it encounters more packets - leading to a
    'diff > replay_window' situation when original core continues to
    xfrm_replay_advance_bmp().
    
    An attempt to fix this issue was suggested in commit bcf66bf54aab
    ("xfrm: Perform a replay check after return from async codepaths"),
    by calling 'x->repl->recheck()' after lock is re-acquired, but fix
    applied only to asyncronous crypto algorithms.
    
    Augment the fix, by *always* calling 'recheck()' - irrespective if we're
    using async crypto.
    
    Fixes: 0ebea8ef3559 ("[IPSEC]: Move state lock into x->type->input")
    Signed-off-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2e99e44b6b2cf3401fb84a1088405706340ac8dc
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Sat Jan 16 19:20:15 2021 +0100

    netfilter: nft_dynset: add timeout extension to template
    
    commit 0c5b7a501e7400869ee905b4f7af3d6717802bcb upstream.
    
    Otherwise, the newly create element shows no timeout when listing the
    ruleset. If the set definition does not specify a default timeout, then
    the set element only shows the expiration time, but not the timeout.
    This is a problem when restoring a stateful ruleset listing since it
    skips the timeout policy entirely.
    
    Fixes: 22fe54d5fefc ("netfilter: nf_tables: add support for dynamic set updates")
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0d1cf08c0e3b7b7df3846495091c647ace2688a0
Author: Max Krummenacher <max.oss.09@gmail.com>
Date:   Mon Jan 11 16:17:04 2021 +0100

    ARM: imx: build suspend-imx6.S with arm instruction set
    
    commit a88afa46b86ff461c89cc33fc3a45267fff053e8 upstream.
    
    When the kernel is configured to use the Thumb-2 instruction set
    "suspend-to-memory" fails to resume. Observed on a Colibri iMX6ULL
    (i.MX 6ULL) and Apalis iMX6 (i.MX 6Q).
    
    It looks like the CPU resumes unconditionally in ARM instruction mode
    and then chokes on the presented Thumb-2 code it should execute.
    
    Fix this by using the arm instruction set for all code in
    suspend-imx6.S.
    
    Signed-off-by: Max Krummenacher <max.krummenacher@toradex.com>
    Fixes: df595746fa69 ("ARM: imx: add suspend in ocram support for i.mx6q")
    Acked-by: Oleksandr Suvorov <oleksandr.suvorov@toradex.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c95d60f23eb7ba5af210b7a1e60af7c2c1840fee
Author: Roger Pau Monne <roger.pau@citrix.com>
Date:   Tue Jan 19 11:57:27 2021 +0100

    xen-blkfront: allow discard-* nodes to be optional
    
    commit 0549cd67b01016b579047bce045b386202a8bcfc upstream.
    
    This is inline with the specification described in blkif.h:
    
     * discard-granularity: should be set to the physical block size if
       node is not present.
     * discard-alignment, discard-secure: should be set to 0 if node not
       present.
    
    This was detected as QEMU would only create the discard-granularity
    node but not discard-alignment, and thus the setup done in
    blkfront_setup_discard would fail.
    
    Fix blkfront_setup_discard to not fail on missing nodes, and also fix
    blkif_set_queue_limits to set the discard granularity to the physical
    block size if none is specified in xenbus.
    
    Fixes: ed30bf317c5ce ('xen-blkfront: Handle discard requests.')
    Reported-by: Arthur Borsboom <arthurborsboom@gmail.com>
    Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Tested-By: Arthur Borsboom <arthurborsboom@gmail.com>
    Link: https://lore.kernel.org/r/20210119105727.95173-1-roger.pau@citrix.com
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7e17073a914b2be1182c660eb71640842b22cc8e
Author: Lorenzo Bianconi <lorenzo@kernel.org>
Date:   Thu Jan 14 18:10:52 2021 +0100

    mt7601u: fix rx buffer refcounting
    
    commit d24c790577ef01bfa01da2b131313a38c843a634 upstream.
    
    Fix the following crash due to erroneous page refcounting:
    
    [   32.445919] BUG: Bad page state in process swapper/1  pfn:11f65a
    [   32.447409] page:00000000938f0632 refcount:0 mapcount:-128 mapping:0000000000000000 index:0x0 pfn:0x11f65a
    [   32.449605] flags: 0x8000000000000000()
    [   32.450421] raw: 8000000000000000 ffffffff825b0148 ffffea00045ae988 0000000000000000
    [   32.451795] raw: 0000000000000000 0000000000000001 00000000ffffff7f 0000000000000000
    [   32.452999] page dumped because: nonzero mapcount
    [   32.453888] Modules linked in:
    [   32.454492] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 5.11.0-rc2+ #1976
    [   32.455695] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-1.fc33 04/01/2014
    [   32.457157] Call Trace:
    [   32.457636]  <IRQ>
    [   32.457993]  dump_stack+0x77/0x97
    [   32.458576]  bad_page.cold+0x65/0x96
    [   32.459198]  get_page_from_freelist+0x46a/0x11f0
    [   32.460008]  __alloc_pages_nodemask+0x10a/0x2b0
    [   32.460794]  mt7601u_rx_tasklet+0x651/0x720
    [   32.461505]  tasklet_action_common.constprop.0+0x6b/0xd0
    [   32.462343]  __do_softirq+0x152/0x46c
    [   32.462928]  asm_call_irq_on_stack+0x12/0x20
    [   32.463610]  </IRQ>
    [   32.463953]  do_softirq_own_stack+0x5b/0x70
    [   32.464582]  irq_exit_rcu+0x9f/0xe0
    [   32.465028]  common_interrupt+0xae/0x1a0
    [   32.465536]  asm_common_interrupt+0x1e/0x40
    [   32.466071] RIP: 0010:default_idle+0x18/0x20
    [   32.468981] RSP: 0018:ffffc90000077f00 EFLAGS: 00000246
    [   32.469648] RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000000
    [   32.470550] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff81aac3dd
    [   32.471463] RBP: ffff88810022ab00 R08: 0000000000000001 R09: 0000000000000001
    [   32.472335] R10: 0000000000000046 R11: 0000000000005aa0 R12: 0000000000000000
    [   32.473235] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
    [   32.474139]  ? default_idle_call+0x4d/0x200
    [   32.474681]  default_idle_call+0x74/0x200
    [   32.475192]  do_idle+0x1d5/0x250
    [   32.475612]  cpu_startup_entry+0x19/0x20
    [   32.476114]  secondary_startup_64_no_verify+0xb0/0xbb
    [   32.476765] Disabling lock debugging due to kernel taint
    
    Fixes: c869f77d6abb ("add mt7601u driver")
    Co-developed-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
    Acked-by: Jakub Kicinski <kubakici@wp.pl>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/62b2380c8c2091834cfad05e1059b55f945bd114.1610643952.git.lorenzo@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7c72c9ebd76ebb07b963eda13680fba99b353997
Author: Lorenzo Bianconi <lorenzo@kernel.org>
Date:   Sun Jan 17 22:46:01 2021 +0100

    mt7601u: fix kernel crash unplugging the device
    
    commit 0acb20a5438c36e0cf2b8bf255f314b59fcca6ef upstream.
    
    The following crash log can occur unplugging the usb dongle since,
    after the urb poison in mt7601u_free_tx_queue(), usb_submit_urb() will
    always fail resulting in a skb kfree while the skb has been already
    queued.
    
    Fix the issue enqueuing the skb only if usb_submit_urb() succeed.
    
    Hardware name: Hewlett-Packard 500-539ng/2B2C, BIOS 80.06 04/01/2015
    Workqueue: usb_hub_wq hub_event
    RIP: 0010:skb_trim+0x2c/0x30
    RSP: 0000:ffffb4c88005bba8 EFLAGS: 00010206
    RAX: 000000004ad483ee RBX: ffff9a236625dee0 RCX: 000000000000662f
    RDX: 000000000000000c RSI: 0000000000000000 RDI: ffff9a2343179300
    RBP: ffff9a2343179300 R08: 0000000000000001 R09: 0000000000000000
    R10: ffff9a23748f7840 R11: 0000000000000001 R12: ffff9a236625e4d4
    R13: ffff9a236625dee0 R14: 0000000000001080 R15: 0000000000000008
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007fd410a34ef8 CR3: 00000001416ee001 CR4: 00000000001706f0
    Call Trace:
     mt7601u_tx_status+0x3e/0xa0 [mt7601u]
     mt7601u_dma_cleanup+0xca/0x110 [mt7601u]
     mt7601u_cleanup+0x22/0x30 [mt7601u]
     mt7601u_disconnect+0x22/0x60 [mt7601u]
     usb_unbind_interface+0x8a/0x270
     ? kernfs_find_ns+0x35/0xd0
     __device_release_driver+0x17a/0x230
     device_release_driver+0x24/0x30
     bus_remove_device+0xdb/0x140
     device_del+0x18b/0x430
     ? kobject_put+0x98/0x1d0
     usb_disable_device+0xc6/0x1f0
     usb_disconnect.cold+0x7e/0x20a
     hub_event+0xbf3/0x1870
     process_one_work+0x1b6/0x350
     worker_thread+0x53/0x3e0
     ? process_one_work+0x350/0x350
     kthread+0x11b/0x140
     ? __kthread_bind_mask+0x60/0x60
     ret_from_fork+0x22/0x30
    
    Fixes: 23377c200b2eb ("mt7601u: fix possible memory leak when the device is disconnected")
    Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
    Acked-by: Jakub Kicinski <kubakici@wp.pl>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/3b85219f669a63a8ced1f43686de05915a580489.1610919247.git.lorenzo@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 659788d29cc31ccf9a837945878e0f4652d7e9b8
Author: Andrea Righi <andrea.righi@canonical.com>
Date:   Wed Nov 25 16:18:22 2020 +0100

    leds: trigger: fix potential deadlock with libata
    
    commit 27af8e2c90fba242460b01fa020e6e19ed68c495 upstream.
    
    We have the following potential deadlock condition:
    
     ========================================================
     WARNING: possible irq lock inversion dependency detected
     5.10.0-rc2+ #25 Not tainted
     --------------------------------------------------------
     swapper/3/0 just changed the state of lock:
     ffff8880063bd618 (&host->lock){-...}-{2:2}, at: ata_bmdma_interrupt+0x27/0x200
     but this lock took another, HARDIRQ-READ-unsafe lock in the past:
      (&trig->leddev_list_lock){.+.?}-{2:2}
    
     and interrupts could create inverse lock ordering between them.
    
     other info that might help us debug this:
      Possible interrupt unsafe locking scenario:
    
            CPU0                    CPU1
            ----                    ----
       lock(&trig->leddev_list_lock);
                                    local_irq_disable();
                                    lock(&host->lock);
                                    lock(&trig->leddev_list_lock);
       <Interrupt>
         lock(&host->lock);
    
      *** DEADLOCK ***
    
     no locks held by swapper/3/0.
    
     the shortest dependencies between 2nd lock and 1st lock:
      -> (&trig->leddev_list_lock){.+.?}-{2:2} ops: 46 {
         HARDIRQ-ON-R at:
                           lock_acquire+0x15f/0x420
                           _raw_read_lock+0x42/0x90
                           led_trigger_event+0x2b/0x70
                           rfkill_global_led_trigger_worker+0x94/0xb0
                           process_one_work+0x240/0x560
                           worker_thread+0x58/0x3d0
                           kthread+0x151/0x170
                           ret_from_fork+0x1f/0x30
         IN-SOFTIRQ-R at:
                           lock_acquire+0x15f/0x420
                           _raw_read_lock+0x42/0x90
                           led_trigger_event+0x2b/0x70
                           kbd_bh+0x9e/0xc0
                           tasklet_action_common.constprop.0+0xe9/0x100
                           tasklet_action+0x22/0x30
                           __do_softirq+0xcc/0x46d
                           run_ksoftirqd+0x3f/0x70
                           smpboot_thread_fn+0x116/0x1f0
                           kthread+0x151/0x170
                           ret_from_fork+0x1f/0x30
         SOFTIRQ-ON-R at:
                           lock_acquire+0x15f/0x420
                           _raw_read_lock+0x42/0x90
                           led_trigger_event+0x2b/0x70
                           rfkill_global_led_trigger_worker+0x94/0xb0
                           process_one_work+0x240/0x560
                           worker_thread+0x58/0x3d0
                           kthread+0x151/0x170
                           ret_from_fork+0x1f/0x30
         INITIAL READ USE at:
                               lock_acquire+0x15f/0x420
                               _raw_read_lock+0x42/0x90
                               led_trigger_event+0x2b/0x70
                               rfkill_global_led_trigger_worker+0x94/0xb0
                               process_one_work+0x240/0x560
                               worker_thread+0x58/0x3d0
                               kthread+0x151/0x170
                               ret_from_fork+0x1f/0x30
       }
       ... key      at: [<ffffffff83da4c00>] __key.0+0x0/0x10
       ... acquired at:
        _raw_read_lock+0x42/0x90
        led_trigger_blink_oneshot+0x3b/0x90
        ledtrig_disk_activity+0x3c/0xa0
        ata_qc_complete+0x26/0x450
        ata_do_link_abort+0xa3/0xe0
        ata_port_freeze+0x2e/0x40
        ata_hsm_qc_complete+0x94/0xa0
        ata_sff_hsm_move+0x177/0x7a0
        ata_sff_pio_task+0xc7/0x1b0
        process_one_work+0x240/0x560
        worker_thread+0x58/0x3d0
        kthread+0x151/0x170
        ret_from_fork+0x1f/0x30
    
     -> (&host->lock){-...}-{2:2} ops: 69 {
        IN-HARDIRQ-W at:
                         lock_acquire+0x15f/0x420
                         _raw_spin_lock_irqsave+0x52/0xa0
                         ata_bmdma_interrupt+0x27/0x200
                         __handle_irq_event_percpu+0xd5/0x2b0
                         handle_irq_event+0x57/0xb0
                         handle_edge_irq+0x8c/0x230
                         asm_call_irq_on_stack+0xf/0x20
                         common_interrupt+0x100/0x1c0
                         asm_common_interrupt+0x1e/0x40
                         native_safe_halt+0xe/0x10
                         arch_cpu_idle+0x15/0x20
                         default_idle_call+0x59/0x1c0
                         do_idle+0x22c/0x2c0
                         cpu_startup_entry+0x20/0x30
                         start_secondary+0x11d/0x150
                         secondary_startup_64_no_verify+0xa6/0xab
        INITIAL USE at:
                        lock_acquire+0x15f/0x420
                        _raw_spin_lock_irqsave+0x52/0xa0
                        ata_dev_init+0x54/0xe0
                        ata_link_init+0x8b/0xd0
                        ata_port_alloc+0x1f1/0x210
                        ata_host_alloc+0xf1/0x130
                        ata_host_alloc_pinfo+0x14/0xb0
                        ata_pci_sff_prepare_host+0x41/0xa0
                        ata_pci_bmdma_prepare_host+0x14/0x30
                        piix_init_one+0x21f/0x600
                        local_pci_probe+0x48/0x80
                        pci_device_probe+0x105/0x1c0
                        really_probe+0x221/0x490
                        driver_probe_device+0xe9/0x160
                        device_driver_attach+0xb2/0xc0
                        __driver_attach+0x91/0x150
                        bus_for_each_dev+0x81/0xc0
                        driver_attach+0x1e/0x20
                        bus_add_driver+0x138/0x1f0
                        driver_register+0x91/0xf0
                        __pci_register_driver+0x73/0x80
                        piix_init+0x1e/0x2e
                        do_one_initcall+0x5f/0x2d0
                        kernel_init_freeable+0x26f/0x2cf
                        kernel_init+0xe/0x113
                        ret_from_fork+0x1f/0x30
      }
      ... key      at: [<ffffffff83d9fdc0>] __key.6+0x0/0x10
      ... acquired at:
        __lock_acquire+0x9da/0x2370
        lock_acquire+0x15f/0x420
        _raw_spin_lock_irqsave+0x52/0xa0
        ata_bmdma_interrupt+0x27/0x200
        __handle_irq_event_percpu+0xd5/0x2b0
        handle_irq_event+0x57/0xb0
        handle_edge_irq+0x8c/0x230
        asm_call_irq_on_stack+0xf/0x20
        common_interrupt+0x100/0x1c0
        asm_common_interrupt+0x1e/0x40
        native_safe_halt+0xe/0x10
        arch_cpu_idle+0x15/0x20
        default_idle_call+0x59/0x1c0
        do_idle+0x22c/0x2c0
        cpu_startup_entry+0x20/0x30
        start_secondary+0x11d/0x150
        secondary_startup_64_no_verify+0xa6/0xab
    
    This lockdep splat is reported after:
    commit e918188611f0 ("locking: More accurate annotations for read_lock()")
    
    To clarify:
     - read-locks are recursive only in interrupt context (when
       in_interrupt() returns true)
     - after acquiring host->lock in CPU1, another cpu (i.e. CPU2) may call
       write_lock(&trig->leddev_list_lock) that would be blocked by CPU0
       that holds trig->leddev_list_lock in read-mode
     - when CPU1 (ata_ac_complete()) tries to read-lock
       trig->leddev_list_lock, it would be blocked by the write-lock waiter
       on CPU2 (because we are not in interrupt context, so the read-lock is
       not recursive)
     - at this point if an interrupt happens on CPU0 and
       ata_bmdma_interrupt() is executed it will try to acquire host->lock,
       that is held by CPU1, that is currently blocked by CPU2, so:
    
       * CPU0 blocked by CPU1
       * CPU1 blocked by CPU2
       * CPU2 blocked by CPU0
    
         *** DEADLOCK ***
    
    The deadlock scenario is better represented by the following schema
    (thanks to Boqun Feng <boqun.feng@gmail.com> for the schema and the
    detailed explanation of the deadlock condition):
    
     CPU 0:                          CPU 1:                        CPU 2:
     -----                           -----                         -----
     led_trigger_event():
       read_lock(&trig->leddev_list_lock);
                                    <workqueue>
                                    ata_hsm_qc_complete():
                                      spin_lock_irqsave(&host->lock);
                                                                    write_lock(&trig->leddev_list_lock);
                                      ata_port_freeze():
                                        ata_do_link_abort():
                                          ata_qc_complete():
                                            ledtrig_disk_activity():
                                              led_trigger_blink_oneshot():
                                                read_lock(&trig->leddev_list_lock);
                                                // ^ not in in_interrupt() context, so could get blocked by CPU 2
     <interrupt>
       ata_bmdma_interrupt():
         spin_lock_irqsave(&host->lock);
    
    Fix by using read_lock_irqsave/irqrestore() in led_trigger_event(), so
    that no interrupt can happen in between, preventing the deadlock
    condition.
    
    Apply the same change to led_trigger_blink_setup() as well, since the
    same deadlock scenario can also happen in power_supply_update_bat_leds()
    -> led_trigger_blink() -> led_trigger_blink_setup() (workqueue context),
    and potentially prevent other similar usages.
    
    Link: https://lore.kernel.org/lkml/20201101092614.GB3989@xps-13-7390/
    Fixes: eb25cb9956cc ("leds: convert IDE trigger to common disk trigger")
    Signed-off-by: Andrea Righi <andrea.righi@canonical.com>
    Signed-off-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit afcf80b1184a8a0b4b710fff33dc70be62d8e3c7
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Tue Jan 26 17:01:49 2021 +0000

    xen: Fix XenStore initialisation for XS_LOCAL
    
    commit 5f46400f7a6a4fad635d5a79e2aa5a04a30ffea1 upstream.
    
    In commit 3499ba8198ca ("xen: Fix event channel callback via INTX/GSI")
    I reworked the triggering of xenbus_probe().
    
    I tried to simplify things by taking out the workqueue based startup
    triggered from wake_waiting(); the somewhat poorly named xenbus IRQ
    handler.
    
    I missed the fact that in the XS_LOCAL case (Dom0 starting its own
    xenstored or xenstore-stubdom, which happens after the kernel is booted
    completely), that IRQ-based trigger is still actually needed.
    
    So... put it back, except more cleanly. By just spawning a xenbus_probe
    thread which waits on xb_waitq and runs the probe the first time it
    gets woken, just as the workqueue-based hack did.
    
    This is actually a nicer approach for *all* the back ends with different
    interrupt methods, and we can switch them all over to that without the
    complex conditions for when to trigger it. But not in -rc6. This is
    the minimal fix for the regression, although it's a step in the right
    direction instead of doing a partial revert and actually putting the
    workqueue back. It's also simpler than the workqueue.
    
    Fixes: 3499ba8198ca ("xen: Fix event channel callback via INTX/GSI")
    Reported-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Link: https://lore.kernel.org/r/4c9af052a6e0f6485d1de43f2c38b1461996db99.camel@infradead.org
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Cc: Salvatore Bonaccorso <carnil@debian.org>
    Cc: Jason Andryuk <jandryuk@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 44f8442a5135e78aeb38be73f8dfc7f8357e0396
Author: Jay Zhou <jianjay.zhou@huawei.com>
Date:   Mon Jan 18 16:47:20 2021 +0800

    KVM: x86: get smi pending status correctly
    
    commit 1f7becf1b7e21794fc9d460765fe09679bc9b9e0 upstream.
    
    The injection process of smi has two steps:
    
        Qemu                        KVM
    Step1:
        cpu->interrupt_request &= \
            ~CPU_INTERRUPT_SMI;
        kvm_vcpu_ioctl(cpu, KVM_SMI)
    
                                    call kvm_vcpu_ioctl_smi() and
                                    kvm_make_request(KVM_REQ_SMI, vcpu);
    
    Step2:
        kvm_vcpu_ioctl(cpu, KVM_RUN, 0)
    
                                    call process_smi() if
                                    kvm_check_request(KVM_REQ_SMI, vcpu) is
                                    true, mark vcpu->arch.smi_pending = true;
    
    The vcpu->arch.smi_pending will be set true in step2, unfortunately if
    vcpu paused between step1 and step2, the kvm_run->immediate_exit will be
    set and vcpu has to exit to Qemu immediately during step2 before mark
    vcpu->arch.smi_pending true.
    During VM migration, Qemu will get the smi pending status from KVM using
    KVM_GET_VCPU_EVENTS ioctl at the downtime, then the smi pending status
    will be lost.
    
    Signed-off-by: Jay Zhou <jianjay.zhou@huawei.com>
    Signed-off-by: Shengen Zhuang <zhuangshengen@huawei.com>
    Message-Id: <20210118084720.1585-1-jianjay.zhou@huawei.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1e5c631d6482a1f334a8c351de8f1e50b78017a0
Author: Like Xu <like.xu@linux.intel.com>
Date:   Wed Dec 30 16:19:16 2020 +0800

    KVM: x86/pmu: Fix HW_REF_CPU_CYCLES event pseudo-encoding in intel_arch_events[]
    
    commit 98dd2f108e448988d91e296173e773b06fb978b8 upstream.
    
    The HW_REF_CPU_CYCLES event on the fixed counter 2 is pseudo-encoded as
    0x0300 in the intel_perfmon_event_map[]. Correct its usage.
    
    Fixes: 62079d8a4312 ("KVM: PMU: add proper support for fixed counter 2")
    Signed-off-by: Like Xu <like.xu@linux.intel.com>
    Message-Id: <20201230081916.63417-1-like.xu@linux.intel.com>
    Reviewed-by: Sean Christopherson <seanjc@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 28287a0d207f94c0cd77a820ac4f118f1bd1cbd7
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Fri Jan 22 14:21:34 2021 +0200

    drivers: soc: atmel: add null entry at the end of at91_soc_allowed_list[]
    
    commit 680896556805d3ad3fa47f6002b87b3041a45ac2 upstream.
    
    of_match_node() calls __of_match_node() which loops though the entries of
    matches array. It stops when condition:
    (matches->name[0] || matches->type[0] || matches->compatible[0]) is
    false. Thus, add a null entry at the end of at91_soc_allowed_list[]
    array.
    
    Fixes: caab13b49604 ("drivers: soc: atmel: Avoid calling at91_soc_init on non AT91 SoCs")
    Cc: stable@vger.kernel.org #4.12+
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b64c11166e3a9d8f832537581832844beb974cb1
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Fri Dec 11 13:58:46 2020 +0000

    drivers: soc: atmel: Avoid calling at91_soc_init on non AT91 SoCs
    
    commit caab13b4960416b9fee83169a758eb0f31e65109 upstream.
    
    Since at91_soc_init is called unconditionally from atmel_soc_device_init,
    we get the following warning on all non AT91 SoCs:
            " AT91: Could not find identification node"
    
    Fix the same by filtering with allowed AT91 SoC list.
    
    Cc: Nicolas Ferre <nicolas.ferre@microchip.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Ludovic Desroches <ludovic.desroches@microchip.com>
    Cc: stable@vger.kernel.org #4.12+
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20201211135846.1334322-1-sudeep.holla@arm.com
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1c931eb816dfe6c9210d3476ba9750b6a553d6db
Author: Giacinto Cifelli <gciofono@gmail.com>
Date:   Wed Jan 20 05:56:50 2021 +0100

    net: usb: qmi_wwan: added support for Thales Cinterion PLSx3 modem family
    
    commit 7e0e63d09516e96994c879f07c5a3c3269d7015e upstream.
    
    Bus 003 Device 009: ID 1e2d:006f
    Device Descriptor:
      bLength                18
      bDescriptorType         1
      bcdUSB               2.00
      bDeviceClass          239 Miscellaneous Device
      bDeviceSubClass         2 ?
      bDeviceProtocol         1 Interface Association
      bMaxPacketSize0        64
      idVendor           0x1e2d
      idProduct          0x006f
      bcdDevice            0.00
      iManufacturer           3 Cinterion Wireless Modules
      iProduct                2 PLSx3
      iSerial                 4 fa3c1419
      bNumConfigurations      1
      Configuration Descriptor:
        bLength                 9
        bDescriptorType         2
        wTotalLength          303
        bNumInterfaces          9
        bConfigurationValue     1
        iConfiguration          1 Cinterion Configuration
        bmAttributes         0xe0
          Self Powered
          Remote Wakeup
        MaxPower              500mA
        Interface Association:
          bLength                 8
          bDescriptorType        11
          bFirstInterface         0
          bInterfaceCount         2
          bFunctionClass          2 Communications
          bFunctionSubClass       2 Abstract (modem)
          bFunctionProtocol       1 AT-commands (v.25ter)
          iFunction               0
        Interface Descriptor:
          bLength                 9
          bDescriptorType         4
          bInterfaceNumber        0
          bAlternateSetting       0
          bNumEndpoints           1
          bInterfaceClass         2 Communications
          bInterfaceSubClass      2 Abstract (modem)
          bInterfaceProtocol      1 AT-commands (v.25ter)
          iInterface              0
          CDC Header:
            bcdCDC               1.10
          CDC ACM:
            bmCapabilities       0x02
              line coding and serial state
          CDC Call Management:
            bmCapabilities       0x03
              call management
              use DataInterface
            bDataInterface          1
          CDC Union:
            bMasterInterface        0
            bSlaveInterface         1
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x81  EP 1 IN
            bmAttributes            3
              Transfer Type            Interrupt
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0040  1x 64 bytes
            bInterval               5
        Interface Descriptor:
          bLength                 9
          bDescriptorType         4
          bInterfaceNumber        1
          bAlternateSetting       0
          bNumEndpoints           2
          bInterfaceClass        10 CDC Data
          bInterfaceSubClass      0 Unused
          bInterfaceProtocol      0
          iInterface              0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x82  EP 2 IN
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x01  EP 1 OUT
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
        Interface Association:
          bLength                 8
          bDescriptorType        11
          bFirstInterface         2
          bInterfaceCount         2
          bFunctionClass          2 Communications
          bFunctionSubClass       2 Abstract (modem)
          bFunctionProtocol       1 AT-commands (v.25ter)
          iFunction               0
        Interface Descriptor:
          bLength                 9
          bDescriptorType         4
          bInterfaceNumber        2
          bAlternateSetting       0
          bNumEndpoints           1
          bInterfaceClass         2 Communications
          bInterfaceSubClass      2 Abstract (modem)
          bInterfaceProtocol      1 AT-commands (v.25ter)
          iInterface              0
          CDC Header:
            bcdCDC               1.10
          CDC ACM:
            bmCapabilities       0x02
              line coding and serial state
          CDC Call Management:
            bmCapabilities       0x03
              call management
              use DataInterface
            bDataInterface          3
          CDC Union:
            bMasterInterface        2
            bSlaveInterface         3
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x83  EP 3 IN
            bmAttributes            3
              Transfer Type            Interrupt
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0040  1x 64 bytes
            bInterval               5
        Interface Descriptor:
          bLength                 9
          bDescriptorType         4
          bInterfaceNumber        3
          bAlternateSetting       0
          bNumEndpoints           2
          bInterfaceClass        10 CDC Data
          bInterfaceSubClass      0 Unused
          bInterfaceProtocol      0
          iInterface              0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x84  EP 4 IN
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x02  EP 2 OUT
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
        Interface Association:
          bLength                 8
          bDescriptorType        11
          bFirstInterface         4
          bInterfaceCount         2
          bFunctionClass          2 Communications
          bFunctionSubClass       2 Abstract (modem)
          bFunctionProtocol       1 AT-commands (v.25ter)
          iFunction               0
        Interface Descriptor:
          bLength                 9
          bDescriptorType         4
          bInterfaceNumber        4
          bAlternateSetting       0
          bNumEndpoints           1
          bInterfaceClass         2 Communications
          bInterfaceSubClass      2 Abstract (modem)
          bInterfaceProtocol      1 AT-commands (v.25ter)
          iInterface              0
          CDC Header:
            bcdCDC               1.10
          CDC ACM:
            bmCapabilities       0x02
              line coding and serial state
          CDC Call Management:
            bmCapabilities       0x03
              call management
              use DataInterface
            bDataInterface          5
          CDC Union:
            bMasterInterface        4
            bSlaveInterface         5
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x85  EP 5 IN
            bmAttributes            3
              Transfer Type            Interrupt
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0040  1x 64 bytes
            bInterval               5
        Interface Descriptor:
          bLength                 9
          bDescriptorType         4
          bInterfaceNumber        5
          bAlternateSetting       0
          bNumEndpoints           2
          bInterfaceClass        10 CDC Data
          bInterfaceSubClass      0 Unused
          bInterfaceProtocol      0
          iInterface              0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x86  EP 6 IN
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x03  EP 3 OUT
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
        Interface Association:
          bLength                 8
          bDescriptorType        11
          bFirstInterface         6
          bInterfaceCount         2
          bFunctionClass          2 Communications
          bFunctionSubClass       2 Abstract (modem)
          bFunctionProtocol       1 AT-commands (v.25ter)
          iFunction               0
        Interface Descriptor:
          bLength                 9
          bDescriptorType         4
          bInterfaceNumber        6
          bAlternateSetting       0
          bNumEndpoints           1
          bInterfaceClass         2 Communications
          bInterfaceSubClass      2 Abstract (modem)
          bInterfaceProtocol      1 AT-commands (v.25ter)
          iInterface              0
          CDC Header:
            bcdCDC               1.10
          CDC ACM:
            bmCapabilities       0x02
              line coding and serial state
          CDC Call Management:
            bmCapabilities       0x03
              call management
              use DataInterface
            bDataInterface          7
          CDC Union:
            bMasterInterface        6
            bSlaveInterface         7
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x87  EP 7 IN
            bmAttributes            3
              Transfer Type            Interrupt
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0040  1x 64 bytes
            bInterval               5
        Interface Descriptor:
          bLength                 9
          bDescriptorType         4
          bInterfaceNumber        7
          bAlternateSetting       0
          bNumEndpoints           2
          bInterfaceClass        10 CDC Data
          bInterfaceSubClass      0 Unused
          bInterfaceProtocol      0
          iInterface              0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x88  EP 8 IN
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x04  EP 4 OUT
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
        Interface Descriptor:
          bLength                 9
          bDescriptorType         4
          bInterfaceNumber        8
          bAlternateSetting       0
          bNumEndpoints           3
          bInterfaceClass       255 Vendor Specific Class
          bInterfaceSubClass    255 Vendor Specific Subclass
          bInterfaceProtocol    255 Vendor Specific Protocol
          iInterface              0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x89  EP 9 IN
            bmAttributes            3
              Transfer Type            Interrupt
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0040  1x 64 bytes
            bInterval               5
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x8a  EP 10 IN
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
          Endpoint Descriptor:
            bLength                 7
            bDescriptorType         5
            bEndpointAddress     0x05  EP 5 OUT
            bmAttributes            2
              Transfer Type            Bulk
              Synch Type               None
              Usage Type               Data
            wMaxPacketSize     0x0200  1x 512 bytes
            bInterval               0
    Device Qualifier (for other device speed):
      bLength                10
      bDescriptorType         6
      bcdUSB               2.00
      bDeviceClass          239 Miscellaneous Device
      bDeviceSubClass         2 ?
      bDeviceProtocol         1 Interface Association
      bMaxPacketSize0        64
      bNumConfigurations      1
    Device Status:     0x0000
      (Bus Powered)
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Giacinto Cifelli <gciofono@gmail.com>
    Acked-by: Bjørn Mork <bjorn@mork.no>
    Link: https://lore.kernel.org/r/20210120045650.10855-1-gciofono@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 173b67cf1e72baff9cc02351cbe3c207b6ae29a4
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Jan 21 17:16:22 2021 +0100

    wext: fix NULL-ptr-dereference with cfg80211's lack of commit()
    
    commit 5122565188bae59d507d90a9a9fd2fd6107f4439 upstream.
    
    Since cfg80211 doesn't implement commit, we never really cared about
    that code there (and it's configured out w/o CONFIG_WIRELESS_EXT).
    After all, since it has no commit, it shouldn't return -EIWCOMMIT to
    indicate commit is needed.
    
    However, EIWCOMMIT is actually an alias for EINPROGRESS, which _can_
    happen if e.g. we try to change the frequency but we're already in
    the process of connecting to some network, and drivers could return
    that value (or even cfg80211 itself might).
    
    This then causes us to crash because dev->wireless_handlers is NULL
    but we try to check dev->wireless_handlers->standard[0].
    
    Fix this by also checking dev->wireless_handlers. Also simplify the
    code a little bit.
    
    Cc: stable@vger.kernel.org
    Reported-by: syzbot+444248c79e117bc99f46@syzkaller.appspotmail.com
    Reported-by: syzbot+8b2a88a09653d4084179@syzkaller.appspotmail.com
    Link: https://lore.kernel.org/r/20210121171621.2076e4a37d5a.I5d9c72220fe7bb133fb718751da0180a57ecba4e@changeid
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8ec82d5a30668f30e6b724e6090965c14b47b250
Author: Koen Vandeputte <koen.vandeputte@citymesh.com>
Date:   Thu Jan 7 10:19:06 2021 +0100

    ARM: dts: imx6qdl-gw52xx: fix duplicate regulator naming
    
    commit 5a22747b76ca2384057d8e783265404439d31d7f upstream.
    
    2 regulator descriptions carry identical naming.
    
    This leads to following boot warning:
    [    0.173138] debugfs: Directory 'vdd1p8' with parent 'regulator' already present!
    
    Fix this by renaming the one used for audio.
    
    Fixes: 5051bff33102 ("ARM: dts: imx: ventana: add LTC3676 PMIC support")
    Signed-off-by: Tim Harvey <tharvey@gateworks.com>
    Signed-off-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
    Cc: stable@vger.kernel.org # v4.11
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f6aa187f6c0ab7c5ac042bdd6c084002ce8c5c7d
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Fri Jan 22 20:53:02 2021 +0800

    ACPI: sysfs: Prefer "compatible" modalias
    
    commit 36af2d5c4433fb40ee2af912c4ac0a30991aecfc upstream.
    
    Commit 8765c5ba1949 ("ACPI / scan: Rework modalias creation when
    "compatible" is present") may create two "MODALIAS=" in one uevent
    file if specific conditions are met.
    
    This breaks systemd-udevd, which assumes each "key" in one uevent file
    to be unique. The internal implementation of systemd-udevd overwrites
    the first MODALIAS with the second one, so its kmod rule doesn't load
    the driver for the first MODALIAS.
    
    So if both the ACPI modalias and the OF modalias are present, use the
    latter to ensure that there will be only one MODALIAS.
    
    Link: https://github.com/systemd/systemd/pull/18163
    Suggested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Fixes: 8765c5ba1949 ("ACPI / scan: Rework modalias creation when "compatible" is present")
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: 4.1+ <stable@vger.kernel.org> # 4.1+
    [ rjw: Subject and changelog edits ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 51359110d9d9b0231dc6a60716895104c73e7770
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Mon Jan 25 12:21:02 2021 -0500

    nbd: freeze the queue while we're adding connections
    
    commit b98e762e3d71e893b221f871825dc64694cfb258 upstream.
    
    When setting up a device, we can krealloc the config->socks array to add
    new sockets to the configuration.  However if we happen to get a IO
    request in at this point even though we aren't setup we could hit a UAF,
    as we deref config->socks without any locking, assuming that the
    configuration was setup already and that ->socks is safe to access it as
    we have a reference on the configuration.
    
    But there's nothing really preventing IO from occurring at this point of
    the device setup, we don't want to incur the overhead of a lock to
    access ->socks when it will never change while the device is running.
    To fix this UAF scenario simply freeze the queue if we are adding
    sockets.  This will protect us from this particular case without adding
    any additional overhead for the normal running case.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
