commit 1872b07a2ec0357e1349cc0081b182dd0b3e9dd7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Mar 30 14:41:43 2021 +0200

    Linux 4.9.264
    
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Jason Self <jason@bluehome.net>
    Tested-by: Shuah Khan <skhan@linuxfoundation.org>
    Tested-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Link: https://lore.kernel.org/r/20210329075607.561619583@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3cb86952ce3c8b28a0c1f3ce82848618d8628015
Author: Jan Beulich <jbeulich@suse.com>
Date:   Fri Mar 26 16:28:57 2021 +0100

    xen-blkback: don't leak persistent grants from xen_blkbk_map()
    
    commit a846738f8c3788d846ed1f587270d2f2e3d32432 upstream.
    
    The fix for XSA-365 zapped too many of the ->persistent_gnt[] entries.
    Ones successfully obtained should not be overwritten, but instead left
    for xen_blkbk_unmap_prepare() to pick up and put.
    
    This is XSA-371.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Wei Liu <wl@xen.org>
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fffbb8528930f34c5a9b9e3562de0167a5377d52
Author: Markus Theil <markus.theil@tu-ilmenau.de>
Date:   Sat Feb 13 14:36:53 2021 +0100

    mac80211: fix double free in ibss_leave
    
    commit 3bd801b14e0c5d29eeddc7336558beb3344efaa3 upstream.
    
    Clear beacon ie pointer and ie length after free
    in order to prevent double free.
    
    ==================================================================
    BUG: KASAN: double-free or invalid-free \
    in ieee80211_ibss_leave+0x83/0xe0 net/mac80211/ibss.c:1876
    
    CPU: 0 PID: 8472 Comm: syz-executor100 Not tainted 5.11.0-rc6-syzkaller #0
    Call Trace:
     __dump_stack lib/dump_stack.c:79 [inline]
     dump_stack+0x107/0x163 lib/dump_stack.c:120
     print_address_description.constprop.0.cold+0x5b/0x2c6 mm/kasan/report.c:230
     kasan_report_invalid_free+0x51/0x80 mm/kasan/report.c:355
     ____kasan_slab_free+0xcc/0xe0 mm/kasan/common.c:341
     kasan_slab_free include/linux/kasan.h:192 [inline]
     __cache_free mm/slab.c:3424 [inline]
     kfree+0xed/0x270 mm/slab.c:3760
     ieee80211_ibss_leave+0x83/0xe0 net/mac80211/ibss.c:1876
     rdev_leave_ibss net/wireless/rdev-ops.h:545 [inline]
     __cfg80211_leave_ibss+0x19a/0x4c0 net/wireless/ibss.c:212
     __cfg80211_leave+0x327/0x430 net/wireless/core.c:1172
     cfg80211_leave net/wireless/core.c:1221 [inline]
     cfg80211_netdev_notifier_call+0x9e8/0x12c0 net/wireless/core.c:1335
     notifier_call_chain+0xb5/0x200 kernel/notifier.c:83
     call_netdevice_notifiers_info+0xb5/0x130 net/core/dev.c:2040
     call_netdevice_notifiers_extack net/core/dev.c:2052 [inline]
     call_netdevice_notifiers net/core/dev.c:2066 [inline]
     __dev_close_many+0xee/0x2e0 net/core/dev.c:1586
     __dev_close net/core/dev.c:1624 [inline]
     __dev_change_flags+0x2cb/0x730 net/core/dev.c:8476
     dev_change_flags+0x8a/0x160 net/core/dev.c:8549
     dev_ifsioc+0x210/0xa70 net/core/dev_ioctl.c:265
     dev_ioctl+0x1b1/0xc40 net/core/dev_ioctl.c:511
     sock_do_ioctl+0x148/0x2d0 net/socket.c:1060
     sock_ioctl+0x477/0x6a0 net/socket.c:1177
     vfs_ioctl fs/ioctl.c:48 [inline]
     __do_sys_ioctl fs/ioctl.c:753 [inline]
     __se_sys_ioctl fs/ioctl.c:739 [inline]
     __x64_sys_ioctl+0x193/0x200 fs/ioctl.c:739
     do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46
     entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    Reported-by: syzbot+93976391bf299d425f44@syzkaller.appspotmail.com
    Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
    Link: https://lore.kernel.org/r/20210213133653.367130-1-markus.theil@tu-ilmenau.de
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ab29b020bc29aecaa05e29063cddea83df393023
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Mar 12 08:59:48 2021 -0800

    net: qrtr: fix a kernel-infoleak in qrtr_recvmsg()
    
    commit 50535249f624d0072cd885bcdce4e4b6fb770160 upstream.
    
    struct sockaddr_qrtr has a 2-byte hole, and qrtr_recvmsg() currently
    does not clear it before copying kernel data to user space.
    
    It might be too late to name the hole since sockaddr_qrtr structure is uapi.
    
    BUG: KMSAN: kernel-infoleak in kmsan_copy_to_user+0x9c/0xb0 mm/kmsan/kmsan_hooks.c:249
    CPU: 0 PID: 29705 Comm: syz-executor.3 Not tainted 5.11.0-rc7-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:79 [inline]
     dump_stack+0x21c/0x280 lib/dump_stack.c:120
     kmsan_report+0xfb/0x1e0 mm/kmsan/kmsan_report.c:118
     kmsan_internal_check_memory+0x202/0x520 mm/kmsan/kmsan.c:402
     kmsan_copy_to_user+0x9c/0xb0 mm/kmsan/kmsan_hooks.c:249
     instrument_copy_to_user include/linux/instrumented.h:121 [inline]
     _copy_to_user+0x1ac/0x270 lib/usercopy.c:33
     copy_to_user include/linux/uaccess.h:209 [inline]
     move_addr_to_user+0x3a2/0x640 net/socket.c:237
     ____sys_recvmsg+0x696/0xd50 net/socket.c:2575
     ___sys_recvmsg net/socket.c:2610 [inline]
     do_recvmmsg+0xa97/0x22d0 net/socket.c:2710
     __sys_recvmmsg net/socket.c:2789 [inline]
     __do_sys_recvmmsg net/socket.c:2812 [inline]
     __se_sys_recvmmsg+0x24a/0x410 net/socket.c:2805
     __x64_sys_recvmmsg+0x62/0x80 net/socket.c:2805
     do_syscall_64+0x9f/0x140 arch/x86/entry/common.c:48
     entry_SYSCALL_64_after_hwframe+0x44/0xa9
    RIP: 0033:0x465f69
    Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
    RSP: 002b:00007f43659d6188 EFLAGS: 00000246 ORIG_RAX: 000000000000012b
    RAX: ffffffffffffffda RBX: 000000000056bf60 RCX: 0000000000465f69
    RDX: 0000000000000008 RSI: 0000000020003e40 RDI: 0000000000000003
    RBP: 00000000004bfa8f R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000010060 R11: 0000000000000246 R12: 000000000056bf60
    R13: 0000000000a9fb1f R14: 00007f43659d6300 R15: 0000000000022000
    
    Local variable ----addr@____sys_recvmsg created at:
     ____sys_recvmsg+0x168/0xd50 net/socket.c:2550
     ____sys_recvmsg+0x168/0xd50 net/socket.c:2550
    
    Bytes 2-3 of 12 are uninitialized
    Memory access of size 12 starts at ffff88817c627b40
    Data copied to user address 0000000020000140
    
    Fixes: bdabad3e363d ("net: Add Qualcomm IPC router")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Courtney Cavin <courtney.cavin@sonymobile.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f4191e89438b4a854657cbf82e1e1f4d1c07091a
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Mar 10 08:26:41 2021 -0800

    net: sched: validate stab values
    
    commit e323d865b36134e8c5c82c834df89109a5c60dab upstream.
    
    iproute2 package is well behaved, but malicious user space can
    provide illegal shift values and trigger UBSAN reports.
    
    Add stab parameter to red_check_params() to validate user input.
    
    syzbot reported:
    
    UBSAN: shift-out-of-bounds in ./include/net/red.h:312:18
    shift exponent 111 is too large for 64-bit type 'long unsigned int'
    CPU: 1 PID: 14662 Comm: syz-executor.3 Not tainted 5.12.0-rc2-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:79 [inline]
     dump_stack+0x141/0x1d7 lib/dump_stack.c:120
     ubsan_epilogue+0xb/0x5a lib/ubsan.c:148
     __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:327
     red_calc_qavg_from_idle_time include/net/red.h:312 [inline]
     red_calc_qavg include/net/red.h:353 [inline]
     choke_enqueue.cold+0x18/0x3dd net/sched/sch_choke.c:221
     __dev_xmit_skb net/core/dev.c:3837 [inline]
     __dev_queue_xmit+0x1943/0x2e00 net/core/dev.c:4150
     neigh_hh_output include/net/neighbour.h:499 [inline]
     neigh_output include/net/neighbour.h:508 [inline]
     ip6_finish_output2+0x911/0x1700 net/ipv6/ip6_output.c:117
     __ip6_finish_output net/ipv6/ip6_output.c:182 [inline]
     __ip6_finish_output+0x4c1/0xe10 net/ipv6/ip6_output.c:161
     ip6_finish_output+0x35/0x200 net/ipv6/ip6_output.c:192
     NF_HOOK_COND include/linux/netfilter.h:290 [inline]
     ip6_output+0x1e4/0x530 net/ipv6/ip6_output.c:215
     dst_output include/net/dst.h:448 [inline]
     NF_HOOK include/linux/netfilter.h:301 [inline]
     NF_HOOK include/linux/netfilter.h:295 [inline]
     ip6_xmit+0x127e/0x1eb0 net/ipv6/ip6_output.c:320
     inet6_csk_xmit+0x358/0x630 net/ipv6/inet6_connection_sock.c:135
     dccp_transmit_skb+0x973/0x12c0 net/dccp/output.c:138
     dccp_send_reset+0x21b/0x2b0 net/dccp/output.c:535
     dccp_finish_passive_close net/dccp/proto.c:123 [inline]
     dccp_finish_passive_close+0xed/0x140 net/dccp/proto.c:118
     dccp_terminate_connection net/dccp/proto.c:958 [inline]
     dccp_close+0xb3c/0xe60 net/dccp/proto.c:1028
     inet_release+0x12e/0x280 net/ipv4/af_inet.c:431
     inet6_release+0x4c/0x70 net/ipv6/af_inet6.c:478
     __sock_release+0xcd/0x280 net/socket.c:599
     sock_close+0x18/0x20 net/socket.c:1258
     __fput+0x288/0x920 fs/file_table.c:280
     task_work_run+0xdd/0x1a0 kernel/task_work.c:140
     tracehook_notify_resume include/linux/tracehook.h:189 [inline]
    
    Fixes: 8afa10cbe281 ("net_sched: red: Avoid illegal values")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3ec3f89169256dd6bdfa90a0d9221245fdde9a22
Author: Martin Willi <martin@strongswan.org>
Date:   Tue Mar 2 13:24:23 2021 +0100

    can: dev: Move device back to init netns on owning netns delete
    
    commit 3a5ca857079ea022e0b1b17fc154f7ad7dbc150f upstream.
    
    When a non-initial netns is destroyed, the usual policy is to delete
    all virtual network interfaces contained, but move physical interfaces
    back to the initial netns. This keeps the physical interface visible
    on the system.
    
    CAN devices are somewhat special, as they define rtnl_link_ops even
    if they are physical devices. If a CAN interface is moved into a
    non-initial netns, destroying that netns lets the interface vanish
    instead of moving it back to the initial netns. default_device_exit()
    skips CAN interfaces due to having rtnl_link_ops set. Reproducer:
    
      ip netns add foo
      ip link set can0 netns foo
      ip netns delete foo
    
    WARNING: CPU: 1 PID: 84 at net/core/dev.c:11030 ops_exit_list+0x38/0x60
    CPU: 1 PID: 84 Comm: kworker/u4:2 Not tainted 5.10.19 #1
    Workqueue: netns cleanup_net
    [<c010e700>] (unwind_backtrace) from [<c010a1d8>] (show_stack+0x10/0x14)
    [<c010a1d8>] (show_stack) from [<c086dc10>] (dump_stack+0x94/0xa8)
    [<c086dc10>] (dump_stack) from [<c086b938>] (__warn+0xb8/0x114)
    [<c086b938>] (__warn) from [<c086ba10>] (warn_slowpath_fmt+0x7c/0xac)
    [<c086ba10>] (warn_slowpath_fmt) from [<c0629f20>] (ops_exit_list+0x38/0x60)
    [<c0629f20>] (ops_exit_list) from [<c062a5c4>] (cleanup_net+0x230/0x380)
    [<c062a5c4>] (cleanup_net) from [<c0142c20>] (process_one_work+0x1d8/0x438)
    [<c0142c20>] (process_one_work) from [<c0142ee4>] (worker_thread+0x64/0x5a8)
    [<c0142ee4>] (worker_thread) from [<c0148a98>] (kthread+0x148/0x14c)
    [<c0148a98>] (kthread) from [<c0100148>] (ret_from_fork+0x14/0x2c)
    
    To properly restore physical CAN devices to the initial netns on owning
    netns exit, introduce a flag on rtnl_link_ops that can be set by drivers.
    For CAN devices setting this flag, default_device_exit() considers them
    non-virtual, applying the usual namespace move.
    
    The issue was introduced in the commit mentioned below, as at that time
    CAN devices did not have a dellink() operation.
    
    Fixes: e008b5fc8dc7 ("net: Simplfy default_device_exit and improve batching.")
    Link: https://lore.kernel.org/r/20210302122423.872326-1-martin@strongswan.org
    Signed-off-by: Martin Willi <martin@strongswan.org>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 385527119136a8811f1b79f58eab585c0692023b
Author: Mike Galbraith <efault@gmx.de>
Date:   Sun Mar 28 22:43:15 2021 +0200

    futex: Handle transient "ownerless" rtmutex state correctly
    
    commit 9f5d1c336a10c0d24e83e40b4c1b9539f7dba627 upstream.
    
    Gratian managed to trigger the BUG_ON(!newowner) in fixup_pi_state_owner().
    This is one possible chain of events leading to this:
    
    Task Prio       Operation
    T1   120        lock(F)
    T2   120        lock(F)   -> blocks (top waiter)
    T3   50 (RT)    lock(F)   -> boosts T1 and blocks (new top waiter)
    XX              timeout/  -> wakes T2
                    signal
    T1   50         unlock(F) -> wakes T3 (rtmutex->owner == NULL, waiter bit is set)
    T2   120        cleanup   -> try_to_take_mutex() fails because T3 is the top waiter
                                 and the lower priority T2 cannot steal the lock.
                              -> fixup_pi_state_owner() sees newowner == NULL -> BUG_ON()
    
    The comment states that this is invalid and rt_mutex_real_owner() must
    return a non NULL owner when the trylock failed, but in case of a queued
    and woken up waiter rt_mutex_real_owner() == NULL is a valid transient
    state. The higher priority waiter has simply not yet managed to take over
    the rtmutex.
    
    The BUG_ON() is therefore wrong and this is just another retry condition in
    fixup_pi_state_owner().
    
    Drop the locks, so that T3 can make progress, and then try the fixup again.
    
    Gratian provided a great analysis, traces and a reproducer. The analysis is
    to the point, but it confused the hell out of that tglx dude who had to
    page in all the futex horrors again. Condensed version is above.
    
    [ tglx: Wrote comment and changelog ]
    
    Fixes: c1e2f0eaf015 ("futex: Avoid violating the 10th rule of futex")
    Reported-by: Gratian Crisan <gratian.crisan@ni.com>
    Signed-off-by: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/87a6w6x7bb.fsf@ni.com
    Link: https://lore.kernel.org/r/87sg9pkvf7.fsf@nanos.tec.linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cec1580fb04c83c2d4300843469be2107ca21d04
Author: Mateusz Nosek <mateusznosek0@gmail.com>
Date:   Sun Mar 28 22:43:10 2021 +0200

    futex: Fix incorrect should_fail_futex() handling
    
    commit 921c7ebd1337d1a46783d7e15a850e12aed2eaa0 upstream.
    
    If should_futex_fail() returns true in futex_wake_pi(), then the 'ret'
    variable is set to -EFAULT and then immediately overwritten. So the failure
    injection is non-functional.
    
    Fix it by actually leaving the function and returning -EFAULT.
    
    The Fixes tag is kinda blury because the initial commit which introduced
    failure injection was already sloppy, but the below mentioned commit broke
    it completely.
    
    [ tglx: Massaged changelog ]
    
    Fixes: 6b4f4bc9cb22 ("locking/futex: Allow low-level atomic operations to return -EAGAIN")
    Signed-off-by: Mateusz Nosek <mateusznosek0@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200927000858.24219-1-mateusznosek0@gmail.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b90aa237f469c3575190a5e6a855b76ad1d2ce94
Author: Yang Tao <yang.tao172@zte.com.cn>
Date:   Sun Mar 28 22:42:58 2021 +0200

    futex: Prevent robust futex exit race
    
    commit ca16d5bee59807bf04deaab0a8eccecd5061528c upstream.
    
    Robust futexes utilize the robust_list mechanism to allow the kernel to
    release futexes which are held when a task exits. The exit can be voluntary
    or caused by a signal or fault. This prevents that waiters block forever.
    
    The futex operations in user space store a pointer to the futex they are
    either locking or unlocking in the op_pending member of the per task robust
    list.
    
    After a lock operation has succeeded the futex is queued in the robust list
    linked list and the op_pending pointer is cleared.
    
    After an unlock operation has succeeded the futex is removed from the
    robust list linked list and the op_pending pointer is cleared.
    
    The robust list exit code checks for the pending operation and any futex
    which is queued in the linked list. It carefully checks whether the futex
    value is the TID of the exiting task. If so, it sets the OWNER_DIED bit and
    tries to wake up a potential waiter.
    
    This is race free for the lock operation but unlock has two race scenarios
    where waiters might not be woken up. These issues can be observed with
    regular robust pthread mutexes. PI aware pthread mutexes are not affected.
    
    (1) Unlocking task is killed after unlocking the futex value in user space
        before being able to wake a waiter.
    
            pthread_mutex_unlock()
                    |
                    V
            atomic_exchange_rel (&mutex->__data.__lock, 0)
                            <------------------------killed
                lll_futex_wake ()                   |
                                                    |
                                                    |(__lock = 0)
                                                    |(enter kernel)
                                                    |
                                                    V
                                                do_exit()
                                                exit_mm()
                                              mm_release()
                                            exit_robust_list()
                                            handle_futex_death()
                                                    |
                                                    |(__lock = 0)
                                                    |(uval = 0)
                                                    |
                                                    V
            if ((uval & FUTEX_TID_MASK) != task_pid_vnr(curr))
                    return 0;
    
        The sanity check which ensures that the user space futex is owned by
        the exiting task prevents the wakeup of waiters which in consequence
        block infinitely.
    
    (2) Waiting task is killed after a wakeup and before it can acquire the
        futex in user space.
    
            OWNER                         WAITER
                                    futex_wait()
       pthread_mutex_unlock()               |
                    |                       |
                    |(__lock = 0)           |
                    |                       |
                    V                       |
             futex_wake() ------------>  wakeup()
                                            |
                                            |(return to userspace)
                                            |(__lock = 0)
                                            |
                                            V
                            oldval = mutex->__data.__lock
                                              <-----------------killed
        atomic_compare_and_exchange_val_acq (&mutex->__data.__lock,  |
                            id | assume_other_futex_waiters, 0)      |
                                                                     |
                                                                     |
                                                       (enter kernel)|
                                                                     |
                                                                     V
                                                             do_exit()
                                                            |
                                                            |
                                                            V
                                            handle_futex_death()
                                            |
                                            |(__lock = 0)
                                            |(uval = 0)
                                            |
                                            V
            if ((uval & FUTEX_TID_MASK) != task_pid_vnr(curr))
                    return 0;
    
        The sanity check which ensures that the user space futex is owned
        by the exiting task prevents the wakeup of waiters, which seems to
        be correct as the exiting task does not own the futex value, but
        the consequence is that other waiters wont be woken up and block
        infinitely.
    
    In both scenarios the following conditions are true:
    
       - task->robust_list->list_op_pending != NULL
       - user space futex value == 0
       - Regular futex (not PI)
    
    If these conditions are met then it is reasonably safe to wake up a
    potential waiter in order to prevent the above problems.
    
    As this might be a false positive it can cause spurious wakeups, but the
    waiter side has to handle other types of unrelated wakeups, e.g. signals
    gracefully anyway. So such a spurious wakeup will not affect the
    correctness of these operations.
    
    This workaround must not touch the user space futex value and cannot set
    the OWNER_DIED bit because the lock value is 0, i.e. uncontended. Setting
    OWNER_DIED in this case would result in inconsistent state and subsequently
    in malfunction of the owner died handling in user space.
    
    The rest of the user space state is still consistent as no other task can
    observe the list_op_pending entry in the exiting tasks robust list.
    
    The eventually woken up waiter will observe the uncontended lock value and
    take it over.
    
    [ tglx: Massaged changelog and comment. Made the return explicit and not
            depend on the subsequent check and added constants to hand into
            handle_futex_death() instead of plain numbers. Fixed a few coding
            style issues. ]
    
    Fixes: 0771dfefc9e5 ("[PATCH] lightweight robust futexes: core")
    Signed-off-by: Yang Tao <yang.tao172@zte.com.cn>
    Signed-off-by: Yi Wang <wang.yi59@zte.com.cn>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1573010582-35297-1-git-send-email-wang.yi59@zte.com.cn
    Link: https://lkml.kernel.org/r/20191106224555.943191378@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bd3ec28fb6d985ee377efe018e2ff8cf7dfce902
Author: Will Deacon <will@kernel.org>
Date:   Sun Mar 28 22:42:51 2021 +0200

    arm64: futex: Bound number of LDXR/STXR loops in FUTEX_WAKE_OP
    
    commit 03110a5cb2161690ae5ac04994d47ed0cd6cef75 upstream.
    
    Our futex implementation makes use of LDXR/STXR loops to perform atomic
    updates to user memory from atomic context. This can lead to latency
    problems if we end up spinning around the LL/SC sequence at the expense
    of doing something useful.
    
    Rework our futex atomic operations so that we return -EAGAIN if we fail
    to update the futex word after 128 attempts. The core futex code will
    reschedule if necessary and we'll try again later.
    
    Fixes: 6170a97460db ("arm64: Atomic operations")
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    [bwh: Backported to 4.9: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8682c2e2cc82b3ee5938a5384ddc04baab4c0fff
Author: Will Deacon <will@kernel.org>
Date:   Sun Mar 28 22:42:44 2021 +0200

    locking/futex: Allow low-level atomic operations to return -EAGAIN
    
    commit 6b4f4bc9cb22875f97023984a625386f0c7cc1c0 upstream.
    
    Some futex() operations, including FUTEX_WAKE_OP, require the kernel to
    perform an atomic read-modify-write of the futex word via the userspace
    mapping. These operations are implemented by each architecture in
    arch_futex_atomic_op_inuser() and futex_atomic_cmpxchg_inatomic(), which
    are called in atomic context with the relevant hash bucket locks held.
    
    Although these routines may return -EFAULT in response to a page fault
    generated when accessing userspace, they are expected to succeed (i.e.
    return 0) in all other cases. This poses a problem for architectures
    that do not provide bounded forward progress guarantees or fairness of
    contended atomic operations and can lead to starvation in some cases.
    
    In these problematic scenarios, we must return back to the core futex
    code so that we can drop the hash bucket locks and reschedule if
    necessary, much like we do in the case of a page fault.
    
    Allow architectures to return -EAGAIN from their implementations of
    arch_futex_atomic_op_inuser() and futex_atomic_cmpxchg_inatomic(), which
    will cause the core futex code to reschedule if necessary and return
    back to the architecture code later on.
    
    Cc: <stable@kernel.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    [bwh: Backported to 4.9: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5083fb83381fd011fe4a8e84b7089fcde8cfcb25
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sun Mar 28 22:42:32 2021 +0200

    futex: Fix (possible) missed wakeup
    
    commit b061c38bef43406df8e73c5be06cbfacad5ee6ad upstream.
    
    We must not rely on wake_q_add() to delay the wakeup; in particular
    commit:
    
      1d0dcb3ad9d3 ("futex: Implement lockless wakeups")
    
    moved wake_q_add() before smp_store_release(&q->lock_ptr, NULL), which
    could result in futex_wait() waking before observing ->lock_ptr ==
    NULL and going back to sleep again.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 1d0dcb3ad9d3 ("futex: Implement lockless wakeups")
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b4f92d8dec9ba55c6d68cd190f139c682e9700ae
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Mar 28 22:42:20 2021 +0200

    futex: Handle early deadlock return correctly
    
    commit 1a1fb985f2e2b85ec0d3dc2e519ee48389ec2434 upstream.
    
    commit 56222b212e8e ("futex: Drop hb->lock before enqueueing on the
    rtmutex") changed the locking rules in the futex code so that the hash
    bucket lock is not longer held while the waiter is enqueued into the
    rtmutex wait list. This made the lock and the unlock path symmetric, but
    unfortunately the possible early exit from __rt_mutex_proxy_start() due to
    a detected deadlock was not updated accordingly. That allows a concurrent
    unlocker to observe inconsitent state which triggers the warning in the
    unlock path.
    
    futex_lock_pi()                         futex_unlock_pi()
      lock(hb->lock)
      queue(hb_waiter)                              lock(hb->lock)
      lock(rtmutex->wait_lock)
      unlock(hb->lock)
                                            // acquired hb->lock
                                            hb_waiter = futex_top_waiter()
                                            lock(rtmutex->wait_lock)
      __rt_mutex_proxy_start()
         ---> fail
              remove(rtmutex_waiter);
         ---> returns -EDEADLOCK
      unlock(rtmutex->wait_lock)
                                            // acquired wait_lock
                                            wake_futex_pi()
                                            rt_mutex_next_owner()
                                              --> returns NULL
                                              --> WARN
    
      lock(hb->lock)
      unqueue(hb_waiter)
    
    The problem is caused by the remove(rtmutex_waiter) in the failure case of
    __rt_mutex_proxy_start() as this lets the unlocker observe a waiter in the
    hash bucket but no waiter on the rtmutex, i.e. inconsistent state.
    
    The original commit handles this correctly for the other early return cases
    (timeout, signal) by delaying the removal of the rtmutex waiter until the
    returning task reacquired the hash bucket lock.
    
    Treat the failure case of __rt_mutex_proxy_start() in the same way and let
    the existing cleanup code handle the eventual handover of the rtmutex
    gracefully. The regular rt_mutex_proxy_start() gains the rtmutex waiter
    removal for the failure case, so that the other callsites are still
    operating correctly.
    
    Add proper comments to the code so all these details are fully documented.
    
    Thanks to Peter for helping with the analysis and writing the really
    valuable code comments.
    
    Fixes: 56222b212e8e ("futex: Drop hb->lock before enqueueing on the rtmutex")
    Reported-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Co-developed-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: linux-s390@vger.kernel.org
    Cc: Stefan Liebler <stli@linux.ibm.com>
    Cc: Sebastian Sewior <bigeasy@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1901292311410.1950@nanos.tec.linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 99f4e930a7713b8a4da061b79b1ef8caf79b6d3d
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sun Mar 28 22:42:08 2021 +0200

    futex,rt_mutex: Fix rt_mutex_cleanup_proxy_lock()
    
    commit 04dc1b2fff4e96cb4142227fbdc63c8871ad4ed9 upstream.
    
    Markus reported that the glibc/nptl/tst-robustpi8 test was failing after
    commit:
    
      cfafcd117da0 ("futex: Rework futex_lock_pi() to use rt_mutex_*_proxy_lock()")
    
    The following trace shows the problem:
    
     ld-linux-x86-64-2161  [019] ....   410.760971: SyS_futex: 00007ffbeb76b028: 80000875  op=FUTEX_LOCK_PI
     ld-linux-x86-64-2161  [019] ...1   410.760972: lock_pi_update_atomic: 00007ffbeb76b028: curval=80000875 uval=80000875 newval=80000875 ret=0
     ld-linux-x86-64-2165  [011] ....   410.760978: SyS_futex: 00007ffbeb76b028: 80000875  op=FUTEX_UNLOCK_PI
     ld-linux-x86-64-2165  [011] d..1   410.760979: do_futex: 00007ffbeb76b028: curval=80000875 uval=80000875 newval=80000871 ret=0
     ld-linux-x86-64-2165  [011] ....   410.760980: SyS_futex: 00007ffbeb76b028: 80000871 ret=0000
     ld-linux-x86-64-2161  [019] ....   410.760980: SyS_futex: 00007ffbeb76b028: 80000871 ret=ETIMEDOUT
    
    Task 2165 does an UNLOCK_PI, assigning the lock to the waiter task 2161
    which then returns with -ETIMEDOUT. That wrecks the lock state, because now
    the owner isn't aware it acquired the lock and removes the pending robust
    list entry.
    
    If 2161 is killed, the robust list will not clear out this futex and the
    subsequent acquire on this futex will then (correctly) result in -ESRCH
    which is unexpected by glibc, triggers an internal assertion and dies.
    
    Task 2161                       Task 2165
    
    rt_mutex_wait_proxy_lock()
       timeout();
       /* T2161 is still queued in  the waiter list */
       return -ETIMEDOUT;
    
                                    futex_unlock_pi()
                                    spin_lock(hb->lock);
                                    rtmutex_unlock()
                                      remove_rtmutex_waiter(T2161);
                                       mark_lock_available();
                                    /* Make the next waiter owner of the user space side */
                                    futex_uval = 2161;
                                    spin_unlock(hb->lock);
    spin_lock(hb->lock);
    rt_mutex_cleanup_proxy_lock()
      if (rtmutex_owner() !== current)
         ...
         return FAIL;
    ....
    return -ETIMEOUT;
    
    This means that rt_mutex_cleanup_proxy_lock() needs to call
    try_to_take_rt_mutex() so it can take over the rtmutex correctly which was
    assigned by the waker. If the rtmutex is owned by some other task then this
    call is harmless and just confirmes that the waiter is not able to acquire
    it.
    
    While there, fix what looks like a merge error which resulted in
    rt_mutex_cleanup_proxy_lock() having two calls to
    fixup_rt_mutex_waiters() and rt_mutex_wait_proxy_lock() not having any.
    Both should have one, since both potentially touch the waiter list.
    
    Fixes: 38d589f2fd08 ("futex,rt_mutex: Restructure rt_mutex_finish_proxy_lock()")
    Reported-by: Markus Trippelsdorf <markus@trippelsdorf.de>
    Bug-Spotted-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Florian Weimer <fweimer@redhat.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Markus Trippelsdorf <markus@trippelsdorf.de>
    Link: http://lkml.kernel.org/r/20170519154850.mlomgdsd26drq5j6@hirez.programming.kicks-ass.net
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 85de471416ae48bfc8d0eee1248f59c918f7793d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Mar 28 22:42:00 2021 +0200

    futex: Avoid freeing an active timer
    
    commit 97181f9bd57405b879403763284537e27d46963d upstream.
    
    Alexander reported a hrtimer debug_object splat:
    
      ODEBUG: free active (active state 0) object type: hrtimer hint: hrtimer_wakeup (kernel/time/hrtimer.c:1423)
    
      debug_object_free (lib/debugobjects.c:603)
      destroy_hrtimer_on_stack (kernel/time/hrtimer.c:427)
      futex_lock_pi (kernel/futex.c:2740)
      do_futex (kernel/futex.c:3399)
      SyS_futex (kernel/futex.c:3447 kernel/futex.c:3415)
      do_syscall_64 (arch/x86/entry/common.c:284)
      entry_SYSCALL64_slow_path (arch/x86/entry/entry_64.S:249)
    
    Which was caused by commit:
    
      cfafcd117da0 ("futex: Rework futex_lock_pi() to use rt_mutex_*_proxy_lock()")
    
    ... losing the hrtimer_cancel() in the shuffle. Where previously the
    hrtimer_cancel() was done by rt_mutex_slowlock() we now need to do it
    manually.
    
    Reported-by: Alexander Levin <alexander.levin@verizon.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Fixes: cfafcd117da0 ("futex: Rework futex_lock_pi() to use rt_mutex_*_proxy_lock()")
    Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1704101802370.2906@nanos
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fc9f98f6e52176bea787e8e4213dd54441fbf677
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sun Mar 28 22:41:51 2021 +0200

    futex: Drop hb->lock before enqueueing on the rtmutex
    
    commit 56222b212e8edb1cf51f5dd73ff645809b082b40 upstream.
    
    When PREEMPT_RT_FULL does the spinlock -> rt_mutex substitution the PI
    chain code will (falsely) report a deadlock and BUG.
    
    The problem is that it hold hb->lock (now an rt_mutex) while doing
    task_blocks_on_rt_mutex on the futex's pi_state::rtmutex. This, when
    interleaved just right with futex_unlock_pi() leads it to believe to see an
    AB-BA deadlock.
    
      Task1 (holds rt_mutex,        Task2 (does FUTEX_LOCK_PI)
             does FUTEX_UNLOCK_PI)
    
                                    lock hb->lock
                                    lock rt_mutex (as per start_proxy)
      lock hb->lock
    
    Which is a trivial AB-BA.
    
    It is not an actual deadlock, because it won't be holding hb->lock by the
    time it actually blocks on the rt_mutex, but the chainwalk code doesn't
    know that and it would be a nightmare to handle this gracefully.
    
    To avoid this problem, do the same as in futex_unlock_pi() and drop
    hb->lock after acquiring wait_lock. This still fully serializes against
    futex_unlock_pi(), since adding to the wait_list does the very same lock
    dance, and removing it holds both locks.
    
    Aside of solving the RT problem this makes the lock and unlock mechanism
    symetric and reduces the hb->lock held time.
    
    Reported-and-tested-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: juri.lelli@arm.com
    Cc: xlpang@redhat.com
    Cc: rostedt@goodmis.org
    Cc: mathieu.desnoyers@efficios.com
    Cc: jdesfossez@efficios.com
    Cc: dvhart@infradead.org
    Cc: bristot@redhat.com
    Link: http://lkml.kernel.org/r/20170322104152.161341537@infradead.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 13c98b088c655ebc294aebcc1a11eacf496c4e6e
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sun Mar 28 22:41:42 2021 +0200

    futex: Rework futex_lock_pi() to use rt_mutex_*_proxy_lock()
    
    commit cfafcd117da0216520568c195cb2f6cd1980c4bb upstream.
    
    By changing futex_lock_pi() to use rt_mutex_*_proxy_lock() all wait_list
    modifications are done under both hb->lock and wait_lock.
    
    This closes the obvious interleave pattern between futex_lock_pi() and
    futex_unlock_pi(), but not entirely so. See below:
    
    Before:
    
    futex_lock_pi()                 futex_unlock_pi()
      unlock hb->lock
    
                                      lock hb->lock
                                      unlock hb->lock
    
                                      lock rt_mutex->wait_lock
                                      unlock rt_mutex_wait_lock
                                        -EAGAIN
    
      lock rt_mutex->wait_lock
      list_add
      unlock rt_mutex->wait_lock
    
      schedule()
    
      lock rt_mutex->wait_lock
      list_del
      unlock rt_mutex->wait_lock
    
                                      <idem>
                                        -EAGAIN
    
      lock hb->lock
    
    After:
    
    futex_lock_pi()                 futex_unlock_pi()
    
      lock hb->lock
      lock rt_mutex->wait_lock
      list_add
      unlock rt_mutex->wait_lock
      unlock hb->lock
    
      schedule()
                                      lock hb->lock
                                      unlock hb->lock
      lock hb->lock
      lock rt_mutex->wait_lock
      list_del
      unlock rt_mutex->wait_lock
    
                                      lock rt_mutex->wait_lock
                                      unlock rt_mutex_wait_lock
                                        -EAGAIN
    
      unlock hb->lock
    
    It does however solve the earlier starvation/live-lock scenario which got
    introduced with the -EAGAIN since unlike the before scenario; where the
    -EAGAIN happens while futex_unlock_pi() doesn't hold any locks; in the
    after scenario it happens while futex_unlock_pi() actually holds a lock,
    and then it is serialized on that lock.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: juri.lelli@arm.com
    Cc: bigeasy@linutronix.de
    Cc: xlpang@redhat.com
    Cc: rostedt@goodmis.org
    Cc: mathieu.desnoyers@efficios.com
    Cc: jdesfossez@efficios.com
    Cc: dvhart@infradead.org
    Cc: bristot@redhat.com
    Link: http://lkml.kernel.org/r/20170322104152.062785528@infradead.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [bwh: Backported to 4.9: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 55404ebc9744489c71e190090cccc3f4ad51f88b
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sun Mar 28 22:41:33 2021 +0200

    futex,rt_mutex: Introduce rt_mutex_init_waiter()
    
    commit 50809358dd7199aa7ce232f6877dd09ec30ef374 upstream.
    
    Since there's already two copies of this code, introduce a helper now
    before adding a third one.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: juri.lelli@arm.com
    Cc: bigeasy@linutronix.de
    Cc: xlpang@redhat.com
    Cc: rostedt@goodmis.org
    Cc: mathieu.desnoyers@efficios.com
    Cc: jdesfossez@efficios.com
    Cc: dvhart@infradead.org
    Cc: bristot@redhat.com
    Link: http://lkml.kernel.org/r/20170322104151.950039479@infradead.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [bwh: Backported to 4.9: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 77d6a4cf9f7a38eaadf6dc5fe9566efc0d6142f2
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sun Mar 28 22:40:54 2021 +0200

    futex: Use smp_store_release() in mark_wake_futex()
    
    commit 1b367ece0d7e696cab1c8501bab282cc6a538b3f upstream.
    
    Since the futex_q can dissapear the instruction after assigning NULL,
    this really should be a RELEASE barrier. That stops loads from hitting
    dead memory too.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: juri.lelli@arm.com
    Cc: bigeasy@linutronix.de
    Cc: xlpang@redhat.com
    Cc: rostedt@goodmis.org
    Cc: mathieu.desnoyers@efficios.com
    Cc: jdesfossez@efficios.com
    Cc: dvhart@infradead.org
    Cc: bristot@redhat.com
    Link: http://lkml.kernel.org/r/20170322104151.604296452@infradead.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b71c271c6234161c0b8c43253a9d14c33adcf891
Author: Matthew Wilcox <willy@infradead.org>
Date:   Wed Dec 14 15:09:13 2016 -0800

    idr: add ida_is_empty
    
    [ Upstream commit 99c494077e2d4282a17120a772eecc00ec3004cc ]
    
    Two of the USB Gadgets were poking around in the internals of struct ida
    in order to determine if it is empty.  Add the appropriate abstraction.
    
    Link: http://lkml.kernel.org/r/1480369871-5271-63-git-send-email-mawilcox@linuxonhyperv.com
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Acked-by: Konstantin Khlebnikov <koct9i@gmail.com>
    Tested-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Felipe Balbi <balbi@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Michal Nazarewicz <mina86@mina86.com>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 95cae1b5702f3092cae4cf06b913ce9d4c80d47b
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Mar 8 17:11:43 2021 +0200

    perf auxtrace: Fix auxtrace queue conflict
    
    [ Upstream commit b410ed2a8572d41c68bd9208555610e4b07d0703 ]
    
    The only requirement of an auxtrace queue is that the buffers are in
    time order.  That is achieved by making separate queues for separate
    perf buffer or AUX area buffer mmaps.
    
    That generally means a separate queue per cpu for per-cpu contexts, and
    a separate queue per thread for per-task contexts.
    
    When buffers are added to a queue, perf checks that the buffer cpu and
    thread id (tid) match the queue cpu and thread id.
    
    However, generally, that need not be true, and perf will queue buffers
    correctly anyway, so the check is not needed.
    
    In addition, the check gets erroneously hit when using sample mode to
    trace multiple threads.
    
    Consequently, fix that case by removing the check.
    
    Fixes: e502789302a6 ("perf auxtrace: Add helpers for queuing AUX area tracing data")
    Reported-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Link: http://lore.kernel.org/lkml/20210308151143.18338-1-adrian.hunter@intel.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e5cdbe419004e172f642e876a671a9ff1c52f8bb
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 22 18:31:00 2021 +0200

    ACPI: scan: Use unique number for instance_no
    
    [ Upstream commit eb50aaf960e3bedfef79063411ffd670da94b84b ]
    
    The decrementation of acpi_device_bus_id->instance_no
    in acpi_device_del() is incorrect, because it may cause
    a duplicate instance number to be allocated next time
    a device with the same acpi_device_bus_id is added.
    
    Replace above mentioned approach by using IDA framework.
    
    While at it, define the instance range to be [0, 4096).
    
    Fixes: e49bd2dd5a50 ("ACPI: use PNPID:instance_no as bus_id of ACPI device")
    Fixes: ca9dc8d42b30 ("ACPI / scan: Fix acpi_bus_id_list bookkeeping")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b38568fe7554587ffde14d4a6ed69eacb63a900e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 14 19:46:47 2021 +0100

    ACPI: scan: Rearrange memory allocation in acpi_device_add()
    
    [ Upstream commit c1013ff7a5472db637c56bb6237f8343398c03a7 ]
    
    The upfront allocation of new_bus_id is done to avoid allocating
    memory under acpi_device_lock, but it doesn't really help,
    because (1) it leads to many unnecessary memory allocations for
    _ADR devices, (2) kstrdup_const() is run under that lock anyway and
    (3) it complicates the code.
    
    Rearrange acpi_device_add() to allocate memory for a new struct
    acpi_device_bus_id instance only when necessary, eliminate a redundant
    local variable from it and reduce the number of labels in there.
    
    No intentional functional impact.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b877545668276c89b0251ff5dfcda1864392836d
Author: Potnuri Bharat Teja <bharat@chelsio.com>
Date:   Thu Mar 25 00:34:53 2021 +0530

    RDMA/cxgb4: Fix adapter LE hash errors while destroying ipv6 listening server
    
    [ Upstream commit 3408be145a5d6418ff955fe5badde652be90e700 ]
    
    Not setting the ipv6 bit while destroying ipv6 listening servers may
    result in potential fatal adapter errors due to lookup engine memory hash
    errors. Therefore always set ipv6 field while destroying ipv6 listening
    servers.
    
    Fixes: 830662f6f032 ("RDMA/cxgb4: Add support for active and passive open connection with IPv6 address")
    Link: https://lore.kernel.org/r/20210324190453.8171-1-bharat@chelsio.com
    Signed-off-by: Potnuri Bharat Teja <bharat@chelsio.com>
    Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
    Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2000a40f7963836b4cec480a45dd123bdd0c46c9
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 18 16:57:49 2021 +0100

    net: cdc-phonet: fix data-interface release on probe failure
    
    [ Upstream commit c79a707072fe3fea0e3c92edee6ca85c1e53c29f ]
    
    Set the disconnected flag before releasing the data interface in case
    netdev registration fails to avoid having the disconnect callback try to
    deregister the never registered netdev (and trigger a WARN_ON()).
    
    Fixes: 87cf65601e17 ("USB host CDC Phonet network interface driver")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3baa636544272ca0233cb0648dc7f9752750a29a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Feb 12 11:22:14 2021 +0100

    mac80211: fix rate mask reset
    
    [ Upstream commit 1944015fe9c1d9fa5e9eb7ffbbb5ef8954d6753b ]
    
    Coverity reported the strange "if (~...)" condition that's
    always true. It suggested that ! was intended instead of ~,
    but upon further analysis I'm convinced that what really was
    intended was a comparison to 0xff/0xffff (in HT/VHT cases
    respectively), since this indicates that all of the rates
    are enabled.
    
    Change the comparison accordingly.
    
    I'm guessing this never really mattered because a reset to
    not having a rate mask is basically equivalent to having a
    mask that enables all rates.
    
    Reported-by: Colin Ian King <colin.king@canonical.com>
    Fixes: 2ffbe6d33366 ("mac80211: fix and optimize MCS mask handling")
    Fixes: b119ad6e726c ("mac80211: add rate mask logic for vht rates")
    Reviewed-by: Colin Ian King <colin.king@canonical.com>
    Link: https://lore.kernel.org/r/20210212112213.36b38078f569.I8546a20c80bc1669058eb453e213630b846e107b@changeid
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 735abed1100e41606134a144eb51cc0a1ea4b695
Author: Torin Cooper-Bennun <torin@maxiluxsystems.com>
Date:   Wed Mar 3 10:31:52 2021 +0000

    can: m_can: m_can_do_rx_poll(): fix extraneous msg loss warning
    
    [ Upstream commit c0e399f3baf42279f48991554240af8c457535d1 ]
    
    Message loss from RX FIFO 0 is already handled in
    m_can_handle_lost_msg(), with netdev output included.
    
    Removing this warning also improves driver performance under heavy
    load, where m_can_do_rx_poll() may be called many times before this
    interrupt is cleared, causing this message to be output many
    times (thanks Mariusz Madej for this report).
    
    Fixes: e0d1f4816f2a ("can: m_can: add Bosch M_CAN controller support")
    Link: https://lore.kernel.org/r/20210303103151.3760532-1-torin@maxiluxsystems.com
    Reported-by: Mariusz Madej <mariusz.madej@xtrack.com>
    Signed-off-by: Torin Cooper-Bennun <torin@maxiluxsystems.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit eb05021a79688538e5a2306288cf789ab8ac2809
Author: Tong Zhang <ztong0001@gmail.com>
Date:   Mon Mar 1 21:55:40 2021 -0500

    can: c_can: move runtime PM enable/disable to c_can_platform
    
    [ Upstream commit 6e2fe01dd6f98da6cae8b07cd5cfa67abc70d97d ]
    
    Currently doing modprobe c_can_pci will make the kernel complain:
    
        Unbalanced pm_runtime_enable!
    
    this is caused by pm_runtime_enable() called before pm is initialized.
    
    This fix is similar to 227619c3ff7c, move those pm_enable/disable code
    to c_can_platform.
    
    Fixes: 4cdd34b26826 ("can: c_can: Add runtime PM support to Bosch C_CAN/D_CAN controller")
    Link: http://lore.kernel.org/r/20210302025542.987600-1-ztong0001@gmail.com
    Signed-off-by: Tong Zhang <ztong0001@gmail.com>
    Tested-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a78e15784231aec2979b829fabc4535f28cd4e6d
Author: Tong Zhang <ztong0001@gmail.com>
Date:   Sun Feb 28 21:45:11 2021 -0500

    can: c_can_pci: c_can_pci_remove(): fix use-after-free
    
    [ Upstream commit 0429d6d89f97ebff4f17f13f5b5069c66bde8138 ]
    
    There is a UAF in c_can_pci_remove(). dev is released by
    free_c_can_dev() and is used by pci_iounmap(pdev, priv->base) later.
    To fix this issue, save the mmio address before releasing dev.
    
    Fixes: 5b92da0443c2 ("c_can_pci: generic module for C_CAN/D_CAN on PCI")
    Link: https://lore.kernel.org/r/20210301024512.539039-1-ztong0001@gmail.com
    Signed-off-by: Tong Zhang <ztong0001@gmail.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 646b4ca277d488acbd0d9474c8f21f934be483db
Author: Lv Yunlong <lyl2019@mail.ustc.edu.cn>
Date:   Wed Mar 10 20:01:40 2021 -0800

    net/qlcnic: Fix a use after free in qlcnic_83xx_get_minidump_template
    
    [ Upstream commit db74623a3850db99cb9692fda9e836a56b74198d ]
    
    In qlcnic_83xx_get_minidump_template, fw_dump->tmpl_hdr was freed by
    vfree(). But unfortunately, it is used when extended is true.
    
    Fixes: 7061b2bdd620e ("qlogic: Deletion of unnecessary checks before two function calls")
    Signed-off-by: Lv Yunlong <lyl2019@mail.ustc.edu.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit baf4fabcd5bd56e3140e4f202fd624fd27db6631
Author: Dinghao Liu <dinghao.liu@zju.edu.cn>
Date:   Sun Feb 28 17:44:23 2021 +0800

    e1000e: Fix error handling in e1000_set_d0_lplu_state_82571
    
    [ Upstream commit b52912b8293f2c496f42583e65599aee606a0c18 ]
    
    There is one e1e_wphy() call in e1000_set_d0_lplu_state_82571
    that we have caught its return value but lack further handling.
    Check and terminate the execution flow just like other e1e_wphy()
    in this function.
    
    Fixes: bc7f75fa9788 ("[E1000E]: New pci-express e1000 driver (currently for ICH9 devices only)")
    Signed-off-by: Dinghao Liu <dinghao.liu@zju.edu.cn>
    Acked-by: Sasha Neftin <sasha.neftin@intel.com>
    Tested-by: Dvora Fuxbrumer <dvorax.fuxbrumer@linux.intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e352ac6caf4d44c27604f0680f2d6ededbfd9eea
Author: Vitaly Lifshits <vitaly.lifshits@intel.com>
Date:   Wed Oct 21 14:59:37 2020 +0300

    e1000e: add rtnl_lock() to e1000_reset_task
    
    [ Upstream commit 21f857f0321d0d0ea9b1a758bd55dc63d1cb2437 ]
    
    A possible race condition was found in e1000_reset_task,
    after discovering a similar issue in igb driver via
    commit 024a8168b749 ("igb: reinit_locked() should be called
    with rtnl_lock").
    
    Added rtnl_lock() and rtnl_unlock() to avoid this.
    
    Fixes: bc7f75fa9788 ("[E1000E]: New pci-express e1000 driver (currently for ICH9 devices only)")
    Suggested-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Vitaly Lifshits <vitaly.lifshits@intel.com>
    Tested-by: Dvora Fuxbrumer <dvorax.fuxbrumer@linux.intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 51838fb6e0babe14d8c4803d1d7ed8630f7eb7d0
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Mar 10 14:17:58 2021 -0800

    net: dsa: bcm_sf2: Qualify phydev->dev_flags based on port
    
    [ Upstream commit 47142ed6c34d544ae9f0463e58d482289cbe0d46 ]
    
    Similar to commit 92696286f3bb37ba50e4bd8d1beb24afb759a799 ("net:
    bcmgenet: Set phydev->dev_flags only for internal PHYs") we need to
    qualify the phydev->dev_flags based on whether the port is connected to
    an internal or external PHY otherwise we risk having a flags collision
    with a completely different interpretation depending on the driver.
    
    Fixes: aa9aef77c761 ("net: dsa: bcm_sf2: communicate integrated PHY revision to PHY driver")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9bd8da264b7ec155cd8a4effe9a830e4d5103a26
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Mar 10 01:56:36 2021 -0800

    macvlan: macvlan_count_rx() needs to be aware of preemption
    
    [ Upstream commit dd4fa1dae9f4847cc1fd78ca468ad69e16e5db3e ]
    
    macvlan_count_rx() can be called from process context, it is thus
    necessary to disable preemption before calling u64_stats_update_begin()
    
    syzbot was able to spot this on 32bit arch:
    
    WARNING: CPU: 1 PID: 4632 at include/linux/seqlock.h:271 __seqprop_assert include/linux/seqlock.h:271 [inline]
    WARNING: CPU: 1 PID: 4632 at include/linux/seqlock.h:271 __seqprop_assert.constprop.0+0xf0/0x11c include/linux/seqlock.h:269
    Modules linked in:
    Kernel panic - not syncing: panic_on_warn set ...
    CPU: 1 PID: 4632 Comm: kworker/1:3 Not tainted 5.12.0-rc2-syzkaller #0
    Hardware name: ARM-Versatile Express
    Workqueue: events macvlan_process_broadcast
    Backtrace:
    [<82740468>] (dump_backtrace) from [<827406dc>] (show_stack+0x18/0x1c arch/arm/kernel/traps.c:252)
     r7:00000080 r6:60000093 r5:00000000 r4:8422a3c4
    [<827406c4>] (show_stack) from [<82751b58>] (__dump_stack lib/dump_stack.c:79 [inline])
    [<827406c4>] (show_stack) from [<82751b58>] (dump_stack+0xb8/0xe8 lib/dump_stack.c:120)
    [<82751aa0>] (dump_stack) from [<82741270>] (panic+0x130/0x378 kernel/panic.c:231)
     r7:830209b4 r6:84069ea4 r5:00000000 r4:844350d0
    [<82741140>] (panic) from [<80244924>] (__warn+0xb0/0x164 kernel/panic.c:605)
     r3:8404ec8c r2:00000000 r1:00000000 r0:830209b4
     r7:0000010f
    [<80244874>] (__warn) from [<82741520>] (warn_slowpath_fmt+0x68/0xd4 kernel/panic.c:628)
     r7:81363f70 r6:0000010f r5:83018e50 r4:00000000
    [<827414bc>] (warn_slowpath_fmt) from [<81363f70>] (__seqprop_assert include/linux/seqlock.h:271 [inline])
    [<827414bc>] (warn_slowpath_fmt) from [<81363f70>] (__seqprop_assert.constprop.0+0xf0/0x11c include/linux/seqlock.h:269)
     r8:5a109000 r7:0000000f r6:a568dac0 r5:89802300 r4:00000001
    [<81363e80>] (__seqprop_assert.constprop.0) from [<81364af0>] (u64_stats_update_begin include/linux/u64_stats_sync.h:128 [inline])
    [<81363e80>] (__seqprop_assert.constprop.0) from [<81364af0>] (macvlan_count_rx include/linux/if_macvlan.h:47 [inline])
    [<81363e80>] (__seqprop_assert.constprop.0) from [<81364af0>] (macvlan_broadcast+0x154/0x26c drivers/net/macvlan.c:291)
     r5:89802300 r4:8a927740
    [<8136499c>] (macvlan_broadcast) from [<81365020>] (macvlan_process_broadcast+0x258/0x2d0 drivers/net/macvlan.c:317)
     r10:81364f78 r9:8a86d000 r8:8a9c7e7c r7:8413aa5c r6:00000000 r5:00000000
     r4:89802840
    [<81364dc8>] (macvlan_process_broadcast) from [<802696a4>] (process_one_work+0x2d4/0x998 kernel/workqueue.c:2275)
     r10:00000008 r9:8404ec98 r8:84367a02 r7:ddfe6400 r6:ddfe2d40 r5:898dac80
     r4:8a86d43c
    [<802693d0>] (process_one_work) from [<80269dcc>] (worker_thread+0x64/0x54c kernel/workqueue.c:2421)
     r10:00000008 r9:8a9c6000 r8:84006d00 r7:ddfe2d78 r6:898dac94 r5:ddfe2d40
     r4:898dac80
    [<80269d68>] (worker_thread) from [<80271f40>] (kthread+0x184/0x1a4 kernel/kthread.c:292)
     r10:85247e64 r9:898dac80 r8:80269d68 r7:00000000 r6:8a9c6000 r5:89a2ee40
     r4:8a97bd00
    [<80271dbc>] (kthread) from [<80200114>] (ret_from_fork+0x14/0x20 arch/arm/kernel/entry-common.S:158)
    Exception stack(0x8a9c7fb0 to 0x8a9c7ff8)
    
    Fixes: 412ca1550cbe ("macvlan: Move broadcasts into a work queue")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a196c7dfdc7041c6e10844f793b7547bdfd3f19e
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Thu Jan 28 21:15:48 2021 +0200

    bus: omap_l3_noc: mark l3 irqs as IRQF_NO_THREAD
    
    [ Upstream commit 7d7275b3e866cf8092bd12553ec53ba26864f7bb ]
    
    The main purpose of l3 IRQs is to catch OCP bus access errors and identify
    corresponding code places by showing call stack, so it's important to
    handle L3 interconnect errors as fast as possible. On RT these IRQs will
    became threaded and will be scheduled much more late from the moment actual
    error occurred so showing completely useless information.
    
    Hence, mark l3 IRQs as IRQF_NO_THREAD so they will not be forced threaded
    on RT or if force_irqthreads = true.
    
    Fixes: 0ee7261c9212 ("drivers: bus: Move the OMAP interconnect driver to drivers/bus/")
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7bfe5a144da0ccbb6dff8ff827908e901db0348d
Author: Horia Geant <horia.geanta@nxp.com>
Date:   Sun Mar 7 22:47:36 2021 +0200

    arm64: dts: ls1043a: mark crypto engine dma coherent
    
    commit 4fb3a074755b7737c4081cffe0ccfa08c2f2d29d upstream.
    
    Crypto engine (CAAM) on LS1043A platform is configured HW-coherent,
    mark accordingly the DT node.
    
    Lack of "dma-coherent" property for an IP that is configured HW-coherent
    can lead to problems, similar to what has been reported for LS1046A.
    
    Cc: <stable@vger.kernel.org> # v4.8+
    Fixes: 63dac35b58f4 ("arm64: dts: ls1043a: add crypto node")
    Link: https://lore.kernel.org/linux-crypto/fe6faa24-d8f7-d18f-adfa-44fa0caa1598@arm.com
    Signed-off-by: Horia Geant <horia.geanta@nxp.com>
    Acked-by: Li Yang <leoyang.li@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 693202c3e15abd6274f6b12fa1b405121cd119de
Author: Phillip Lougher <phillip@squashfs.org.uk>
Date:   Wed Mar 24 21:37:35 2021 -0700

    squashfs: fix xattr id and id lookup sanity checks
    
    commit 8b44ca2b634527151af07447a8090a5f3a043321 upstream.
    
    The checks for maximum metadata block size is missing
    SQUASHFS_BLOCK_OFFSET (the two byte length count).
    
    Link: https://lkml.kernel.org/r/2069685113.2081245.1614583677427@webmail.123-reg.co.uk
    Fixes: f37aa4c7366e23f ("squashfs: add more sanity checks in id lookup")
    Signed-off-by: Phillip Lougher <phillip@squashfs.org.uk>
    Cc: Sean Nyekjaer <sean@geanix.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 31daf16cbd18ea3d109caa2403f87420884617d0
Author: Sean Nyekjaer <sean@geanix.com>
Date:   Wed Mar 24 21:37:32 2021 -0700

    squashfs: fix inode lookup sanity checks
    
    commit c1b2028315c6b15e8d6725e0d5884b15887d3daa upstream.
    
    When mouting a squashfs image created without inode compression it fails
    with: "unable to read inode lookup table"
    
    It turns out that the BLOCK_OFFSET is missing when checking the
    SQUASHFS_METADATA_SIZE agaist the actual size.
    
    Link: https://lkml.kernel.org/r/20210226092903.1473545-1-sean@geanix.com
    Fixes: eabac19e40c0 ("squashfs: add more sanity checks in inode lookup")
    Signed-off-by: Sean Nyekjaer <sean@geanix.com>
    Acked-by: Phillip Lougher <phillip@squashfs.org.uk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cdba20cdf253b0143391c41101417b54a44fefea
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Mar 25 11:02:31 2021 +0100

    x86/tlb: Flush global mappings when KAISER is disabled
    
    Jim Mattson reported that Debian 9 guests using a 4.9-stable kernel
    are exploding during alternatives patching:
    
      kernel BUG at /build/linux-dqnRSc/linux-4.9.228/arch/x86/kernel/alternative.c:709!
      invalid opcode: 0000 [#1] SMP
      Modules linked in:
      CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.9.0-13-amd64 #1 Debian 4.9.228-1
      Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
      Call Trace:
       swap_entry_free
       swap_entry_free
       text_poke_bp
       swap_entry_free
       arch_jump_label_transform
       set_debug_rodata
       __jump_label_update
       static_key_slow_inc
       frontswap_register_ops
       init_zswap
       init_frontswap
       do_one_initcall
       set_debug_rodata
       kernel_init_freeable
       rest_init
       kernel_init
       ret_from_fork
    
    triggering the BUG_ON in text_poke() which verifies whether patched
    instruction bytes have actually landed at the destination.
    
    Further debugging showed that the TLB flush before that check is
    insufficient because there could be global mappings left in the TLB,
    leading to a stale mapping getting used.
    
    I say "global mappings" because the hardware configuration is a new one:
    machine is an AMD, which means, KAISER/PTI doesn't need to be enabled
    there, which also means there's no user/kernel pagetables split and
    therefore the TLB can have global mappings.
    
    And the configuration is new one for a second reason: because that AMD
    machine supports PCID and INVPCID, which leads the CPU detection code to
    set the synthetic X86_FEATURE_INVPCID_SINGLE flag.
    
    Now, __native_flush_tlb_single() does invalidate global mappings when
    X86_FEATURE_INVPCID_SINGLE is *not* set and returns.
    
    When X86_FEATURE_INVPCID_SINGLE is set, however, it invalidates the
    requested address from both PCIDs in the KAISER-enabled case. But if
    KAISER is not enabled and the machine has global mappings in the TLB,
    then those global mappings do not get invalidated, which would lead to
    the above mismatch from using a stale TLB entry.
    
    So make sure to flush those global mappings in the KAISER disabled case.
    
    Co-debugged by Babu Moger <babu.moger@amd.com>.
    
    Reported-by: Jim Mattson <jmattson@google.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Hugh Dickins <hughd@google.com>
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Tested-by: Babu Moger <babu.moger@amd.com>
    Tested-by: Jim Mattson <jmattson@google.com>
    Link: https://lkml.kernel.org/r/CALMp9eRDSW66%2BXvbHVF4ohL7XhThoPoT0BrB0TcS0cgk=dkcBg@mail.gmail.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a1dcff84cbebf6b8202fe6786c11550e64c16181
Author: Sergei Trofimovich <slyfox@gentoo.org>
Date:   Fri Mar 12 21:08:27 2021 -0800

    ia64: fix ptrace(PTRACE_SYSCALL_INFO_EXIT) sign
    
    [ Upstream commit 61bf318eac2c13356f7bd1c6a05421ef504ccc8a ]
    
    In https://bugs.gentoo.org/769614 Dmitry noticed that
    `ptrace(PTRACE_GET_SYSCALL_INFO)` does not return error sign properly.
    
    The bug is in mismatch between get/set errors:
    
    static inline long syscall_get_error(struct task_struct *task,
                                         struct pt_regs *regs)
    {
            return regs->r10 == -1 ? regs->r8:0;
    }
    
    static inline long syscall_get_return_value(struct task_struct *task,
                                                struct pt_regs *regs)
    {
            return regs->r8;
    }
    
    static inline void syscall_set_return_value(struct task_struct *task,
                                                struct pt_regs *regs,
                                                int error, long val)
    {
            if (error) {
                    /* error < 0, but ia64 uses > 0 return value */
                    regs->r8 = -error;
                    regs->r10 = -1;
            } else {
                    regs->r8 = val;
                    regs->r10 = 0;
            }
    }
    
    Tested on v5.10 on rx3600 machine (ia64 9040 CPU).
    
    Link: https://lkml.kernel.org/r/20210221002554.333076-2-slyfox@gentoo.org
    Link: https://bugs.gentoo.org/769614
    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
    Reported-by: Dmitry V. Levin <ldv@altlinux.org>
    Reviewed-by: Dmitry V. Levin <ldv@altlinux.org>
    Cc: John Paul Adrian Glaubitz <glaubitz@physik.fu-berlin.de>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3abc8cbd044c5ed10bd5118e0f2c7c13823e9af2
Author: Sergei Trofimovich <slyfox@gentoo.org>
Date:   Fri Mar 12 21:08:23 2021 -0800

    ia64: fix ia64_syscall_get_set_arguments() for break-based syscalls
    
    [ Upstream commit 0ceb1ace4a2778e34a5414e5349712ae4dc41d85 ]
    
    In https://bugs.gentoo.org/769614 Dmitry noticed that
    `ptrace(PTRACE_GET_SYSCALL_INFO)` does not work for syscalls called via
    glibc's syscall() wrapper.
    
    ia64 has two ways to call syscalls from userspace: via `break` and via
    `eps` instructions.
    
    The difference is in stack layout:
    
    1. `eps` creates simple stack frame: no locals, in{0..7} == out{0..8}
    2. `break` uses userspace stack frame: may be locals (glibc provides
       one), in{0..7} == out{0..8}.
    
    Both work fine in syscall handling cde itself.
    
    But `ptrace(PTRACE_GET_SYSCALL_INFO)` uses unwind mechanism to
    re-extract syscall arguments but it does not account for locals.
    
    The change always skips locals registers. It should not change `eps`
    path as kernel's handler already enforces locals=0 and fixes `break`.
    
    Tested on v5.10 on rx3600 machine (ia64 9040 CPU).
    
    Link: https://lkml.kernel.org/r/20210221002554.333076-1-slyfox@gentoo.org
    Link: https://bugs.gentoo.org/769614
    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
    Reported-by: Dmitry V. Levin <ldv@altlinux.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: John Paul Adrian Glaubitz <glaubitz@physik.fu-berlin.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a69c8d135e6673b37ce93291579ad08b95e0d179
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Thu Jan 28 17:36:38 2021 -0500

    nfs: we don't support removing system.nfs4_acl
    
    [ Upstream commit 4f8be1f53bf615102d103c0509ffa9596f65b718 ]
    
    The NFSv4 protocol doesn't have any notion of reomoving an attribute, so
    removexattr(path,"system.nfs4_acl") doesn't make sense.
    
    There's no documented return value.  Arguably it could be EOPNOTSUPP but
    I'm a little worried an application might take that to mean that we
    don't support ACLs or xattrs.  How about EINVAL?
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d54d0aaa05379d5cfcd6db328bf595c51e4fbc98
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Mar 8 09:38:12 2021 +0100

    u64_stats,lockdep: Fix u64_stats_init() vs lockdep
    
    [ Upstream commit d5b0e0677bfd5efd17c5bbb00156931f0d41cb85 ]
    
    Jakub reported that:
    
        static struct net_device *rtl8139_init_board(struct pci_dev *pdev)
        {
                ...
                u64_stats_init(&tp->rx_stats.syncp);
                u64_stats_init(&tp->tx_stats.syncp);
                ...
        }
    
    results in lockdep getting confused between the RX and TX stats lock.
    This is because u64_stats_init() is an inline calling seqcount_init(),
    which is a macro using a static variable to generate a lockdep class.
    
    By wrapping that in an inline, we negate the effect of the macro and
    fold the static key variable, hence the confusion.
    
    Fix by also making u64_stats_init() a macro for the case where it
    matters, leaving the other case an inline for argument validation
    etc.
    
    Reported-by: Jakub Kicinski <kuba@kernel.org>
    Debugged-by: "Ahmed S. Darwish" <a.darwish@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Tested-by: "Erhard F." <erhard_f@mailbox.org>
    Link: https://lkml.kernel.org/r/YEXicy6+9MksdLZh@hirez.programming.kicks-ass.net
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1acd547ea05c518d277becc6a449415203582155
Author: Tong Zhang <ztong0001@gmail.com>
Date:   Sun Mar 7 22:25:30 2021 -0500

    atm: idt77252: fix null-ptr-dereference
    
    [ Upstream commit 4416e98594dc04590ebc498fc4e530009535c511 ]
    
    this one is similar to the phy_data allocation fix in uPD98402, the
    driver allocate the idt77105_priv and store to dev_data but later
    dereference using dev->dev_data, which will cause null-ptr-dereference.
    
    fix this issue by changing dev_data to phy_data so that PRIV(dev) can
    work correctly.
    
    Signed-off-by: Tong Zhang <ztong0001@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b7c445361734b398f2595ed09ad98ce0437e37e2
Author: Tong Zhang <ztong0001@gmail.com>
Date:   Sun Mar 7 22:25:29 2021 -0500

    atm: uPD98402: fix incorrect allocation
    
    [ Upstream commit 3153724fc084d8ef640c611f269ddfb576d1dcb1 ]
    
    dev->dev_data is set in zatm.c, calling zatm_start() will overwrite this
    dev->dev_data in uPD98402_start() and a subsequent PRIV(dev)->lock
    (i.e dev->phy_data->lock) will result in a null-ptr-dereference.
    
    I believe this is a typo and what it actually want to do is to allocate
    phy_data instead of dev_data.
    
    Signed-off-by: Tong Zhang <ztong0001@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ef822bd0d8701a1a901153ec0c8605e4b79101c3
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Sun Mar 7 01:12:56 2021 -0800

    net: wan: fix error return code of uhdlc_init()
    
    [ Upstream commit 62765d39553cfd1ad340124fe1e280450e8c89e2 ]
    
    When priv->rx_skbuff or priv->tx_skbuff is NULL, no error return code of
    uhdlc_init() is assigned.
    To fix this bug, ret is assigned with -ENOMEM in these cases.
    
    Reported-by: TOTE Robot <oslab@tsinghua.edu.cn>
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 55ef4f2c5d616589554306e65a603e6635371ff8
Author: Frank Sorenson <sorenson@redhat.com>
Date:   Mon Mar 8 12:12:13 2021 -0600

    NFS: Correct size calculation for create reply length
    
    [ Upstream commit ad3dbe35c833c2d4d0bbf3f04c785d32f931e7c9 ]
    
    CREATE requests return a post_op_fh3, rather than nfs_fh3. The
    post_op_fh3 includes an extra word to indicate 'handle_follows'.
    
    Without that additional word, create fails when full 64-byte
    filehandles are in use.
    
    Add NFS3_post_op_fh_sz, and correct the size calculation for
    NFS3_createres_sz.
    
    Signed-off-by: Frank Sorenson <sorenson@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7c34fb36d1a5f39e98e7b34249ebc33ad780a102
Author: Timo Rothenpieler <timo@rothenpieler.org>
Date:   Tue Feb 23 15:19:01 2021 +0100

    nfs: fix PNFS_FLEXFILE_LAYOUT Kconfig default
    
    [ Upstream commit a0590473c5e6c4ef17c3132ad08fbad170f72d55 ]
    
    This follows what was done in 8c2fabc6542d9d0f8b16bd1045c2eda59bdcde13.
    With the default being m, it's impossible to build the module into the
    kernel.
    
    Signed-off-by: Timo Rothenpieler <timo@rothenpieler.org>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 54567920b3bcfd704f27b818525ef01872a5e9a1
Author: Denis Efremov <efremov@linux.com>
Date:   Fri Mar 5 20:02:12 2021 +0300

    sun/niu: fix wrong RXMAC_BC_FRM_CNT_COUNT count
    
    [ Upstream commit 155b23e6e53475ca3b8c2a946299b4d4dd6a5a1e ]
    
    RXMAC_BC_FRM_CNT_COUNT added to mp->rx_bcasts twice in a row
    in niu_xmac_interrupt(). Remove the second addition.
    
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c8e18cb54708aa173bdc4dda9b3679d0c11ba42e
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Thu Mar 4 18:06:48 2021 -0800

    net: tehuti: fix error return code in bdx_probe()
    
    [ Upstream commit 38c26ff3048af50eee3fcd591921357ee5bfd9ee ]
    
    When bdx_read_mac() fails, no error return code of bdx_probe()
    is assigned.
    To fix this bug, err is assigned with -EFAULT as error return code.
    
    Reported-by: TOTE Robot <oslab@tsinghua.edu.cn>
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c3fab454a349742888603463351648f62cbc65be
Author: Dinghao Liu <dinghao.liu@zju.edu.cn>
Date:   Sun Jan 3 16:08:42 2021 +0800

    ixgbe: Fix memleak in ixgbe_configure_clsu32
    
    [ Upstream commit 7a766381634da19fc837619b0a34590498d9d29a ]
    
    When ixgbe_fdir_write_perfect_filter_82599() fails,
    input allocated by kzalloc() has not been freed,
    which leads to memleak.
    
    Signed-off-by: Dinghao Liu <dinghao.liu@zju.edu.cn>
    Reviewed-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 20b2ca1f0fa09e4f9ae5950bd5d3d74203998651
Author: Tong Zhang <ztong0001@gmail.com>
Date:   Sat Feb 27 22:55:50 2021 -0500

    atm: lanai: dont run lanai_dev_close if not open
    
    [ Upstream commit a2bd45834e83d6c5a04d397bde13d744a4812dfc ]
    
    lanai_dev_open() can fail. When it fail, lanai->base is unmapped and the
    pci device is disabled. The caller, lanai_init_one(), then tries to run
    atm_dev_deregister(). This will subsequently call lanai_dev_close() and
    use the already released MMIO area.
    
    To fix this issue, set the lanai->base to NULL if open fail,
    and test the flag in lanai_dev_close().
    
    [    8.324153] lanai: lanai_start() failed, err=19
    [    8.324819] lanai(itf 0): shutting down interface
    [    8.325211] BUG: unable to handle page fault for address: ffffc90000180024
    [    8.325781] #PF: supervisor write access in kernel mode
    [    8.326215] #PF: error_code(0x0002) - not-present page
    [    8.326641] PGD 100000067 P4D 100000067 PUD 100139067 PMD 10013a067 PTE 0
    [    8.327206] Oops: 0002 [#1] SMP KASAN NOPTI
    [    8.327557] CPU: 0 PID: 95 Comm: modprobe Not tainted 5.11.0-rc7-00090-gdcc0b49040c7 #12
    [    8.328229] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-48-gd9c812dda519-4
    [    8.329145] RIP: 0010:lanai_dev_close+0x4f/0xe5 [lanai]
    [    8.329587] Code: 00 48 c7 c7 00 d3 01 c0 e8 49 4e 0a c2 48 8d bd 08 02 00 00 e8 6e 52 14 c1 48 80
    [    8.330917] RSP: 0018:ffff8881029ef680 EFLAGS: 00010246
    [    8.331196] RAX: 000000000003fffe RBX: ffff888102fb4800 RCX: ffffffffc001a98a
    [    8.331572] RDX: ffffc90000180000 RSI: 0000000000000246 RDI: ffff888102fb4000
    [    8.331948] RBP: ffff888102fb4000 R08: ffffffff8115da8a R09: ffffed102053deaa
    [    8.332326] R10: 0000000000000003 R11: ffffed102053dea9 R12: ffff888102fb48a4
    [    8.332701] R13: ffffffffc00123c0 R14: ffff888102fb4b90 R15: ffff888102fb4b88
    [    8.333077] FS:  00007f08eb9056a0(0000) GS:ffff88815b400000(0000) knlGS:0000000000000000
    [    8.333502] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [    8.333806] CR2: ffffc90000180024 CR3: 0000000102a28000 CR4: 00000000000006f0
    [    8.334182] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [    8.334557] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [    8.334932] Call Trace:
    [    8.335066]  atm_dev_deregister+0x161/0x1a0 [atm]
    [    8.335324]  lanai_init_one.cold+0x20c/0x96d [lanai]
    [    8.335594]  ? lanai_send+0x2a0/0x2a0 [lanai]
    [    8.335831]  local_pci_probe+0x6f/0xb0
    [    8.336039]  pci_device_probe+0x171/0x240
    [    8.336255]  ? pci_device_remove+0xe0/0xe0
    [    8.336475]  ? kernfs_create_link+0xb6/0x110
    [    8.336704]  ? sysfs_do_create_link_sd.isra.0+0x76/0xe0
    [    8.336983]  really_probe+0x161/0x420
    [    8.337181]  driver_probe_device+0x6d/0xd0
    [    8.337401]  device_driver_attach+0x82/0x90
    [    8.337626]  ? device_driver_attach+0x90/0x90
    [    8.337859]  __driver_attach+0x60/0x100
    [    8.338065]  ? device_driver_attach+0x90/0x90
    [    8.338298]  bus_for_each_dev+0xe1/0x140
    [    8.338511]  ? subsys_dev_iter_exit+0x10/0x10
    [    8.338745]  ? klist_node_init+0x61/0x80
    [    8.338956]  bus_add_driver+0x254/0x2a0
    [    8.339164]  driver_register+0xd3/0x150
    [    8.339370]  ? 0xffffffffc0028000
    [    8.339550]  do_one_initcall+0x84/0x250
    [    8.339755]  ? trace_event_raw_event_initcall_finish+0x150/0x150
    [    8.340076]  ? free_vmap_area_noflush+0x1a5/0x5c0
    [    8.340329]  ? unpoison_range+0xf/0x30
    [    8.340532]  ? ____kasan_kmalloc.constprop.0+0x84/0xa0
    [    8.340806]  ? unpoison_range+0xf/0x30
    [    8.341014]  ? unpoison_range+0xf/0x30
    [    8.341217]  do_init_module+0xf8/0x350
    [    8.341419]  load_module+0x3fe6/0x4340
    [    8.341621]  ? vm_unmap_ram+0x1d0/0x1d0
    [    8.341826]  ? ____kasan_kmalloc.constprop.0+0x84/0xa0
    [    8.342101]  ? module_frob_arch_sections+0x20/0x20
    [    8.342358]  ? __do_sys_finit_module+0x108/0x170
    [    8.342604]  __do_sys_finit_module+0x108/0x170
    [    8.342841]  ? __ia32_sys_init_module+0x40/0x40
    [    8.343083]  ? file_open_root+0x200/0x200
    [    8.343298]  ? do_sys_open+0x85/0xe0
    [    8.343491]  ? filp_open+0x50/0x50
    [    8.343675]  ? exit_to_user_mode_prepare+0xfc/0x130
    [    8.343935]  do_syscall_64+0x33/0x40
    [    8.344132]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [    8.344401] RIP: 0033:0x7f08eb887cf7
    [    8.344594] Code: 48 89 57 30 48 8b 04 24 48 89 47 38 e9 1d a0 02 00 48 89 f8 48 89 f7 48 89 d6 41
    [    8.345565] RSP: 002b:00007ffcd5c98ad8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
    [    8.345962] RAX: ffffffffffffffda RBX: 00000000008fea70 RCX: 00007f08eb887cf7
    [    8.346336] RDX: 0000000000000000 RSI: 00000000008fd9e0 RDI: 0000000000000003
    [    8.346711] RBP: 0000000000000003 R08: 0000000000000000 R09: 0000000000000001
    [    8.347085] R10: 00007f08eb8eb300 R11: 0000000000000246 R12: 00000000008fd9e0
    [    8.347460] R13: 0000000000000000 R14: 00000000008fddd0 R15: 0000000000000001
    [    8.347836] Modules linked in: lanai(+) atm
    [    8.348065] CR2: ffffc90000180024
    [    8.348244] ---[ end trace 7fdc1c668f2003e5 ]---
    [    8.348490] RIP: 0010:lanai_dev_close+0x4f/0xe5 [lanai]
    [    8.348772] Code: 00 48 c7 c7 00 d3 01 c0 e8 49 4e 0a c2 48 8d bd 08 02 00 00 e8 6e 52 14 c1 48 80
    [    8.349745] RSP: 0018:ffff8881029ef680 EFLAGS: 00010246
    [    8.350022] RAX: 000000000003fffe RBX: ffff888102fb4800 RCX: ffffffffc001a98a
    [    8.350397] RDX: ffffc90000180000 RSI: 0000000000000246 RDI: ffff888102fb4000
    [    8.350772] RBP: ffff888102fb4000 R08: ffffffff8115da8a R09: ffffed102053deaa
    [    8.351151] R10: 0000000000000003 R11: ffffed102053dea9 R12: ffff888102fb48a4
    [    8.351525] R13: ffffffffc00123c0 R14: ffff888102fb4b90 R15: ffff888102fb4b88
    [    8.351918] FS:  00007f08eb9056a0(0000) GS:ffff88815b400000(0000) knlGS:0000000000000000
    [    8.352343] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [    8.352647] CR2: ffffc90000180024 CR3: 0000000102a28000 CR4: 00000000000006f0
    [    8.353022] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [    8.353397] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [    8.353958] modprobe (95) used greatest stack depth: 26216 bytes left
    
    Signed-off-by: Tong Zhang <ztong0001@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 164393ee6ca5894aa36bf49a74812261705c287b
Author: Tong Zhang <ztong0001@gmail.com>
Date:   Sat Feb 27 16:15:06 2021 -0500

    atm: eni: dont release is never initialized
    
    [ Upstream commit 4deb550bc3b698a1f03d0332cde3df154d1b6c1e ]
    
    label err_eni_release is reachable when eni_start() fail.
    In eni_start() it calls dev->phy->start() in the last step, if start()
    fail we don't need to call phy->stop(), if start() is never called, we
    neither need to call phy->stop(), otherwise null-ptr-deref will happen.
    
    In order to fix this issue, don't call phy->stop() in label err_eni_release
    
    [    4.875714] ==================================================================
    [    4.876091] BUG: KASAN: null-ptr-deref in suni_stop+0x47/0x100 [suni]
    [    4.876433] Read of size 8 at addr 0000000000000030 by task modprobe/95
    [    4.876778]
    [    4.876862] CPU: 0 PID: 95 Comm: modprobe Not tainted 5.11.0-rc7-00090-gdcc0b49040c7 #2
    [    4.877290] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-48-gd94
    [    4.877876] Call Trace:
    [    4.878009]  dump_stack+0x7d/0xa3
    [    4.878191]  kasan_report.cold+0x10c/0x10e
    [    4.878410]  ? __slab_free+0x2f0/0x340
    [    4.878612]  ? suni_stop+0x47/0x100 [suni]
    [    4.878832]  suni_stop+0x47/0x100 [suni]
    [    4.879043]  eni_do_release+0x3b/0x70 [eni]
    [    4.879269]  eni_init_one.cold+0x1152/0x1747 [eni]
    [    4.879528]  ? _raw_spin_lock_irqsave+0x7b/0xd0
    [    4.879768]  ? eni_ioctl+0x270/0x270 [eni]
    [    4.879990]  ? __mutex_lock_slowpath+0x10/0x10
    [    4.880226]  ? eni_ioctl+0x270/0x270 [eni]
    [    4.880448]  local_pci_probe+0x6f/0xb0
    [    4.880650]  pci_device_probe+0x171/0x240
    [    4.880864]  ? pci_device_remove+0xe0/0xe0
    [    4.881086]  ? kernfs_create_link+0xb6/0x110
    [    4.881315]  ? sysfs_do_create_link_sd.isra.0+0x76/0xe0
    [    4.881594]  really_probe+0x161/0x420
    [    4.881791]  driver_probe_device+0x6d/0xd0
    [    4.882010]  device_driver_attach+0x82/0x90
    [    4.882233]  ? device_driver_attach+0x90/0x90
    [    4.882465]  __driver_attach+0x60/0x100
    [    4.882671]  ? device_driver_attach+0x90/0x90
    [    4.882903]  bus_for_each_dev+0xe1/0x140
    [    4.883114]  ? subsys_dev_iter_exit+0x10/0x10
    [    4.883346]  ? klist_node_init+0x61/0x80
    [    4.883557]  bus_add_driver+0x254/0x2a0
    [    4.883764]  driver_register+0xd3/0x150
    [    4.883971]  ? 0xffffffffc0038000
    [    4.884149]  do_one_initcall+0x84/0x250
    [    4.884355]  ? trace_event_raw_event_initcall_finish+0x150/0x150
    [    4.884674]  ? unpoison_range+0xf/0x30
    [    4.884875]  ? ____kasan_kmalloc.constprop.0+0x84/0xa0
    [    4.885150]  ? unpoison_range+0xf/0x30
    [    4.885352]  ? unpoison_range+0xf/0x30
    [    4.885557]  do_init_module+0xf8/0x350
    [    4.885760]  load_module+0x3fe6/0x4340
    [    4.885960]  ? vm_unmap_ram+0x1d0/0x1d0
    [    4.886166]  ? ____kasan_kmalloc.constprop.0+0x84/0xa0
    [    4.886441]  ? module_frob_arch_sections+0x20/0x20
    [    4.886697]  ? __do_sys_finit_module+0x108/0x170
    [    4.886941]  __do_sys_finit_module+0x108/0x170
    [    4.887178]  ? __ia32_sys_init_module+0x40/0x40
    [    4.887419]  ? file_open_root+0x200/0x200
    [    4.887634]  ? do_sys_open+0x85/0xe0
    [    4.887826]  ? filp_open+0x50/0x50
    [    4.888009]  ? fpregs_assert_state_consistent+0x4d/0x60
    [    4.888287]  ? exit_to_user_mode_prepare+0x2f/0x130
    [    4.888547]  do_syscall_64+0x33/0x40
    [    4.888739]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [    4.889010] RIP: 0033:0x7ff62fcf1cf7
    [    4.889202] Code: 48 89 57 30 48 8b 04 24 48 89 47 38 e9 1d a0 02 00 48 89 f8 48 89 f71
    [    4.890172] RSP: 002b:00007ffe6644ade8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
    [    4.890570] RAX: ffffffffffffffda RBX: 0000000000f2ca70 RCX: 00007ff62fcf1cf7
    [    4.890944] RDX: 0000000000000000 RSI: 0000000000f2b9e0 RDI: 0000000000000003
    [    4.891318] RBP: 0000000000000003 R08: 0000000000000000 R09: 0000000000000001
    [    4.891691] R10: 00007ff62fd55300 R11: 0000000000000246 R12: 0000000000f2b9e0
    [    4.892064] R13: 0000000000000000 R14: 0000000000f2bdd0 R15: 0000000000000001
    [    4.892439] ==================================================================
    
    Signed-off-by: Tong Zhang <ztong0001@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9113d25060a05e6db046b76b6ef26e4fe64cb9b3
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Feb 18 23:30:58 2021 +1100

    powerpc/4xx: Fix build errors from mfdcr()
    
    [ Upstream commit eead089311f4d935ab5d1d8fbb0c42ad44699ada ]
    
    lkp reported a build error in fsp2.o:
    
      CC      arch/powerpc/platforms/44x/fsp2.o
      {standard input}:577: Error: unsupported relocation against base
    
    Which comes from:
    
      pr_err("GESR0: 0x%08x\n", mfdcr(base + PLB4OPB_GESR0));
    
    Where our mfdcr() macro is stringifying "base + PLB4OPB_GESR0", and
    passing that to the assembler, which obviously doesn't work.
    
    The mfdcr() macro already checks that the argument is constant using
    __builtin_constant_p(), and if not calls the out-of-line version of
    mfdcr(). But in this case GCC is smart enough to notice that "base +
    PLB4OPB_GESR0" will be constant, even though it's not something we can
    immediately stringify into a register number.
    
    Segher pointed out that passing the register number to the inline asm
    as a constant would be better, and in fact it fixes the build error,
    presumably because it gives GCC a chance to resolve the value.
    
    While we're at it, change mtdcr() similarly.
    
    Reported-by: kernel test robot <lkp@intel.com>
    Suggested-by: Segher Boessenkool <segher@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Acked-by: Feng Tang <feng.tang@intel.com>
    Link: https://lore.kernel.org/r/20210218123058.748882-1-mpe@ellerman.id.au
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9b67dcf5cc6a568d6b2482b3b1835dad45a6b82e
Author: Heiko Thiery <heiko.thiery@gmail.com>
Date:   Thu Feb 25 22:15:16 2021 +0100

    net: fec: ptp: avoid register access when ipg clock is disabled
    
    [ Upstream commit 6a4d7234ae9a3bb31181f348ade9bbdb55aeb5c5 ]
    
    When accessing the timecounter register on an i.MX8MQ the kernel hangs.
    This is only the case when the interface is down. This can be reproduced
    by reading with 'phc_ctrl eth0 get'.
    
    Like described in the change in 91c0d987a9788dcc5fe26baafd73bf9242b68900
    the igp clock is disabled when the interface is down and leads to a
    system hang.
    
    So we check if the ptp clock status before reading the timecounter
    register.
    
    Signed-off-by: Heiko Thiery <heiko.thiery@gmail.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Link: https://lore.kernel.org/r/20210225211514.9115-1-heiko.thiery@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
