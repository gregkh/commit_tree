ACPI: fix CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS

The following was observed by Steve Rostedt on 3.0.0-rc5
Backtrace:
irq 16: nobody cared (try booting with the "irqpoll" option)
Pid: 65, comm: irq/16-uhci_hcd Not tainted 3.0.0-rc5-test+ #94
Call Trace:
 [<ffffffff810aa643>] __report_bad_irq+0x37/0xc1
 [<ffffffff810aaa2d>] note_interrupt+0x14e/0x1c9
 [<ffffffff810a9a05>] ? irq_thread_fn+0x3c/0x3c
 [<ffffffff810a990e>] irq_thread+0xf6/0x1b1
 [<ffffffff810a9818>] ? irq_finalize_oneshot+0xb3/0xb3
 [<ffffffff8106b4d6>] kthread+0x9f/0xa7
 [<ffffffff814f1f04>] kernel_thread_helper+0x4/0x10
 [<ffffffff8103ca09>] ? finish_task_switch+0x7b/0xc0
 [<ffffffff814eac78>] ? retint_restore_args+0x13/0x13
 [<ffffffff8106b437>] ? __init_kthread_worker+0x5a/0x5a
 [<ffffffff814f1f00>] ? gs_change+0x13/0x13
handlers:
[<ffffffff810a912d>] irq_default_primary_handler threaded [<ffffffff8135eaa6>] usb_hcd_irq
[<ffffffff810a912d>] irq_default_primary_handler threaded [<ffffffff8135eaa6>] usb_hcd_irq
Disabling IRQ #16

The problem being that a device triggers boot interrupts (due to threaded
interrupt handling and masking of the IO-APIC), which are forwarded
to the PIRQ line of the device. These interrupts are not handled on the PIRQ
line because the interrupt handler is not present there.
This should have already been fixed by CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS.
However some parts of the quirk got lost in the ACPI merge. This is a resent of
the patch proposed in 2009.
See http://lkml.org/lkml/2009/9/7/192

Signed-off-by: Stefan Assmann <sassmann@kpanic.de>
Tested-by: Steven Rostedt <rostedt@goodmis.org>
Signed-off-by: Len Brown <len.brown@intel.com>

